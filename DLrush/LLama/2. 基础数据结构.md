## 1. embedding简介







## Additional: 编程补充知识

### 1. enum

#### enum (传统枚举)

`enum`是C和早期C++中引入的枚举类型，它用于定义一个常量组，每个成员都有一个整数值。默认情况下，第一个成员的值为0，每个后续成员的值依次增加1。你也可以为枚举的成员指定特定的值。

**特点**：

- `enum`成员的作用域不受限制，这意味着所有枚举值都在包含它们的作用域内直接可见。
- `enum`类型的变量实际上是整型，因此可以与整数进行隐式转换，这可能导致类型安全问题。

**示例**：

```c++
enum Color { RED, GREEN, BLUE };
Color color = RED;
int colorValue = color; // 隐式转换为整数
```

#### enum class (强类型枚举)

`enum class`是在C++11中引入的，用于解决传统`enum`的一些问题，特别是关于作用域和类型安全的问题。

**特点**：

- `enum class`成员的作用域被限制在枚举类内部，避免了命名冲突。
- `enum class`不允许隐式转换为整数，提高了类型安全。如果需要获取枚举值的整数表示，必须进行显式转换。
- 默认情况下，`enum class`的底层类型是`int`，但你可以指定使用其他整数类型作为底层类型。

**示例**：

```c++
enum class Color { RED, GREEN, BLUE };
Color color = Color::RED; // 必须使用作用域解析运算符(::)
int colorValue = static_cast<int>(color); // 需要显式转换为整数
```









### 2.`half`

在C++标准中，`half`类型并不是内置的。然而，一些第三方库、特定的编译器扩展或者硬件加速API（如CUDA）提供了对半精度浮点数的支持。例如，在CUDA中，`half`类型用于表示在GPU上进行计算时可以使用的半精度浮点数，以提升性能和减少内存占用。使用`half`时通常需要包含相应的头文件或者使用特定的库来支持半精度的运算和处理。













### 3.`CHECK`宏

考虑到CUDA部分的报错十分的简洁，几乎不可读，因此设计CHECK宏来获取详细的信息

```c++
#define CHECK(call)                                   \
do                                                    \
{                                                     \
    const cudaError_t error_code = call;              \
    if (error_code != cudaSuccess)                    \
    {                                                 \
        printf("CUDA Error:\n");                      \
        printf("    File:       %s\n", __FILE__);     \
        printf("    Line:       %d\n", __LINE__);     \
        printf("    Error code: %d\n", error_code);   \
        printf("    Error text: %s\n",                \
            cudaGetErrorString(error_code));          \
        exit(1);                                      \
    }                                                 \
} while (0)
```

* `/`用于换行
* **宏定义**：使用`#define CHECK(call)`定义了一个预处理宏，`call`是宏的参数，代表CUDA API调用。
* **do-while循环**：使用`do { ... } while (0)`是一种常见的技巧，确保宏的使用就像一个语句一样，即使在没有花括号的情况下也能正常工作。这种结构使得宏在任何地方使用时都需要以分号结束，从而避免潜在的编译问题。
* **错误检查**：通过`call`执行CUDA API调用，并将返回的错误码存储在局部变量`error_code`中。然后，检查`error_code`是否等于`cudaSuccess`。如果不等于，说明调用失败。
* **错误处理**：如果检测到错误，使用`printf`函数打印出错误信息，包括发生错误的文件名（`__FILE__`）、行号（`__LINE__`）、错误码（`error_code`）以及通过`cudaGetErrorString(error_code)`获取的错误描述文本。这有助于开发者快速定位问题。
* **终止程序**：最后，使用`exit(1)`终止程序。`exit(1)`表示因为发生错误而终止，非零的退出码通常表示程序异常结束。

使用这个宏可以使CUDA程序的错误处理更加简洁和一致。你只需要在每个CUDA API调用后面使用`CHECK()`宏，如`CHECK(cudaMalloc((void**)&devPtr, size));`，这样一旦调用失败就会自动打印出有关错误的详细信息并终止程序。这是一种有效的调试和错误检查手段。









### 4.利用Assert进行防御性检查（LLM_CHECK）

```c++
inline void llmAssert(bool result, const char* const file, int const line, std::string const& info = "")
{
    if (!result) {
        throwRuntimeError(file, line, info);
    }
}

#define LLM_CHECK(val) llmAssert(val, __FILE__, __LINE__)
#define LLM_CHECK_WITH_INFO(val, info)                                                                              \
    do {                                                                                                               \
        bool is_valid_val = (val);                                                                                     \
        if (!is_valid_val) {                                                                                           \
            llmAssert(is_valid_val, __FILE__, __LINE__, (info));                                                    \
        }                                                                                                              \
    } while (0)

```

* llmAssert检查传递的布尔表达式result是否为true，如果为false则抛出一个error
  * `result`：要检查的布尔表达式。
  * `file`：传递给`throwRuntimeError`函数的文件名，通常使用宏`__FILE__`来获取当前代码文件的名称。
  * `line`：传递给`throwRuntimeError`函数的行号，通常使用宏`__LINE__`来获取当前代码的行号。
  * `info`：一个可选的字符串参数，提供额外的错误信息，其默认值为空字符串。
* LLM_CHECK:只需要传递一个表达式`val`，如果`val`为`false`，则使用当前文件名和行号调用`llmAssert`函数。
* LLM_CHECK_WITH_INFO: 与`LLM_CHECK`宏类似，但它允许传递一个额外的信息字符串`info`，提供关于失败条件的更多上下文。这在需要对错误进行更详细说明时非常有用。
  * 首先评估表达式`val`，将结果存储在局部变量`is_valid_val`中。如果`is_valid_val`为`false`，则调用`llmAssert`函数，并传入文件名、行号和额外的错误信息`info`。

## 2.embedding实现

