## 1. find_package()

* find_package()会按照一定的预先顺序寻找项目外包的位置
* find_package()会按规则设置一系列固有字段，利用这些字段能够进行进一步操作



## 2. 编译器标识

`CMAKE_C_FLAGS` 是 CMake 中的一个固有变量，用于指定在编译 C 语言文件时传递给 C 编译器的标志。这个变量允许开发者在项目的 CMake 配置文件中添加或修改编译器标志，以控制 C 程序的编译过程。

CMake 提供了一系列这样的变量来管理不同语言的编译器标志，其中包括：

- **`CMAKE_C_FLAGS`**：用于 C 语言文件的编译器标志。
- **`CMAKE_CXX_FLAGS`**：用于 C++ 语言文件的编译器标志。
- **`CMAKE_CUDA_FLAGS`**：用于 CUDA 文件的编译器标志。

这些变量可以根据构建类型进一步细分，以便为不同的构建配置（如 Debug、Release）指定不同的编译器标志。例如：

- **`CMAKE_C_FLAGS_DEBUG`**：在 Debug 构建类型下用于 C 语言文件的编译器标志。
- **`CMAKE_CXX_FLAGS_DEBUG`**：在 Debug 构建类型下用于 C++ 语言文件的编译器标志。
- **`CMAKE_CUDA_FLAGS_DEBUG`**：在 Debug 构建类型下用于 CUDA 文件的编译器标志。

通过在项目的 `CMakeLists.txt` 文件中设置这些变量，开发者可以细粒度地控制编译过程。例如，可以添加优化标志、调试信息、警告级别等，以满足特定的开发、调试或发布需求。

==使用这些变量时，通常会将它们与现有值一起使用，以保留通过命令行或其他方式传递给 CMake 的任何默认或用户指定的标志。例如：==

```cmake
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
```

这条命令会添加 `-Wall` 标志来启用所有编译器警告，同时保留 `CMAKE_C_FLAGS` 变量中已经设置的任何其他标志。



### 编译器后缀

#### 构建型后缀

- **`DEBUG`**：用于Debug模式的构建。Debug模式下的编译通常包含调试信息，没有优化或只有最小优化，以便于调试。对应的标志变量，如`CMAKE_C_FLAGS_DEBUG`，用于添加或修改在Debug构建中特定于C语言的编译器标志。
- **`RELEASE`**：用于Release模式的构建。Release模式下的编译通常包括优化，不包含调试信息，旨在提高程序的运行效率。对应的标志变量，如`CMAKE_CXX_FLAGS_RELEASE`，用于添加或修改在Release构建中特定于C++语言的编译器标志。
- **`RELWITHDEBINFO`**：用于Release-With-Debug-Info模式的构建。这种模式在Release模式的基础上添加调试信息，结合了Release模式的优化和Debug模式的调试能力。对应的标志变量，如`CMAKE_CUDA_FLAGS_RELWITHDEBINFO`，用于在此模式下为CUDA文件设置编译器标志。
- **`MINSIZEREL`**：用于最小大小Release模式的构建。这种模式针对减小最终可执行文件的大小进行优化。对应的标志变量，如`CMAKE_C_FLAGS_MINSIZEREL`，用于在此模式下为C语言文件设置编译器标志。



#### 编程语言后缀

- **`C_FLAGS`**：指C语言的编译器标志。这些标志会传递给C编译器来控制C代码的编译过程。
- **`CXX_FLAGS`**：指C++语言的编译器标志。这些标志会传递给C++编译器来控制C++代码的编译过程。
- **`CUDA_FLAGS`**：指CUDA语言的编译器标志。这些标志会传递给NVCC编译器，NVCC是NVIDIA的CUDA编译器，用于编译CUDA代码。





#### 标志

##### GCC和Clang通用标志

- **`-Wall`**：启用大多数编译器警告。这是一个非常有用的标志，因为它可以帮助开发者发现潜在的代码问题。它并不包括所有可能的警告。
- **`-Wextra`**：启用额外的警告，超出 `-Wall` 的范围。使用 `-Wall -Wextra` 可以提供更全面的警告检查。
- **`-Werror`**：将所有警告当作错误处理。这意味着，任何警告都会导致编译失败，迫使开发者修正警告指出的问题。
- **`-O0`**：不进行优化，编译速度最快，生成的可执行文件通常较大，执行速度较慢。这对于调试非常有用。
- **`-O1`**、**`-O2`**、**`-O3`**：这些标志指定了不同级别的优化。`-O1` 提供了编译速度与代码执行效率之间的平衡。`-O2` 和 `-O3` 提供了更高级别的优化，可以生成执行速度更快的代码，但可能会增加编译时间。
- **`-Os`**：优化生成的代码，使其尽可能小。这对于内存受限的系统非常有用。
- **`-g`**：生成调试信息。这对于使用调试器分析程序非常重要。

##### 特定于语言的标志

- **`-std=c99`**、**`-std=c11`**、**`-std=c++11`**、**`-std=c++14`** 等：指定使用特定的语言标准进行编译。例如，`-std=c99` 指定使用 C 语言的 1999 年标准，`-std=c++11` 指定使用 C++ 语言的 2011 年标准。

##### NVIDIA CUDA特有标志

- **`-arch=sm_xx`**：指定CUDA代码编译目标的架构。`sm_xx` 代表特定的GPU架构版本。
- **`-Xcompiler`**：允许向底层编译器传递选项。例如，`-Xcompiler -Wall` 会将 `-Wall` 选项传递给用于编译CUDA程序的C/C++编译器。

编译器标志是编译器特定的，这意味着不同的编译器（例如GCC、Clang、MSVC、NVCC）可能支持不同的标志集。因此，使用标志时，应参考所使用编译器的文档。



## CUDA gencode与转义字符

### `-gencode`选项

- **`arch=compute_xx`**：指定虚拟架构的计算能力版本。这个选项告诉编译器生成中间PTX代码（Parallel Thread Execution，即并行线程执行代码）适用于指定的计算能力。PTX代码在运行时可以JIT（Just-In-Time）编译到GPU的本地指令集。指定较低版本的`compute_xx`可以提高兼容性，使得生成的代码能在更广泛的GPU上运行。
- **`code=sm_xx`**：指定真实架构的计算能力版本。`sm_xx`（Streaming Multiprocessor，即流处理器）指的是具体GPU的架构版本。这个选项告诉编译器直接为指定架构生成二进制代码，这样做通常可以获得更好的性能，因为不需要在运行时进行额外的编译步骤。

### 示例中的`-gencode`配置

在提供的示例中，设置了四组`-gencode`，分别为：

- `arch=compute_70,code=\"sm_70,compute_70\"`：为具有计算能力7.0的GPU生成代码，同时生成适用于该架构的PTX代码和二进制代码。
- `arch=compute_75,code=\"sm_75,compute_75\"`：为具有计算能力7.5的GPU生成代码，包括PTX和二进制。
- `arch=compute_80,code=\"sm_80,compute_80\"`：为具有计算能力8.0的GPU生成代码，包括PTX和二进制。
- `arch=compute_86,code=\"sm_86,compute_86\"`：为具有计算能力8.6的GPU生成代码，包括PTX和二进制。

### 转义字符

这样配置的目的是为了最大化代码的兼容性和性能。通过为多个架构生成PTX和二进制代码，可以确保代码在广泛的硬件上都能运行，并且在具体指定的硬件上运行得更快。包括PTX代码使得在未来的、更高计算能力的GPU上也能通过JIT编译运行，即使没有为那些具体计算能力直接生成二进制代码。

注意：在字符串中，`\"`用于在CMake字符串里嵌入双引号。这是因为CMake解析字符串时会消耗掉外层的引号，所以需要转义双引号以确保它们作为命令的一部分被正确传递给NVCC编译器。

`\`（反斜杠）用作转义字符。在字符串中，某些字符具有特殊的含义或不能直接表示，转义字符`\`用来给这些字符赋予特殊的意义或者去除这些意义，以便它们可以在字符串中被正确理解和处理。

在您提供的CMake命令中：

```cmake
set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS}  \
                      -gencode=arch=compute_70,code=\\\"sm_70,compute_70\\\" \
                      -gencode=arch=compute_75,code=\\\"sm_75,compute_75\\\" \
                      -gencode=arch=compute_80,code=\\\"sm_80,compute_80\\\" \
                      -gencode=arch=compute_86,code=\\\"sm_86,compute_86\\\" \
                        ")
```

`\\\"`是一个特殊的序列，用于在CMake处理这个字符串时插入一个实际的双引号`"`字符。这里是如何工作的：

- 第一个`\`是转义字符，它的作用是转义紧跟在后面的字符。
- 第二个`\`实际上是要在字符串中表示的字符，所以这对`\\`表示一个实际的反斜杠`\`字符。
- 紧接着的`\"`表示一个实际的双引号`"`字符。`\`用于转义双引号，因为双引号本身在字符串中用于界定字符串的开始和结束，所以如果要在字符串中表示一个双引号字符，就需要使用`\`来转义。

综合起来，`\\\"`在CMake处理这个字符串时会变成`\"`，这意味着在最终的字符串中插入了一个实际的双引号字符。这是必要的，因为NVCC编译器的`-gencode`选项需要`code=`部分的值被双引号包围，以正确地解析包含逗号的值（如`code="sm_70,compute_70"`）。

因此，这种用法确保了`-gencode`选项被正确地传递给了NVCC编译器，包括它所需的格式和双引号。