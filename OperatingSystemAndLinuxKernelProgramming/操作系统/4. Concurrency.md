## 1. Peterson Algorithm

### é—®é¢˜

è€ƒè™‘å¯¹äºä¹‹å‰çš„Race Conditionçš„ä»£ç 

```c
#include "thread.h"

#define N 10000000

void Tsum(){
    for(int i = 0; i < N; i++){
        sum++;
    }
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```

ç°åœ¨æˆ‘ä»¬å¸Œæœ›ç»™è¿™ä¸ªsum++åŠ ä¸€ä¸ªäº’æ–¥é”

```c
#include "thread.h"

#define N 10000000

void Tsum(){
    for(int i = 0; i < N; i++){
        lock();
        sum++;
        unlock();
    }
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```

äº’æ–¥é”çš„ä½œç”¨æ˜¯ï¼Œå½“è¿›å…¥lockä¹‹åï¼Œå‘Šè¯‰å…¶ä»–çº¿ç¨‹ä¸å…è®¸å¹¶å‘æ‰§è¡ŒæŸä¸€ä¸ªä»£ç æ®µï¼ˆæˆ–è€…è®¿é—®ç‰¹å®šçš„èµ„æºï¼‰ï¼Œä¹Ÿå°±æ˜¯æ‰§è¡ŒæŸä¸€æ®µæ—¶å¼ºåˆ¶ä¸²è¡Œï¼Œä»¥é¿å…race conditionã€‚

ä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªå€¼æ¥è¡¨ç¤ºæ˜¯å¦è§£é”ï¼Œä¸æ˜¯çš„è¯å°±æ­»å¾ªç¯ï¼Œä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæˆ‘ä»¬ä»¥ä¸€æ¬¡sum++ä¸ºä¾‹

```c
#include "thread.h"

#define N 10000000

int locked = UNLOCK;
void Tsum(){
retry:
    if(locked != UNLOCK){
        goto retry;
    }
    locked = LOCK;
    
    sum++;
    
    locked = UNLOCK;
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```



è¿™ä¸ªæ–¹å¼çœ‹èµ·æ¥å¾ˆç¾å¥½ï¼Œå®é™…ä¸Šæ˜¯é”™çš„ï¼ŒåŸå› æ˜¯å’Œä¹‹å‰fake alipayçš„ä¾‹å­ä¸€æ ·ï¼Œ==åˆ¤æ–­çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªéåŸå­æ€§çš„æ“ä½œ==

ä¾‹å¦‚æœ‰ä¸¤ä¸ªçº¿ç¨‹T1ï¼ŒT2

* T1æ‰§è¡Œç¬¬8è¡Œï¼Œåˆ¤æ–­æˆåŠŸï¼Œè¿›å…¥ç¬¬åè¡Œï¼Œä½†æ˜¯æ²¡æœ‰lockä¸Š
* æ­¤æ—¶ï¼Œåˆ‡æ¢ä¸Šä¸‹æ–‡ï¼ŒT2åˆ¤æ–­ç¬¬8è¡Œï¼Œåˆ¤æ–­æˆåŠŸï¼Œè¿›å…¥ç¬¬åè¡Œï¼Œæ­¤æ—¶ï¼ŒT1å’ŒT2éƒ½è¿›å…¥äº†lockåçš„ç¯å¢ƒï¼Œè¿™æ˜¯ä¸€ä¸ªå¤±è´¥çš„é”

äº‹å®ä¸Šï¼Œä¸Šé¢æåˆ°çš„æ˜¯å•å¤„ç†å™¨çš„æƒ…å†µï¼Œå¦‚æœä½ æ˜¯å¤šå¤„ç†å™¨å¹¶è¡Œçš„æƒ…å†µï¼Œä¸¤ä¸ªå¤„ç†å™¨åŒæ—¶è¿›å…¥lockæ˜¯å¾ˆå¸¸è§çš„ã€‚

å› æ­¤ï¼Œæ™®é€šçš„æ“ä½œæ˜¯æ— æ³•æ¨¡æ‹Ÿé”çš„ï¼Œå½’æ ¹åˆ°åº•æ˜¯ä»–ä»¬ä¸èƒ½åŸå­çš„å®Œæˆï¼Œåªè¦ä¸æ˜¯åŸå­çš„æ“ä½œï¼ˆéä¸€æ­¥å®Œæˆï¼‰ï¼Œå°±ä¼šå‡ºé—®é¢˜ã€‚å› æ­¤é€šå¸¸éœ€è¦ç”¨åˆ°ç¡¬ä»¶åº•å±‚çš„lockå‘½ä»¤ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰åªä½¿ç”¨éåŸå­æ€§çš„æ“ä½œå®Œæˆçš„é”çš„æ–¹å¼å‘¢ï¼Ÿæ˜¯æœ‰çš„ï¼Œè¿™å°±æ˜¯Petersonç®—æ³•ã€‚



**å†™åœ¨å‰é¢ï¼ŒPetersonç®—æ³•çš„è¦æ±‚ååˆ†è‹›åˆ»ï¼ŒåŒ…æ‹¬ä½†ä¸é™äº**

* **å˜é‡çš„å˜åŒ–éœ€è¦ä¿è¯ç¼“å­˜ä¸€è‡´æ€§**

  åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªå¤„ç†å™¨éƒ½æœ‰è‡ªå·±çš„ç¼“å­˜ã€‚Petersonç®—æ³•ä¾èµ–äºå…±äº«å˜é‡çš„æ›´æ–°ï¼Œè¿™äº›å˜é‡éœ€è¦åœ¨å„ä¸ªå¤„ç†å™¨çš„ç¼“å­˜ä¸­ä¿æŒä¸€è‡´ã€‚è¿™ä¼šå¯¼è‡´å¤§é‡çš„ç¼“å­˜ä¸€è‡´æ€§æµé‡ï¼Œå½±å“æ€§èƒ½ã€‚

* **ä¸¥æ ¼çš„å†…å­˜é¡ºåºä¿è¯**

  ç°ä»£å¤„ç†å™¨å¯èƒ½ä¼šé‡æ–°æ’åºæŒ‡ä»¤ä»¥ä¼˜åŒ–æ€§èƒ½ã€‚Petersonç®—æ³•éœ€è¦ä¸¥æ ¼çš„å†…å­˜é¡ºåºä¿è¯ï¼Œä»¥ç¡®ä¿æ ‡å¿—å˜é‡å’Œè½®è½¬å˜é‡çš„æ“ä½œæŒ‰é¢„æœŸé¡ºåºå‘ç”Ÿã€‚å¦åˆ™ï¼Œå¯èƒ½ä¼šå‡ºç°æ— æ³•é¢„æ–™çš„ç«æ€æ¡ä»¶ã€‚è¿™éœ€è¦ä½¿ç”¨å†…å­˜å±éšœæˆ–ç¼–è¯‘å™¨æŒ‡ä»¤æ¥ä¿è¯é¡ºåºä¸€è‡´æ€§ï¼Œè¿™åœ¨å®é™…ç¼–ç¨‹ä¸­å¢åŠ äº†å¤æ‚æ€§ã€‚

* **ä»…é€‚ç”¨äºä¸¤ä¸ªçº¿ç¨‹**





**åŒæ—¶ï¼Œè¯´æ˜å¤šå¤„ç†å™¨ä¸‹çš„ä¸€ä¸ªloadæ“ä½œ(æš‚æ—¶è®¤ä¸ºæ˜¯åŸå­æ“ä½œ)æ˜¯å¦‚ä½•å‘ç”Ÿçš„**

* å½“å¤šä¸ªå¤„ç†å™¨åŒæ—¶å°è¯•å†™å…¥åŒä¸€ä¸ªå˜é‡æ—¶ï¼Œç³»ç»Ÿä¼šè¿›è¡Œä»²è£ï¼Œç¡®ä¿åªæœ‰ä¸€ä¸ªå¤„ç†å™¨èƒ½æˆåŠŸæ‰§è¡Œå†™æ“ä½œã€‚

  - **ä»²è£æœºåˆ¶**ï¼šç¡¬ä»¶ä½¿ç”¨ä»²è£æœºåˆ¶æ¥å†³å®šå“ªä¸ªå¤„ç†å™¨ä¼˜å…ˆè¿›è¡Œå†™æ“ä½œï¼Œ==å…¶ä»–å¤„ç†å™¨ä¼šè¢«æš‚æ—¶é˜»å¡ï¼Œç›´åˆ°å†™æ“ä½œå®Œæˆã€‚==

* è®©æˆ‘ä»¬å…·ä½“åˆ†æä¸€ä¸‹åœ¨ä¸¤ä¸ªå¤„ç†å™¨åŒæ—¶å‘å˜é‡ `A` å†™å…¥å€¼æ—¶å¯èƒ½å‘ç”Ÿçš„æƒ…å†µï¼š

  1. **åŒæ—¶å†™å…¥å°è¯•**ï¼š

     - å¤„ç†å™¨ P1 å’Œ P2 éƒ½å°è¯•å†™å…¥å˜é‡ `A`ï¼Œå‡è®¾å†™å…¥çš„å€¼åˆ†åˆ«æ˜¯ `1` å’Œ `2`ã€‚

  2. **ç¼“å­˜ä¸€è‡´æ€§åè®®ä½œç”¨**ï¼š

     - ä¸¤ä¸ªå¤„ç†å™¨çš„ç¼“å­˜æ§åˆ¶å™¨ä¼šé€šè¿‡ç¼“å­˜ä¸€è‡´æ€§åè®®æ¥åè°ƒå†™å…¥æ“ä½œã€‚

       > **ç¼“å­˜è¡Œæ— æ•ˆ**ï¼šå¦‚æœä¸€ä¸ªå¤„ç†å™¨ä¿®æ”¹äº†æŸä¸ªç¼“å­˜è¡Œï¼Œå…¶ä»–å¤„ç†å™¨ä¸­çš„è¯¥ç¼“å­˜è¡Œä¼šè¢«æ ‡è®°ä¸ºæ— æ•ˆã€‚
       >
       > **ç¼“å­˜è¡Œæ›´æ–°**ï¼šå½“ä¸€ä¸ªå¤„ç†å™¨å†™å…¥å…±äº«å˜é‡æ—¶ï¼Œå®ƒä¼šå‘å…¶ä»–å¤„ç†å™¨å‘é€æ¶ˆæ¯ï¼Œæ›´æ–°å®ƒä»¬çš„ç¼“å­˜æˆ–ä½¿å®ƒä»¬çš„ç¼“å­˜è¡Œæ— æ•ˆã€‚

     - å¦‚æœ P1 å…ˆè·å–åˆ°å†™å…¥æƒé™ï¼Œå®ƒå°†å†™å…¥ `1`ï¼Œå¹¶é€šè¿‡ä¸€è‡´æ€§åè®®é€šçŸ¥ P2ï¼Œä½¿ P2 çš„ç¼“å­˜è¡Œæ— æ•ˆã€‚

     - æ¥ä¸‹æ¥ï¼ŒP2 å°è¯•å†™å…¥ `2` æ—¶ï¼Œå¿…é¡»å…ˆä»å†…å­˜è¯»å–æœ€æ–°çš„å€¼ï¼Œæˆ–ç›´æ¥è¿›è¡Œå†™å…¥ã€‚

  3. **ä»²è£æœºåˆ¶**ï¼š

     - å¤„ç†å™¨ä¹‹é—´é€šè¿‡ä»²è£æœºåˆ¶å†³å®šå†™å…¥çš„é¡ºåºã€‚å‡è®¾ P1 è·èƒœï¼Œå®ƒå®Œæˆå†™å…¥ `1` åï¼ŒP2 å†è¿›è¡Œå†™å…¥ `2`ã€‚
     - æœ€ç»ˆå†…å­˜ä¸­çš„å€¼æ˜¯ `2`ï¼Œå› ä¸º P2 çš„å†™å…¥è¦†ç›–äº† P1 çš„å†™å…¥ã€‚

  4. **æ€»çº¿é”æˆ–ç¼“å­˜é”**ï¼š

     - ç¡®ä¿å†™å…¥æ“ä½œçš„åŸå­æ€§ï¼Œé€šè¿‡é”ä½æ€»çº¿æˆ–ç¼“å­˜è¡Œï¼Œé˜²æ­¢å…¶ä»–å¤„ç†å™¨å¹²æ‰°ã€‚

==è¿™ä½“ç°äº†å¤šå¤„ç†å™¨çš„loadæ“ä½œå®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä¸å•å¤„ç†å™¨å¹¶å‘çœ‹ä½œæ˜¯ç±»ä¼¼çš„æ“ä½œï¼Œå³ä¸ºâ€œå¤„ç†å™¨æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªçº¿ç¨‹çš„ä¸€ä¸ªæŒ‡ä»¤è¿è¡Œâ€ï¼Œä¸€åŒè®¨è®ºã€‚==ï¼ˆå› ä¸ºä¸»è¦å‘ç”Ÿäº‰è®®çš„ç‚¹å°±æ˜¯æ¶‰åŠåˆ°å…±äº«å†…å­˜ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†æ˜¯å®Œå…¨å¹¶è¡Œè¿˜æ˜¯å•å¤„ç†å™¨å¹¶å‘æ— å…³ç´§è¦ï¼‰







### Petersonç®—æ³•

Petersonç®—æ³•æå‡ºäº†ä¸€ç§äº’æ–¥çš„åè®®ï¼Œå®ƒçš„æ¨¡å‹æ˜¯åŸºäºå…±äº«å†…å­˜æ¨¡å‹ï¼Œ

ç®€å•æ¥è¯´ï¼Œä¸ºäº†è§£å†³ä¹‹å‰æåˆ°çš„â€œä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿›å…¥äº†é”â€çš„æƒ…å†µï¼ŒPetersonç®—æ³•ä½¿ç”¨äº†ä¸€æ¬¡é¢å¤–çš„åˆ¤æ–­æ¥å¤„ç†è¿™ç§æƒ…å†µã€‚

* ä¸¤ä¸ªçº¿ç¨‹è‹¥æ˜¯éœ€è¦è¿›å…¥é”éƒ½éœ€è¦å£°æ˜(flag = true)
* ä¸¤ä¸ªçº¿ç¨‹åœ¨è¿›è¡Œæ“ä½œå‰éœ€è¦é¦–å…ˆåœ¨ä¸€ä¸ªå…¬å…±boardä¸Šå†™ä¸Šå¯¹æ–¹çº¿ç¨‹çš„åå­—
* ä¸¤ä¸ªçº¿ç¨‹åœ¨è¿›è¡Œæ“ä½œå‰éœ€è¦åˆ¤æ–­
  * å¯¹æ–¹æ˜¯å¦ä¹Ÿè¿›å…¥é”ï¼ˆflag == true)
  * å¦‚æœå¯¹æ–¹ä¹Ÿè¿›å…¥é”ï¼Œåˆ¤æ–­boardæ˜¯å¦ä¸ºè‡ªå·±çš„åå­—ï¼Œå¦‚æœä¸æ˜¯åˆ™ç­‰å¾…ï¼ˆè°¦è®©ï¼‰
  * å¦‚æœå¯¹æ–¹æœªè¿›å…¥é”ï¼Œç›´æ¥æ‰§è¡Œ
  * ç»“æŸåé‡ç½®è‡ªå·±çš„flag=false

```c
#include "thread.h"

#define A 1
#define B 2

atomic_int nested;
atomic_long count;

/*
    è¿™ä¸ªå‡½æ•°å®ç°äº†ä¸€ä¸ªå¯¹countåŸå­åŠ å’ŒåŸå­å‡çš„è¿‡ç¨‹ï¼Œç”¨äºéªŒè¯å¯¹ä¸´ç•ŒåŒºçš„è®¿é—®æ§åˆ¶ã€‚
    - `count` å˜é‡ç”¨äºè®°å½•è¿›å…¥ä¸´ç•ŒåŒºçš„æ¬¡æ•°ã€‚
    - `nested` å˜é‡ç”¨äºç¡®ä¿ä¸´ç•ŒåŒºçš„äº’æ–¥è®¿é—®ï¼Œå³åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨ä¸´ç•ŒåŒºå†…ã€‚

    å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š
    1. å°†countçš„å€¼å¢åŠ 1ï¼Œè¿”å›å¢åŠ å‰çš„å€¼ï¼Œå¹¶å°†å…¶èµ‹ç»™`cnt`ã€‚
    2. å°†nestedçš„å€¼å¢åŠ 1ï¼Œå¹¶æ–­è¨€å¢åŠ å‰çš„å€¼ä¸º0ï¼ˆç¡®ä¿æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨ä¸´ç•ŒåŒºå†…ï¼‰ã€‚
    3. å°†nestedçš„å€¼å‡å°‘1ï¼Œä»¥è¡¨ç¤ºçº¿ç¨‹ç¦»å¼€äº†ä¸´ç•ŒåŒºã€‚
    
    å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹åœ¨ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆç¨‹åºå°±ä¼šè§¦å‘æ–­è¨€assertï¼Œè¿™ä¸ªå‡½æ•°ä¸€å®šç¨‹åº¦ä¸Šèƒ½å±•ç°ç¨‹åºçš„çŠ¶æ€æœºï¼Œä½†æ˜¯å¹¶ä¸èƒ½ä¿è¯ç®—æ³•çš„æ­£ç¡®æ€§
*/
void critical_section(){
    long cnt = atomic_fetch_add(&count, 1);
    assert(atomic_fetch_add(&nested, 1) == 0);
    atomic_fetch_add(&nested, -1);
}

// volatileå…³é—­äº†ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œä¸»è¦ç›®çš„æ˜¯é˜²æ­¢ç¼–è¯‘å™¨ç¼“å­˜è¿™äº›å˜é‡åˆ°å¯„å­˜å™¨ä¸­
// è¿™å°±å¯èƒ½ä¼šå¯¼è‡´ï¼Œä¸€ä¸ªçº¿ç¨‹å¯¹å˜é‡çš„ä¿®æ”¹å¯¹å¦ä¸€ä¸ªçº¿ç¨‹ä¸å¯è§
// volatileå¼ºåˆ¶ä¿è¯ä¸¤ä¸ªçº¿ç¨‹ä»å†…å­˜è¯»å–
int volatile x = 0, y = 0, turn = A;


void TA(){
    while(1){
        x = 1;					// å£°æ˜éœ€è¦å†™å…¥
        turn = B;				// å°†å…±äº«çŠ¶æ€è½¬æ¢ä¸ºB
        while(y && turn == B);	// åˆ¤æ–­æ˜¯å¦å¯ä»¥è¿›å…¥é”åŒº
        critical_section();		// æ‰§è¡Œä»»åŠ¡
        x = 0;					// å£°æ˜ä»»åŠ¡å®Œæˆ
    }
}

void TB(){
    while(1){
        y=1;					
        turn = A;
        while(x && turn == A);
        critical_section();
        y=0;
    }
}
```

å¯ä»¥å‘ç°ï¼ŒPetersonç®—æ³•é€šè¿‡ä¸€ä¸ªâ€œè°¦è®©â€æœºåˆ¶ï¼Œå·§å¦™åœ°æŠ¹å»äº†ä¹‹å‰`x=1`å’Œ`turn = B`çš„éåŸå­æ€§

å¦‚æœæ²¡æœ‰è¿™ä¸ªè°¦è®©æœºåˆ¶ï¼ˆä¾‹å¦‚å¯¹äºThreadA`x = 1;turn=A;while(y && turn==B);`)ï¼Œæ­¤æ—¶å­˜åœ¨ä¸€ä¸ªæ‰§è¡Œé¡ºåº

`TA:x=1`

`TB:y=1`

`TA:turn=A`

`TA:while(y && turn==B);`:æ­¤æ—¶turn=Aï¼Œå› æ­¤ç›´æ¥è¿›å…¥é”

`TB:turn=B`

`TB:while(x && turn==A);`ï¼šæ­¤æ—¶turn=B,å› æ­¤ç›´æ¥è¿›å…¥é”



è¿™é‡Œå¹¶ä¸å‡å®š `while (flag[1] && turn == 1);` æ˜¯åŸå­çš„ã€‚ç›¸åï¼Œ**Petersonç®—æ³•åˆ©ç”¨äº†ç°ä»£å¤„ç†å™¨æä¾›çš„åŸºæœ¬å†…å­˜æ“ä½œçš„åŸå­æ€§æ¥å®ç°å®ƒçš„äº’æ–¥æœºåˆ¶ã€‚**æˆ–è€…è¯´Petersonç®—æ³•çš„åŸºç¡€æ˜¯è¯»å†™æ“ä½œåœ¨ç°ä»£å¤„ç†å™¨ä¸­çš„ä¸²è¡Œæ€§ï¼ˆå³ä¸¤ä¸ªçº¿ç¨‹å¯¹ä¸€ä¸ªå…±äº«å˜é‡çš„å†™å…¥ä¸€å®šä¼šè®©è¿™ä¸ªå…±äº«å˜é‡ç»å†ä¸¤æ¬¡çŠ¶æ€çš„å˜æ¢ï¼‰



å…·ä½“çš„petersonç®—æ³•çš„çŠ¶æ€æ ‘å¯ä»¥è¢«ç”»å‡ºä»¥è¯æ˜å…¶æ­£ç¡®æ€§ï¼ŒçŠ¶æ€å¤ªå¤šæ‡’çš„ç”»äº†

![image-20240731164204710](./assets/image-20240731164204710.png)

### ç°ä»£å¤„ç†å™¨ä¸ŠPetersonç®—æ³•çš„å±€é™æ€§

å®ƒçš„å±€é™æ€§å°±ä½“ç°åœ¨æ²Ÿæ§½çš„ç¼–è¯‘å™¨ä¼˜åŒ–å’Œä¹±åºæ‰§è¡Œ

æ¢å¥è¯è¯´ï¼Œå®ƒçš„å†…å­˜åºæ— æ³•è¢«ä¿è¯

å¯ä»¥å‘ç°

![image-20240731164904002](./assets/image-20240731164904002.png)

å®ƒè¿è¡Œäº†å¤§æ¦‚22359328æ¬¡å°±ä¼šå‡ºé”™ï¼Œä¹Ÿå°±æ˜¯å®ƒå†…éƒ¨è¿è¡Œæ—¶æ ¹æœ¬ä¸è·Ÿç€çŠ¶æ€æœºå·²æœ‰çŠ¶æ€æ¥æ‰§è¡Œ





è¿™ä¸ªçš„è§£å†³æ–¹å¼æ˜¯æ·»åŠ barrier

```c++

#include "thread.h"

#define A 1
#define B 2

#define BARRIER __sync_synchronize()

atomic_int nested;
atomic_long count;

void critical_section() {
  long cnt = atomic_fetch_add(&count, 1);
  int i = atomic_fetch_add(&nested, 1) + 1;
  if (i != 1) {
    printf("%d threads in the critical section @ count=%ld\n", i, cnt);
    assert(0);
  }
  atomic_fetch_add(&nested, -1);
}

int volatile x = 0, y = 0, turn;

void TA() {
  while (1) {
    x = 1;                   BARRIER;
    turn = B;                BARRIER; // <- this is critcal for x86
    while (1) {
      if (!y) break;         BARRIER;
      if (turn != B) break;  BARRIER;
    }
    critical_section();
    x = 0;                   BARRIER;
  }
}

void TB() {
  while (1) {
    y = 1;                   BARRIER;
    turn = A;                BARRIER;
    while (1) {
      if (!x) break;         BARRIER;
      if (turn != A) break;  BARRIER;
    }
    critical_section();
    y = 0;                   BARRIER;
  }
}

int main() {
  create(TA);
  create(TB);
}
```

è¿™é‡Œæ·»åŠ BARRIERä¹‹åï¼Œå¯ä»¥å‘ç°ï¼Œwhileä¸­çš„åˆ¤æ–­é¡ºåºä¹Ÿæ˜¯éœ€è¦äººä¸ºè§„å®šçš„ã€‚å¿…é¡»æ˜¯å…ˆåˆ¤æ–­flagååˆ¤æ–­turnã€‚

![image-20240731165050071](./assets/image-20240731165050071.png)

æ­¤æ—¶å°±èƒ½æ­£å¸¸æ‰§è¡Œäº†ã€‚

`__sync_synchronize()`ä¸ä»…ä¸å…è®¸ç¼–è¯‘å™¨éšæ„reorderï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªmemory_barrier







## 2. å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ï¼ˆè‡ªæ—‹é”ï¼Œäº’æ–¥é”ä¸Futexï¼‰



### 2.1 Motivation

Petersonçš„å¹¶å‘å®ç°æ˜¯å¾ˆä½æ•ˆçš„ï¼ŒçœŸæ­£çš„å¹¶å‘

ä½†æ˜¯Petersonç®—æ³•ç»™äº’æ–¥æä¾›äº†ä¸€ä¸ªä»£ç å±‚é¢çš„å®ç°



äº’æ–¥ï¼ˆmutual exclusionï¼‰åŸºæœ¬ä¸Šå°±æ˜¯å®ç°ä¸€ä¸ªlock/unlockçš„APIï¼Œè¿™ä¸ªlock/unlockä¹‹é—´æ˜¯é”çš„å¯¹è±¡ï¼Œè¿™æ˜¯ä¸€ä¸ªå…·æœ‰æ’ä»–æ€§çš„é”ï¼Œè¿™æ„å‘³ç€å¯¹äºé”çš„å¯¹è±¡ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„lock**ä¸èƒ½è¿”å›ã€‚**



ä»ç¬¬ä¸€ç« ä¸­Petersonç®—æ³•çš„ç¤ºä¾‹å¯ä»¥çœ‹å‡ºï¼Œå®ç°äº’æ–¥é”çš„æ ¹æœ¬å›°éš¾åœ¨äºloadå’Œstoreæ˜¯åˆ†å¼€çš„ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½åŒæ—¶è¯»å†™å…±äº«å†…å­˜ï¼Œè¿™å¯¼è‡´äº†ç¨‹åºè·å¾—çš„æ‰€æœ‰ä¿¡æ¯éƒ½æ˜¯â€œå†å²ä¿¡æ¯â€ï¼Œä½ å¹¶ä¸èƒ½ä¿è¯å®ƒåœ¨å½“å‰æƒ…å†µä¸‹ä¸éœ€æ±‚ç¬¦åˆã€‚



ç°åœ¨ï¼Œä½ éœ€è¦åšçš„å°±æ˜¯å¯¹äºç¬¦åˆè¦æ±‚çš„å¤šä¸ªçº¿ç¨‹ï¼Œè®©ä»–ä»¬è¿›å…¥ç­‰å¾…åŒºï¼ˆé”ï¼‰ï¼Œä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿæ“ä½œã€‚



è¦å®Œæˆè¿™ä¸ªç›®æ ‡ï¼Œ

* è¦ä¹ˆæ˜¯æå‡ºç®—æ³•ï¼ˆPetersonï¼‰ï¼Œ

* è¦ä¹ˆå°±æ˜¯æ±‚å·±ä¸å¦‚æ±‚äººï¼ˆæˆ‘ä»¬**ç›´æ¥è®©ç¡¬ä»¶å¤šä¸€ä¸ªæ“ä½œï¼Œä½¿å¾—storeå’Œloadèƒ½å¤Ÿæˆä¸ºåŸå­æ“ä½œ**ï¼‰

  æ¢å¥è¯è¯´ï¼Œæ­¤æ—¶æœ‰å¤šä¸ªçº¿ç¨‹è¯·æ±‚å°†sum+1ï¼Œåœ¨è¿™ä¸€ä¸ªæ—¶é—´æ­¥ï¼Œç¡¬ä»¶ç›´æ¥æ—¶åœï¼Œå®ƒä¼šçœ‹ä¸€çœ‹æœ‰å“ªäº›çº¿ç¨‹è¯·æ±‚+1ï¼Œç„¶åé€‰ä¸€ä¸ªå¹¸è¿å„¿åœ¨è¿™ä¸ªæ—¶é—´æ­¥å®Œæˆ`load,calculate,store`ï¼Œå¹¶å°†å…¶ä»–è¯·æ±‚å»¶åã€‚è¿™æ ·å°±å®Œç¾çš„è§£å†³äº†race conditionçš„é—®é¢˜

  > è¿™ä¹Ÿæ˜¯x86æ¶æ„çš„å“²å­¦ï¼Œæ—¢ç„¶è¿™ä¸ªå®ç°å¾ˆéº»çƒ¦ï¼Œé‚£ä¸å¦‚åŠ ä¸€æ¡æŒ‡ä»¤äº¤ç»™ç¡¬ä»¶åš

```c++
#include "thread.h"

#define N 10000000

long sum = 0;

void Tsum(){
        for(int i = 0; i < N; i++)
        {
                asm volatile("lock addq $1, %0" : "+m"(sum));
        }

}

int main(){
        create(Tsum);

        create(Tsum);

        join();

        printf("sum = %ld\n", sum);

}
```



![image-20240801155925763](./assets/image-20240801155925763.png)

æ­¤å¤„çš„lockæ˜¯ä¸€ä¸ª**x86æ±‡ç¼–æŒ‡ä»¤å‰ç¼€**ï¼Œç”¨äºç¡®ä¿åç»­æŒ‡ä»¤åœ¨å¤šå¤„ç†å™¨ç¯å¢ƒä¸­çš„åŸå­æ€§ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™æ„å‘³ç€ `lock` å‰ç¼€ä½¿å¾—éšåçš„æŒ‡ä»¤åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«å…¶ä»–å¤„ç†å™¨ä¸­æ–­ï¼Œä»è€Œç¡®ä¿å¯¹å…±äº«å†…å­˜çš„æ“ä½œæ˜¯åŸå­çš„ã€‚

* `addq $1, %0` çš„æ„æ€æ˜¯å°†ç«‹å³æ•° 1 åŠ åˆ°æ“ä½œæ•° `%0` ä¸Šã€‚
* `%0` æ˜¯å†…è”æ±‡ç¼–ä¸­çš„å ä½ç¬¦ï¼Œç”± `"+m"(sum)` æŒ‡å®šã€‚`sum` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œ`+m` è¡¨ç¤ºè¯¥æ“ä½œæ•°æ˜¯å†…å­˜æ“ä½œæ•°ï¼Œå¹¶ä¸”å°†è¢«è¯»å†™ã€‚









### 2.2 è‡ªæ—‹é” (Spin lock)

> **ç®€å•æ¥è¯´ï¼Œè‡ªæ—‹é”å°±æ˜¯ï¼Œä½ è‡ªå·±çŠ¶æ€ä¸ºlockï¼Œæœ‰ä¸€ä¸ªå…¬å…±çŠ¶æ€ä¸ºunlockï¼Œæ¯ä¸ªçº¿ç¨‹æ­»å¾ªç¯çš„ä¸å…¬å…±çŠ¶æ€äº¤æ¢ï¼Œè‹¥è‡ªå·±çš„çŠ¶æ€å˜ä¸ºunlockå³è§†ä¸ºè¿›å…¥é”ã€‚**
>
> è¿™é‡Œæ˜¯åˆ©ç”¨äº†åŸå­æŒ‡ä»¤xchgå®ç°çš„

`xchg`

```c
// è¯¥æ“ä½œå°†ä¸€ä¸ªæ–°å€¼å­˜å‚¨åˆ°æŒ‡å®šçš„å†…å­˜ä½ç½®ï¼Œå¹¶è¿”å›è¯¥ä½ç½®ä¹‹å‰çš„æ—§å€¼ã€‚è®©æˆ‘ä»¬è¯¦ç»†è§£æè¿™æ®µä»£ç ï¼š
int xchg(volatile int *adder, int newval){
    // è¿™é‡Œxchgæœ¬æ¥å°±æ˜¯åŸå­çš„ï¼Œå¯ä»¥ä¸ç”¨lock
	asm volatile("lock xchg %0, %1" : "+m"(*adder), "=a"(result) : "1"(newval));
    return result
}
```

å…·ä½“çš„åŸå­æŒ‡ä»¤å‚è€ƒæ‰‹å†Œ`stdatomic.h`

åˆ©ç”¨è¿™äº›åŸå­æŒ‡ä»¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç®€åŒ–ä¹‹å‰çš„åè®®

```c
int table  = YES;
void lock(){
retry:
    // å°†flagé€šè¿‡äº¤æ¢è®¾ç½®ä¸ºNOPEå¹¶è·å–åŸæœ¬tableä¸­çš„å€¼
    int got = xchg(&table, NOPE);
    // got == YESåˆ™è¿›å…¥é”
    if(got == NOPE){
        goto retry;
    }
    assert(got == YES);
}

void unlock(){
    xchg(&table, YES);
}
```

æ›´ç®€åŒ–ä¸€äº›å¯ä»¥è·å¾—

```c
int lock = 0;
void lock(){while(xchg(&locked,1));}
void unlock(){xchg(&locked,0);}
```

è¿™å°±è·å¾—äº†ä¸€ä¸ªè‡ªæ—‹é”







### 2.3 åŸå­æŒ‡ä»¤çš„æ¨¡å‹

#### æŒ‡ä»¤å‰ç¼€lock

![image-20240801190425848](./assets/image-20240801190425848-1722510267269-1.png)

æ‰€æœ‰çš„åŸå­æŒ‡ä»¤ï¼ŒåŒ…æ‹¬lock å£°æ˜ï¼Œå¯¹äºå•å¤„ç†å™¨å’Œå¤šå¤„ç†å™¨æ¨¡å‹éƒ½æ»¡è¶³ä¸¤æ¡å®šå¾‹ï¼š

* **lockæ»¡è¶³åŸå­æ€§ï¼š**å³åŒä¸€ç§ç±»å‹çš„lockå¿…å®šä¸²è¡Œå¤„ç†

* **lockä¿è¯ç›¸å¯¹å†…å­˜åºï¼š**å¯¹äºä¸€ä¸ªçº¿ç¨‹ä¸Šä¸åŒçš„lockï¼ˆä¾‹å¦‚å…ˆæ‰§è¡Œlock1ï¼Œåæ‰§è¡Œlock2ï¼‰ï¼Œåæ‰§è¡Œçš„lock2å¿…å®šèƒ½ä¿è¯å…ˆæ‰§è¡Œçš„lock1ä¹‹å‰çš„æ‰€æœ‰æŒ‡ä»¤å·²æ‰§è¡Œ

  è¿™é‡Œç›¸å¯¹å†…å­˜åºè¡¨ç¤ºçš„æ˜¯

  * lock1ä¹‹å‰çš„å·²å®Œæˆ
  * lock2åˆ°lock1ä¹‹é—´çš„å†…å­˜åºæ— æ³•ä¿è¯







#### x86çš„åŸå­æŒ‡ä»¤å®ç°

åŸå­æŒ‡ä»¤é€šå¸¸æ˜¯é€šè¿‡Bus Lockå®ç°çš„ã€‚

<img src="./assets/image-20240801192033793.png" alt="image-20240801192033793" style="zoom:50%;" />

ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªå¤šå¤„ç†å™¨å•memoryçš„æ¨¡å‹ï¼Œæ¯ä¸ªå¤„ç†å™¨é€šè¿‡æ€»çº¿å‘memoryå‘å‡ºæŒ‡ä»¤è¯·æ±‚ã€‚

ä»¥addä¸ºä¾‹ï¼Œé€šå¸¸æ˜¯`load->calculate->store`

ä¸ºäº†åº”å¯¹å¤šå¤„ç†å™¨æ¨¡å‹ä¸­å¯¹åŒä¸€ä¸ªå˜é‡çš„å¤šä¸ªaddè¯·æ±‚ï¼Œx86åœ¨ç¡¬ä»¶ä¸Šå®ç°äº†é”ï¼Œå…·ä½“æ¥è¯´ï¼Œæ˜¯ä¸ºmemoryæ·»åŠ äº†é”ï¼ˆ1bitçš„æŒ‡ç¤ºä½ï¼‰ï¼Œå½“æ€»çº¿ä¸­æœ‰å¤šä¸ªè¯·æ±‚æ—¶ï¼Œæ€»çº¿å†³å®šè®©ä¸€ä¸ªå¤„ç†å™¨çš„è¯·æ±‚é€šè¿‡ã€‚

å¯¹äºä¸€ä¸ª`lock [instruction]`è¯­å¥ï¼Œå®ƒé€šå¸¸é¦–å…ˆè¯»å–lockï¼Œåœ¨è·å–åˆ°memory lockæƒé™ä¹‹åæ‰ä¼šæ‰§è¡Œåé¢çš„instructionã€‚è¿™ç§å®ç°æ—©æœŸåœ¨8086å’Œä¸€äº›æœåŠ¡å™¨ä¸Šå‡ºç°ã€‚



ç°ä»£Intel CPUå…·æœ‰æé‡çš„å†å²åŒ…è¢±ï¼Œè¿™æ˜¯å› ä¸ºæ¯ä¸ªå¤„ç†å™¨éƒ½æœ‰ä¸€ä¸ªcacheã€‚å½“æ¯ä¸ªå¤„ç†å™¨çš„cacheéƒ½hitäº†å…±äº«å˜é‡æ—¶ï¼Œbusä¼šé¦–å…ˆé€‰æ‹©ä¸€ä¸ªå¤„ç†å™¨ï¼ˆä¸€ä¸ªçº¿ç¨‹ï¼‰å…è®¸å…¶è®¿é—®memoryï¼Œå¹¶ä¸ºmemoryä¸Šé”ï¼ŒåŒæ—¶ï¼Œåˆ é™¤å…¶ä»–cacheä¸­çš„å¯¹åº”cache lineï¼Œå¼ºè¿«ä»–ä»¬åœ¨é”ç»“æŸåè§¦å‘cache missï¼Œä»memoryé‡æ–°è¯»å–æœ€æ–°çš„å€¼ã€‚

* L1 cacheå±‚ä¿æŒä¸€è‡´æ€§

  * æ¯ä¸ªcache lineæœ‰åˆ†åˆ«çš„é”
  * store(x)è¿›å…¥L1ç¼“å­˜å³ä¿è¯å¯¹å…¶ä»–å¤„ç†å™¨å¯è§ï¼Œéœ€è¦å°å¿ƒstore bufferå’Œä¹±åºæ‰§è¡Œ

* L1 cache lineæ ¹æ®çŠ¶æ€è¿›è¡Œåè°ƒ

  çŠ¶æ€åŒ…æ‹¬

  * **M**odifiesï¼Œ dirty bitï¼Œè¡¨ç¤ºæ˜¯å¦ä¿®æ”¹
  * **E**xclusive, ç‹¬å è®¿é—®
  * **S**hared, åªè¯»å…±äº«
  * **I**nvalid, cache lineæ— æ•ˆ

<img src="./assets/image-20240801192025151.png" alt="image-20240801192025151" style="zoom:50%;" />







#### RISCVçš„åŸå­æŒ‡ä»¤è®¾è®¡

ä¸åŒäºx86çš„æ€»çº¿é”ï¼ŒRSIC-Vä½¿ç”¨äº†å¦ä¸€ç§æ–¹å¼æ›´ç»†ç²’åŒ–çš„å®Œæˆäº†ä¸€ä¸ªé”ã€‚

è§‚å¯Ÿä¹‹å‰æåˆ°çš„å‡ ä¸ªåŸå­æ“ä½œ

* atomic test-and-set: `reg = load(x); if(reg == xx){store(x,YY);}`
* lock xchg: `reg = load(x); store(x,XX);`
* lock add:`t = load(x); t++; store(x,t);`

å¯ä»¥å‘ç°ï¼Œæ‰€æœ‰çš„race conditionå½’æ ¹åˆ°åº•æ˜¯â€æ¥è‡ªloadåˆ°å¯„å­˜å™¨â€œ åï¼Œå…±äº«å˜é‡å¯èƒ½è¢«å…¶ä»–äººä¿®æ”¹ï¼Œå¯¼è‡´â€storeå›å»â€œçš„æ—¶å€™æœ¬åœ°å˜é‡å’Œå…±äº«å˜é‡å¯¹åº”çš„åˆå§‹çŠ¶æ€ä¸ä¸€è‡´ã€‚

x86åšçš„æ˜¯åªå…è®¸ä¸€ä¸ªçº¿ç¨‹`è¯»å–ï¼Œå¤„ç†ï¼Œå†™å›`å…±äº«å˜é‡

è€ŒRISC-Våšçš„äº‹å…è®¸æ‰€æœ‰çº¿ç¨‹`è¯»å–`å…±äº«å˜é‡å¹¶åœ¨æœ¬åœ°`å¤„ç†`ï¼Œä½†æ˜¯å†™å›æ—¶ï¼Œè‹¥æ˜¯å…±äº«å˜é‡å·²ç»è¢«å¤„ç†è¿‡ï¼Œé‚£ä¹ˆå°±é‡æ–°`è¯»å–`å¹¶`å¤„ç†`ï¼Œå¦åˆ™ç›´æ¥å†™å›ã€‚

å®¹æ˜“å‘ç°ï¼Œæ ‡è®°ä¸èƒ½æ˜¯1bitæ ‡å¿—ä½ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªçº¿ç¨‹æ•°ä½æ•°çš„æ ‡å¿—ç»„ã€‚å¦åˆ™ä¼šå­˜åœ¨çº¿ç¨‹Aæ‰“ä¸Šreservedæ ‡è®°ï¼Œçº¿ç¨‹Bå†™å›æ¶ˆé™¤reservedæ ‡è®°ï¼Œçº¿ç¨‹C loadåˆæ‰“ä¸Šreservedæ ‡è®°ï¼Œè¿™ä¼šå¯¼è‡´çº¿ç¨‹Aè®¤ä¸ºå…±äº«å˜é‡æœªè¢«ä¿®æ”¹ã€‚



RISC-Væœ‰**Load-Reserved(LR)**å’Œ**Store-Conditional**ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹è¯»å–å…±äº«å˜é‡æ—¶ï¼Œå®ƒä¼šåœ¨å†…å­˜ä¸Šæ‰“ä¸Šæ ‡è®°ï¼ˆreservedï¼‰ï¼Œå…¶ä»–çº¿ç¨‹çš„å†™å…¥éƒ½ä¼šå¯¼è‡´æ ‡è®°æ¶ˆé™¤ã€‚

```
lr.w rd, (rs1)
rd = M[rs1]
reserve M[rs1]
```

å½“è¯¥çº¿ç¨‹å¤„ç†å®Œå…±äº«å˜é‡åï¼Œè‹¥æ˜¯reservedæ ‡è®°å­˜åœ¨åˆ™ç›´æ¥å†™å›ï¼Œå¦åˆ™é‡æ–°æ‰§è¡Œè¯»å–å¤„ç†ã€‚

```
sc.w rd, rs2, (rs1)
if still reserved:
	M[rs1] = rs2
	rd = 0
elseï¼›
	rd = nonzero
```



ä¸€ä¸ªç®€å•çš„å®ç°å¦‚ä¸‹

```c
int cas(int *addr, int cmp_val, int new_val){
    int old_val = *addr;
    if(old_val == cmp_val){
        *addr = new_val; return 0;
    }else{
        return 1;
    }
}
```





### è‡ªæ—‹é”çš„åŠ£åŠ¿

**ä½æ€§èƒ½**ï¼šè‡ªæ—‹é”å› ä¸ºåœ¨ä¸åœçš„ä¿®æ”¹å…±äº«å˜é‡ï¼ˆæ ‡å¿—ä½ï¼‰ï¼Œåœ¨ç°ä»£å¤šå¤„ç†å™¨ï¼ˆå¸¦cacheï¼‰ä¸­ä¼šå› ä¸ºç¼“å­˜åŒæ­¥å¯¼è‡´å»¶è¿Ÿå¢åŠ ï¼Œæ€§èƒ½ä¸‹é™ã€‚

**æ— æ•ˆè´Ÿè½½**ï¼šåœ¨è‡ªæ—‹é”ä¸­ï¼Œåªæœ‰è·å–é”çš„çº¿ç¨‹æ‰æ˜¯æœ‰æ•ˆè´Ÿè½½ï¼Œå…¶ä»–çº¿ç¨‹åªæ˜¯åœ¨ç©ºè½¬ï¼Œå ç”¨CPUèµ„æºã€‚è¿™æ„å‘³ç€äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½ã€‚

**å ç€èŒ…å‘ä¸æ‹‰å±**ï¼šåœ¨è‡ªæ—‹é”ä¸­ï¼Œè·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹$\color{red}{å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»}$ã€‚å› ä¸ºè½®è½¬æ—¶é—´ç‰‡æœºåˆ¶ï¼Œåœ¨æ“ä½œç³»ç»Ÿçœ¼é‡Œï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è¦å¿™çš„äº‹ï¼Œæœ‰äº›å¿™ç©ºè½¬ï¼Œæœ‰äº›å¿™æ­£äº‹ï¼Œä½†æ˜¯æ“ä½œç³»ç»Ÿä¸çŸ¥é“ï¼Œå¦‚æœæŠŠè‡ªæ—‹é”åˆ‡å‡ºå»äº†ï¼Œè¿™ä¸‹å°±æ˜¯100%çš„èµ„æºæµªè´¹äº†ã€‚





å› æ­¤ï¼Œè‡ªæ—‹é”çš„åº”ç”¨åœºæ™¯æ˜¯ä½œä¸ºâ€å¾ˆå°‘å‘ç”Ÿå†²çªçš„åœºæ™¯â€œä¸­ä½¿ç”¨ã€‚

* ä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µ
* æŒæœ‰è‡ªæ—‹é”æ—¶è¯¥çº¿ç¨‹ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢ï¼ˆå› æ­¤æ™®é€šè¿›ç¨‹æ˜¯ä¸å¯èƒ½çš„ï¼‰

è‡ªæ—‹é”é€šå¸¸ç”¨äº**æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„**ï¼Œè¿™äº›æ•°æ®ç»“æ„å…·æœ‰çŸ­ä¸´ç•ŒåŒºï¼Œä¹Ÿå°±æ˜¯ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å¯èƒ½éœ€è¦100nsï¼Œè®¡ç®—å¯èƒ½éœ€è¦100msï¼Œå¾ˆä¸é¢‘ç¹çš„å–ä»»åŠ¡æ—¶ï¼Œä»»åŠ¡å†²çªå°±å¾ˆå°‘æ­¤æ—¶å°±æ˜¯ä¸€ä¸ªçŸ­ä¸´ç•ŒåŒºã€‚

* æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å ï¼Œä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”









### æ€§èƒ½ç»´åº¦ï¼šScalability

å¯¹äºåŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ï¼ˆCPU cyclesï¼‰å’Œç©ºé—´ï¼ˆmapped memoryï¼‰ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚

æ ¹æ®2.2ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—ä¸€ä»½è‡ªæ—‹é”çš„å®ç°

```c
#include <semaphore.h>

// Spinlock
typedef int spinlock_t;
#define SPIN_INIT() 0

static inline int atomic_xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1":
    "+m"(*addr), "=a"(result) : "1"(newval) : "memory");
  return result;
}

void spin_lock(spinlock_t *lk) {
  while (1) {
    intptr_t value = atomic_xchg(lk, 1);
    if (value == 0) {
      break;
    }
  }
}
void spin_unlock(spinlock_t *lk) {
  atomic_xchg(lk, 0);
}

// Mutex
typedef pthread_mutex_t mutex_t;
#define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER
void mutex_lock(mutex_t *lk)   { pthread_mutex_lock(lk); }
void mutex_unlock(mutex_t *lk) { pthread_mutex_unlock(lk); }

// Conditional Variable
typedef pthread_cond_t cond_t;
#define COND_INIT() PTHREAD_COND_INITIALIZER
#define cond_wait pthread_cond_wait
#define cond_broadcast pthread_cond_broadcast
#define cond_signal pthread_cond_signal

// Semaphore
#define P sem_wait
#define V sem_post
#define SEM_INIT(sem, val) sem_init(sem, 0, val)
~                                                     
```

ä½¿ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥æµ‹è¯•æ€§èƒ½

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
spinlock_t lock = SPIN_INIT();
long n, sum = 0;

void Tsum(){
    // è‡ªæ—‹é”ä¿æŠ¤ä¸‹çš„sum++
    for(int i = 0; i < n; i++){
        spin_lock(&lock);
        sum++;
        spin_unlock(&lock);
    }
}

int main(int argc, char*argv[]){
    assert(argc==2);
    // åˆ†é…nthreadä¸ªçº¿ç¨‹åˆ†åˆ«å®Œæˆnæ¬¡sum++
    int nthread = atoi(argv[1]);
    n = N/nthread;
    for(int i = 0; i < nthread; i++){
        create(Tsum);
    }
    join();
    assert(sum == n * nthread);
}
```

![image-20240801205633178](./assets/image-20240801205633178.png)

å¯ä»¥å‘ç°ï¼Œçº¿ç¨‹è¶Šå¤šï¼Œè€—æ—¶è¶Šé•¿

![image-20240801210422158](./assets/image-20240801210422158.png)





### ç¡çœ é”/äº’æ–¥é”ï¼šå®ç°è‡ªæ—‹é”é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥

è¿™é‡Œçš„æƒ³æ³•æ˜¯ï¼Œè®©ç©ºè½¬çš„çº¿ç¨‹æ”¾æƒï¼Œå°†èµ„æº(CPU)è®©ç»™å…¶ä»–ä½œä¸šï¼ˆçº¿ç¨‹ï¼‰æ‰§è¡Œã€‚

å¯ä»¥å‘ç°ï¼Œè¿™é‡Œå­˜åœ¨â€å‡ºè®©èµ„æºâ€œçš„è¡Œä¸ºï¼Œè¿™ä¸ªè¡Œä¸ºä¸€å®šä¸æ˜¯è¿›ç¨‹æœ¬èº«ï¼ˆå‡ºè®©CPUèµ„æºæ§åˆ¶æƒï¼‰å¯ä»¥åšçš„ï¼Œè¿™ä¸ªè¡Œä¸ºæ˜¯æ“ä½œç³»ç»Ÿè¿›ç¨‹æ‰èƒ½åšçš„ï¼ˆCè¯­è¨€ä»£ç åªèƒ½è®¡ç®—ï¼‰

å› æ­¤ï¼Œé€šå¸¸è¿™äº›è¿›ç¨‹ä¼šä½¿ç”¨system call

* `syscall(SYSCALL_lock, &lk);`

  è¯•å›¾è·å¾—lkï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹

* `syscall(SYSCALL_unlock,&lk);`

  é‡Šæ”¾lkï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

> * å…ˆåˆ°çš„çº¿ç¨‹è¿›å…¥é”ï¼Œ`lk=ğŸ”’`ï¼Œç³»ç»Ÿè°ƒç”¨ç›´æ¥è¿”å›
> * å…¶ä»–çš„çº¿ç¨‹å‘ç°`lk=ğŸ”’`ï¼Œçº¿ç¨‹è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ‰§è¡Œçº¿ç¨‹åˆ‡æ¢(yield)
> * å½“ç¬¬ä¸€ä¸ªçº¿ç¨‹å®Œæˆ
>   * è‹¥ç­‰å¾…é˜Ÿåˆ—ä¸ç©ºï¼Œä»ç­‰å¾…é˜Ÿåˆ—å–å‡ºä¸€ä¸ªçº¿ç¨‹å…è®¸æ‰§è¡Œ
>   * è‹¥ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œè®¾ç½®`lk=ç©º`
> * OSä½¿ç”¨è‡ªæ—‹é”ä¿è¯è‡ªå·±å¤„ç†lkçš„è¿‡ç¨‹æ˜¯åŸå­çš„





### è‡ªæ—‹é”ä¸ç¡çœ é”

**è‡ªæ—‹é”**ï¼ˆçº¿ç¨‹ç›´æ¥å…±äº«lockedï¼‰

* æ›´å¿«çš„fast path
  * xchgæˆåŠŸï¼ˆä»…ä¸€æ¡åŸå­æŒ‡ä»¤åï¼‰$\rightarrow$ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
* æ›´æ…¢çš„slow path
  * xchgå¤±è´¥$\rightarrow$ æµªè´¹CPUè‡ªæ—‹





**ç¡çœ é”**ï¼ˆé€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—®locked)

* æ›´å¿«çš„slow path
  * ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨CPU
* æ›´æ…¢çš„fast path
  * å³ä½¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸(syscall)





### æŠ˜ä¸­çš„æ–¹æ¡ˆï¼šFutex(Fast Userspace muTexes)

Fast Pathï¼šä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›

Slow Pathï¼šä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 

è¿™ä¸ªæ–¹æ³•åˆ†ç¦»äº†ä¸Šé”å’Œsyscallï¼Œé¿å…äº†ç¡çœ é”ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦syscallï¼Œä¹Ÿé¿å…äº†è‡ªæ—‹é”ä¸Šé”å¤±è´¥æŒç»­å ç”¨CPU

> ### å·¥ä½œæœºåˆ¶
>
> 1. **ç”¨æˆ·ç©ºé—´çš„è‡ªæ—‹é”**ï¼š åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œçº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´ä½¿ç”¨è‡ªæ—‹é”è¿›è¡ŒåŒæ­¥ã€‚å¦‚æœé”å¾ˆå¿«å¯ç”¨ï¼Œçº¿ç¨‹åªåœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹å‡ æ¬¡ï¼Œä¸ä¼šè¿›å…¥å†…æ ¸ï¼Œä»è€Œå‡å°‘äº†ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚
> 2. **å†…æ ¸ç©ºé—´çš„ç¡çœ é”**ï¼š å½“çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹ä¸€æ®µæ—¶é—´åä»æœªè·å–åˆ°é”ï¼Œå°±ä¼šé€šè¿‡`futex`ç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸ã€‚å†…æ ¸ä¸­çš„`futex`æœºåˆ¶ä¼šå°†çº¿ç¨‹ç½®äºç¡çœ çŠ¶æ€ï¼Œç­‰å¾…é”å˜å¾—å¯ç”¨ã€‚å½“é”å¯ç”¨æ—¶ï¼Œå†…æ ¸ä¼šå”¤é†’ç­‰å¾…çš„çº¿ç¨‹ã€‚
>
> ### è¯¦ç»†æ­¥éª¤
>
> 1. **å°è¯•è·å–é”**ï¼š
>    - çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´å°è¯•è·å–é”ã€‚å¦‚æœæˆåŠŸï¼Œåˆ™è¿›å…¥ä¸´ç•ŒåŒºã€‚
>    - å¦‚æœé”è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼Œåˆ™è¿›è¡Œè‡ªæ—‹ç­‰å¾…ã€‚
> 2. **ç”¨æˆ·ç©ºé—´è‡ªæ—‹**ï¼š
>    - çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹ä¸€æ®µæ—¶é—´ï¼Œå°è¯•å¤šæ¬¡è·å–é”ã€‚å¦‚æœåœ¨æŒ‡å®šçš„è‡ªæ—‹æ¬¡æ•°å†…è·å–åˆ°é”ï¼Œåˆ™è¿›å…¥ä¸´ç•ŒåŒºã€‚
>    - å¦‚æœè‡ªæ—‹ç­‰å¾…è¶…è¿‡æŒ‡å®šæ¬¡æ•°ä»æœªè·å–åˆ°é”ï¼Œåˆ™è¿›å…¥å†…æ ¸æ€ã€‚
> 3. **è¿›å…¥å†…æ ¸æ€**ï¼š
>    - çº¿ç¨‹è°ƒç”¨`futex`ç³»ç»Ÿè°ƒç”¨ï¼Œå°†è‡ªèº«é˜»å¡åœ¨é”ä¸Šï¼Œè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç­‰å¾…é”å˜å¾—å¯ç”¨ã€‚
> 4. **é”é‡Šæ”¾å’Œå”¤é†’**ï¼š
>    - å½“æŒæœ‰é”çš„çº¿ç¨‹é‡Šæ”¾é”æ—¶ï¼Œä¼šé€šè¿‡`futex`ç³»ç»Ÿè°ƒç”¨é€šçŸ¥å†…æ ¸ï¼Œå†…æ ¸ä¼šå”¤é†’ç­‰å¾…é”çš„çº¿ç¨‹ã€‚
>    - è¢«å”¤é†’çš„çº¿ç¨‹ä»å†…æ ¸æ€è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œé‡æ–°å°è¯•è·å–é”ã€‚

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
mutex_t lock = MUTEX_INIT();
long n, sum = 0;

void Tsum(){
    // è‡ªæ—‹é”ä¿æŠ¤ä¸‹çš„sum++
    for(int i = 0; i < n; i++){
        mutex_lock(&lock);
        sum++;
        mutex_unlock(&lock);
    }
}

int main(int argc, char*argv[]){
    assert(argc==2);
    // åˆ†é…nthreadä¸ªçº¿ç¨‹åˆ†åˆ«å®Œæˆnæ¬¡sum++
    int nthread = atoi(argv[1]);
    n = N/nthread;
    for(int i = 0; i < nthread; i++){
        create(Tsum);
    }
    join();
    assert(sum == n * nthread);
}
```

æ€§èƒ½æå‡æ˜¯éå¸¸æ˜æ˜¾çš„

![image-20240802143941797](./assets/image-20240802143941797.png)

è¿™é‡Œå°±æ˜¯è°ƒç”¨çš„çº¿ç¨‹åº“ä¸­çš„é”

å¦‚æœä½¿ç”¨straceçœ‹è¿™ä¸ªç¨‹åºæ‰€æœ‰å­è¿›ç¨‹çš„è¯

```bash
strace -f ./a.out 64
```

![image-20240802145044509](./assets/image-20240802145044509.png)

å¯ä»¥å‘ç°è°ƒç”¨çš„æ˜¯futex







## 3. åŒæ­¥æ§åˆ¶

åŒ…æ‹¬å…¸å‹çš„åŒæ­¥é—®é¢˜ï¼šç”Ÿäº§è€…æ¶ˆè´¹è€…ï¼›å“²å­¦å®¶åƒé¥­

åŒæ­¥çš„å®ç°æ–¹æ³•ï¼šä¿¡å·é‡ï¼Œæ¡ä»¶å˜é‡



### 3.1 åŒæ­¥

ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šéšæ—¶é—´å˜åŒ–çš„é‡åœ¨å˜åŒ–çš„è¿‡ç¨‹ä¸­ä¿æŒä¸€å®šçš„ç›¸å¯¹å…³ç³»

>  å¼‚æ­¥(Asynchronous) = ä¸åŒæ­¥

çº¿ç¨‹åŒæ­¥æ„å‘³ç€$\color{red}{åœ¨æŸä¸ªæ—¶é—´ç‚¹åŒæ—¶è¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€}$



### 3.2 Naive Producer-Consumer Model

```c
void Tproduce(){while(1) printf("(");}
void Tconsume(){while(1) printf(")");}
```

è¿™é‡Œçš„æ‹¬å·åŒ¹é…è¦æ±‚

* å³æ‹¬å·ä¸€å®šèƒ½æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å·
* æ€»çš„æœªåŒ¹é…å·¦æ‹¬å·æ•°ä¸è¶…è¿‡n

æ‰€ä»¥å·¦æ‹¬å·å¯ä»¥çœ‹ä½œä¸€ä¸ªproducerï¼Œè€Œå³æ‹¬å·å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªconsumer



è¿™ä¸ªé—®é¢˜æ¨¡æ‹Ÿäº†ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ï¼Œå…¶ä¸­ä½ éœ€è¦æœ‰å·¦æ‹¬å·çš„ç”Ÿäº§æ‰èƒ½æœ‰å³æ‹¬å·çš„æ¶ˆè´¹

è€ƒè™‘è¿™ä¹ˆä¸€ä¸ªæ¨¡å‹å¦‚ä½•åº”å¯¹å¹¶å‘çŠ¶å†µ

ä¸€ä¸ªæƒ³æ³•æ˜¯ä½¿ç”¨äº’æ–¥é”

* æ¯å½“Produceræ·»åŠ ä»»åŠ¡æ—¶
  * ä»»åŠ¡æ± ä¸Šé”
  * åˆ¤æ–­é˜Ÿåˆ—æ·±åº¦æ˜¯å¦å¤§äºnï¼Œè‹¥å°äºnåˆ™ç»™ä¸€ä¸ªåˆ°è¾¾Producerçº¿ç¨‹è§£é”ï¼Œç»™è¯¥çº¿ç¨‹å†™å…¥æƒé™
* å½“Consumerè·å–ä»»åŠ¡æ—¶
  * ä»»åŠ¡æ± ä¸Šé”
  * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºåˆ™ç»™ä¸€ä¸ªåˆ°è¾¾çš„consumerçº¿ç¨‹è§£é”ï¼Œç»™è¯¥çº¿ç¨‹è¯»å–æƒé™

ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŒæ¡ä»¶æˆç«‹

```c++
#include "thread.h"
#include "thread-sync.h"

int n, count = 0;
mutex_t lk = MUTEX_INIT();

void Tproduce(){
    while(1){
    retry:
        mutex_lock(&lk);
        
        if(count == n){
            mutex_unlock(&lk);
            goto retry;
        }
        count++;
        printf("(");
        mutex_unlock(&lk);
    }
}



void Tconsume(){
    while(1){
    retry:
        mutex_lock(&lk);
        if(count == 0){
            mutex_unlock(&lk);
            goto retry;
        }
        
        count--;
        printf(")");
        mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc == 2);
    n = atoi(argv[1]);
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tproduce);
    }
}
```

```bash
gcc -pc.c -lpthread && ./a.out 1
```

è¿™é‡Œä¼ å…¥å‚æ•°1è¡¨ç¤ºä»»åŠ¡æ± æœ€å¤šåªèƒ½æ¥å—ä¸€ä¸ªä»»åŠ¡ï¼Œè‡³å°‘ä»è¿™é‡Œçœ‹èµ·æ¥è¿˜æ˜¯æ²¡é—®é¢˜çš„ï¼Œæ²¡æœ‰ç±»ä¼¼`(())`æˆ–è€…æ›´å¤šçš„æƒ…å†µ

![image-20240805145236531](./assets/image-20240805145236531.png)

å½“ç„¶ï¼Œæ›´é«˜çš„å‚æ•°äººçœ¼å°±è¯†åˆ«ä¸å‡ºæ¥äº†ï¼Œæ‰€ä»¥å¯ä»¥ç”¨è„šæœ¬è¯­è¨€å†™ä¸€ä¸ªç®€å•çš„checker

```py
import sys
# limit read from input, represents the max job num in poll
limit = int(sys.argv[1])
# n è®¾ç½®ä¸º 100000ï¼Œè¿™æ˜¯æ¯æ¬¡ä»æ ‡å‡†è¾“å…¥è¯»å–çš„å­—ç¬¦æ•°é‡ã€‚
count, n = 0, 100000

while True:
    # ä»æ ‡å‡†è¾“å…¥è¯»å– n ä¸ªå­—ç¬¦ï¼Œå¹¶é€ä¸ªå¤„ç†
    for ch in sys.stdin.read(n):
        if ch == '(': count += 1
        if ch == ')': count -= 1
        # æ–­è¨€ count çš„å€¼åœ¨ 0 å’Œ limit ä¹‹é—´ã€‚å¦‚æœ count è¶…å‡ºæ­¤èŒƒå›´ï¼Œç¨‹åºä¼šæŠ›å‡º AssertionError å¹¶ç»ˆæ­¢ã€‚
        assert 0 <= count <= limit
    print(f'{n} Ok.')

```

```bash
./a.out 1 | python3 pc-check.py 1
```

é¦–å…ˆå¯ä»¥å‘ç°ï¼Œè¿™ä¸ªç¨‹åºæ˜¯å½“a.outè¾“å…¥ä¸º2ï¼Œpyè®¾å®šä¸º1æ—¶æ˜¯ä¼šæŠ¥é”™çš„ï¼Œè¿™è¯´æ˜å¤§æ¦‚ç‡ç¨‹åºæ˜¯æ²¡bugçš„

![image-20240805151350844](./assets/image-20240805151350844.png)

![image-20240805151305319](./assets/image-20240805151305319.png)















### 3.3 æ”¹è¿›1ï¼šConditional valuable(æ¡ä»¶å˜é‡cv)

#### 3.3.1 futex/mutexå®ç°çš„åŠ£åŠ¿

åœ¨ä¸Šé¢çš„å®ç°ä¸­ï¼Œå¯ä»¥å‘ç°

* å°±ç®—ä»»åŠ¡é˜Ÿåˆ—æ»¡äº†ï¼Œå‡å¦‚æ²¡æœ‰ç©ºé—²çš„consumerï¼Œæ­¤æ—¶producerä»ç„¶ä¼šä¸åœçš„å»è·å–é”è¯•å›¾å¾€é‡Œé¢åŠ ä»»åŠ¡

  å…·ä½“æ¥è¯´ï¼Œ

  producer thread 1è·å–é”ï¼Œå…¶ä½™producer threadè¯•å›¾è·å–é”è¢«æ²‰ç¡**ï¼ˆfutex)**

  producer thread 1 é‡Šæ”¾é”ï¼Œå”¤é†’å…¶ä½™producer thread**(futex)**

  è¿™æ˜¯å¾ˆæ— æ„ä¹‰å¾ˆè€—æ—¶é—´çš„ï¼ŒåŒæ—¶å¯èƒ½è¯´100ä¸ªproducerè¯•å›¾å¾€æ»¡çš„poolé‡Œæ¨å…¥ä»»åŠ¡ï¼Œä½¿å¾—åˆšé†’æ¥çš„consumer threadè¢«å¡å¾ˆä¹…ï¼Œå› ä¸ºä»–ä»¬ä½¿ç”¨çš„åŒä¸€ä¸ªé”

* åŒç†ï¼Œå°±ç®—ä»»åŠ¡é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œconsumerä¹Ÿä¼šä¸åœçš„å»ç”³è¯·ï¼Œproducerå¯èƒ½è¢«ä¸¥é‡é˜»å¡



é‡æ–°åˆ†æä¸€ä¸‹ä¹‹å‰é—®é¢˜çš„å†™æ³•(futex)

* çº¿ç¨‹è·å–é”ï¼Œä»…æœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè·å–åˆ°é”ï¼Œå…¶ä½™è¢«futexæ²‰ç¡
* è·å–åˆ°é”çš„çº¿ç¨‹åˆ¤æ–­æŸä¸€ä¸ªæ¡ä»¶æ˜¯å¦æˆç«‹
  * ä¸æˆç«‹çš„è¯é‡Šæ”¾é”ï¼Œè¯¥çº¿ç¨‹retryï¼Œfutexå”¤é†’å…¶ä»–çº¿ç¨‹
  * æˆç«‹çš„è¯ç›´æ¥è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œ
* æ¯æ¬¡é”å› ä¸ºå„ç§åŸå› è¢«é‡Šæ”¾åï¼Œ**æ‰€æœ‰çº¿ç¨‹éƒ½ä¼šå†è¯•å›¾å»è·å–é”**



æˆ‘ä»¬æœŸå¾…çš„æ˜¯ä¼˜åŒ–å»è¿™ä¸ª**è®¸å¤šçº¿ç¨‹åŒæ—¶è·å–é”çš„è¿‡ç¨‹**ï¼Œæ›´å‡†ç¡®çš„è¯´ï¼Œæ˜¯ä¸å¿…è¦çš„é”çš„è·å–è¿‡ç¨‹

ä¾‹å¦‚ï¼Œæˆ‘ç°åœ¨ä»»åŠ¡æ± å·²ç»æ»¡äº†ï¼Œè¿˜æ˜¯æœ‰é“ºå¤©ç›–åœ°çš„producer threadè¯•å›¾æ·»åŠ ä»»åŠ¡ï¼Œè¿™å°±æ˜¯æµªè´¹CPUèµ„æºçš„è¡Œä¸ºï¼Œå› ä¸ºæ³¨å®šæ˜¯å¤±è´¥çš„

ä¼˜åŒ–çš„æ€è·¯å°±æ˜¯ï¼Œæ—¢ç„¶ä½ æˆä¸ºäº†å¹¸è¿å„¿ï¼Œä½ è·å–åˆ°é”äº†ï¼Œé‚£ä¹ˆå¦‚æœä½ æ²¡æœ‰èƒ½å¤Ÿæ»¡è¶³æ¡ä»¶ï¼ˆä¾‹å¦‚ä»»åŠ¡æ± æ»¡äº†ï¼‰ï¼Œé‚£ä¹ˆä½ å°±åº”è¯¥æ²‰ç¡ï¼Œç›´åˆ°ä»»åŠ¡æ± æœ‰ç©ºä½ä½ æ‰èƒ½å¤Ÿå‚ä¸é”çš„ç«äº‰



#### 3.3.2 æ¡ä»¶å˜é‡

æ¡ä»¶å˜é‡APIåŒ…æ‹¬

* `wait(cv,mutex)`
  * wait until wake
  * è°ƒç”¨æ—¶å¿…é¡»ä¿è¯å·²ç»è·å¾—mutex
  * é‡Šæ”¾mutexï¼Œè¿›å…¥ç¡çœ çŠ¶æ€
  * ç›¸å½“äº`mutex_unlock_and_sleep`
* `signal(cv)`
  * Notification
  * å¦‚æœæœ‰ä¸€ä¸ªçº¿ç¨‹æ­£åœ¨ç­‰å¾…cvï¼Œå”¤é†’å…¶ä¸­ä¸€ä¸ª
  * ç›¸å½“äºwake_up()
* `broadcast(cv)`
  * å”¤é†’å…¨éƒ¨æ­£åœ¨ç­‰å¾…cvçš„çº¿ç¨‹







#### 3.3.3 ä¸€ä¸ªé”™è¯¯çš„ä¾‹å­

åœ¨[6. å¹¶å‘æ§åˆ¶](https://www.bilibili.com/video/BV17T4y1S7RS/?p=6&spm_id_from=pageDriver&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9)ä¸­æå‡ºäº†ä¸€ä¸ªé”™è¯¯çš„ç­–ç•¥ï¼Œå®ƒæœŸå¾…è®©æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„çº¿ç¨‹æ²‰ç¡ï¼Œä¸€æ¬¡å”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œä»¥å‡å°‘çº¿ç¨‹é—´çš„mutexç«äº‰ï¼Œå› æ­¤è·å¾—äº†é”™è¯¯çš„ç»“æœï¼Œå¯ä»¥çœ‹ä¸€ä¸‹



```c++
#include "thread.h"
#include <semaphore.h>

int n, count = 0;

mutex_t lk = PTHREAD_MUTEX_INITIALIZER;
cond_T cv = PTHREAD_COND_INITIALIZER;

void Tproduce(){
    while(1){
        pthread_mutex_lock(&lk);
        if(count == n){
            pthread_cond_wait(&cv, &lk);
        }
        printf("(");count++;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }

}


void Tconsume(){
    while(1){
        pthread_mutex_lock(&lk);
        if(count == 0){
            pthread_cond_wait(&cv, &lk);
        }
        printf(")");count--;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc==2);
    
    n = atoi(argv[1]);
    // è®¾ç½®æ ‡å‡†è¾“å‡ºä¸ºæ— ç¼“å†²
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tconsume);
    }
}
```

> åœ¨ä»£ç ä¸­ä½¿ç”¨ `setbuf(stdout, NULL);` å°†æ ‡å‡†è¾“å‡ºè®¾ç½®ä¸ºæ— ç¼“å†²æ¨¡å¼ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ç¡®ä¿æ¯æ¬¡è°ƒç”¨ `printf` æ—¶ï¼Œè¾“å‡ºç«‹å³è¢«å†™å…¥åˆ°ç›®æ ‡ï¼ˆå¦‚ç»ˆç«¯ï¼‰ï¼Œè€Œä¸æ˜¯å…ˆå­˜å‚¨åœ¨ç¼“å†²åŒºä¸­ã€‚è¿™åœ¨è°ƒè¯•å’Œå®æ—¶è¾“å‡ºæ—¶éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå¯ä»¥ç¡®ä¿æ‰€æœ‰è¾“å‡ºæŒ‰é¡ºåºç«‹å³æ˜¾ç¤ºï¼Œè€Œä¸ä¼šå› ä¸ºç¼“å†²è€Œå»¶è¿Ÿã€‚

è¿™é‡Œçš„`pthread_cond_wait`åšäº†ä¸‰ä¸ªæ“ä½œ

* é‡Šæ”¾é”
* ç¡çœ ç­‰å¾…wake
* wakeåè¯•å›¾è·å–é”
* è·å–é”æˆåŠŸåˆ™ç»§ç»­åé¢çš„ï¼Œå¦åˆ™ä»ç„¶å¤„äºcvçš„ç­‰å¾…é˜Ÿåˆ—



è¿™é‡Œå¯ä»¥å‘ç°ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„é€»è¾‘æ¼æ´äº†ï¼Œ==å®ƒå¹¶æ²¡æœ‰å†æ¬¡åˆ¤æ–­count==

![image-20240805165100566](./assets/image-20240805165100566.png)

æ˜¾ç„¶ï¼Œå®ƒç¬¬ä¸€ä¸ªåä¸‡ç”¨ä¾‹éƒ½æ²¡æ’‘è¿‡å»



##### åˆ†æ1ï¼šé‡å¤åˆ¤æ–­æ¡ä»¶

ä»¥producerä¸ºä¾‹ï¼Œå®ƒåœ¨æ²‰ç¡æ—¶ä»£è¡¨ä»»åŠ¡æ± ä¸ºæ»¡ï¼Œä½†æ˜¯å¯èƒ½é†’æ¥åä»»åŠ¡æ± ä»ç„¶ä¸ºæ»¡ï¼Œä½†æ˜¯æ­¤æ—¶è¿™ä¸ªçº¿ç¨‹æ‰€éœ€è¦åšçš„å°±æ˜¯è·å¾—å”¾æ‰‹å¯å¾—çš„æ§åˆ¶æƒï¼ˆå› ä¸ºåªæœ‰å®ƒä¸€ä¸ªè‹é†’äº†ï¼‰ï¼Œå®ƒå¹¶ä¸ç”¨é‡æ–°åˆ¤æ–­ä»»åŠ¡æ± ï¼Œå› æ­¤å°±ä¼šå‡ºç°é”™è¯¯

åŒç†ï¼Œå¯¹äºconsumerä¹Ÿæ˜¯è¿™æ ·

**å› æ­¤ï¼Œä¸€ä¸ªè¾ƒä¸ºé€šç”¨çš„ä½¿ç”¨condition variableçš„æ–¹å¼å°±å‡ºæ¥äº†ï¼Œå³ä¸ºä½¿ç”¨whileé‡å¤åˆ¤æ–­æ¡ä»¶**

æ­¤æ—¶cvè¿ä½œçš„è¿‡ç¨‹æ˜¯è¿™æ ·çš„

* åˆ¤æ–­æ¡ä»¶ï¼Œè‹¥ç¬¦åˆåˆ™è¿›å…¥

* é‡Šæ”¾é”
* ç¡çœ ç­‰å¾…wake
* wakeåè¯•å›¾è·å–é”
* è·å–é”æˆåŠŸï¼Œé‡æ–°åˆ¤æ–­æ¡ä»¶

```c++
#include "thread.h"
#include <semaphore.h>

int n, count = 0;

mutex_t lk = PTHREAD_MUTEX_INITIALIZER;
cond_T cv = PTHREAD_COND_INITIALIZER;

void Tproduce(){
    while(1){
        pthread_mutex_lock(&lk);
        //æ”¹æˆwhileï¼Œåœ¨è¿™æ ·åœ¨cond waitè·å–é”ä¹‹åä»ç„¶èƒ½å¤Ÿåˆ¤æ–­
        while(count == n){
            pthread_cond_wait(&cv, &lk);
        }
        assert(count != n);//ç”¨äºå‹åŠ›æµ‹è¯•
        printf("(");count++;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }

}


void Tconsume(){
    while(1){
        pthread_mutex_lock(&lk);
        while(count == 0){
            pthread_cond_wait(&cv, &lk);
        }
        printf(")");count--;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc==2);
    
    n = atoi(argv[1]);
    // è®¾ç½®æ ‡å‡†è¾“å‡ºä¸ºæ— ç¼“å†²
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tconsume);
    }
}
```

ç»è¿‡æµ‹è¯•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæ¦‚ç‡å‡ºç°ä¸€ä¸ªbug

![image-20240805201957072](./assets/image-20240805201957072.png)

å®ƒä¼šåœ¨æŸä¸€ä¸ªæ—¶é—´ç‚¹æ­»é”äº†

è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯signalï¼Œè¿™æ„å‘³ç€æ¯æ¬¡ä¸€ä¸ªçº¿ç¨‹å®Œæˆæ“ä½œï¼Œä»…èƒ½å”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œå¾ˆå®¹æ˜“å‡ºç°å¡ä½ï¼Œå‡ºç°æ­»é”

å…·ä½“æ¥è¯´ï¼Œ











è§£å†³æ–¹æ³•å°±æ˜¯æ¯æ¬¡éƒ½æ˜¯å…¨éƒ¨å”¤é†’ï¼Œè€Œéä»…å”¤é†’ä¸€ä¸ª

å³æ›¿æ¢`pthread_cond_signal`ä¸º`pthread_cond_broadcast`

![image-20240806141158397](./assets/image-20240806141158397.png)

==è¿™ä¹Ÿæ˜¯ä¸€ç§å¾ˆå¸¸è§çš„ä½¿ç”¨æ¡ä»¶å˜é‡å®ç°å¹¶è¡Œè®¡ç®—çš„æ–¹å¼ï¼Œå³==

```c++
struct job{
    void (*run)(void *arg);
    void *arg;
}


while(1){
    struct job* job;
    mutex_lock(&mutex);
    while(!(job=get_job())){
        wait(&cv,&mutex);
    }
    
    mutex_unlock(&mutex);
    job0>run(job->arg);
}
```









å¦ä¸€ç§åšæ³•å°±æ˜¯ä¸èƒ½åŒç±»å”¤é†’ï¼Œå³ä¸ºConsumerä¸èƒ½å”¤é†’consumerï¼ŒProducerä¸èƒ½å”¤é†’producerï¼Œå› ä¸ºä»–ä»¬çš„èµ„æºæ˜¯ä¸€ä¸ªç›¸äº’dependï¼Œè€ŒåŒç±»æ˜¯ç«äº‰çš„ã€‚



















### 3.4 ä¸€ä¸ªç®€å•çš„å¹¶è¡Œé¢˜ç›®ï¼šç”»ğŸŸ

è€ƒè™‘ä¸€ä¸ªå¹¶è¡Œç¨‹åºï¼Œå®ƒè¦æ±‚ä½ ç”»å‡º`<><_`æˆ–è€…`><>_`çš„ç»„åˆ

![image-20240806155658881](./assets/image-20240806155658881.png)

å¦‚å›¾æ‰€ç¤ºï¼Œæ¯ä¸ªçº¿ç¨‹è®¤é¢†ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶é€šè¿‡barrieræŒ‰é¡ºåºè¾“å‡ºä»–ä»¬

åŸºæœ¬çš„æ€æƒ³å¾ˆç®€å•ï¼Œå°±æ˜¯çŠ¶æ€æœºï¼Œæˆ‘ä»¬ä½¿ç”¨çŠ¶æ€æœºæ¥ç¡®å®šä¸‹ä¸€ä¸ªæ‰“å°å“ªä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åä½¿ç”¨condition variableæ¥ç¡®ä¿æŒæœ‰è¯¥å­—ç¬¦çš„çº¿ç¨‹è¾“å‡ºã€‚

å¯ä»¥å‘ç°ï¼Œä»£ç å®ç°ä¸­ä¸€å…±æ‹¥æœ‰ä¸‰æ¬¡é˜»å¡æœºä¼šï¼Œä¸¤æ¬¡æ˜¯futexï¼Œä¸€æ¬¡æ˜¯cv

cvä¿è¯äº†åªæœ‰

* è·å¾—è¾“å‡ºæƒé™çš„çº¿ç¨‹(quota==1)
* åœ¨çŠ¶æ€æœºä¸­æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªæœ‰æ•ˆçŠ¶æ€(next != 0)

æ—¶æ‰èƒ½è¾“å‡º

çŠ¶æ€æœºå¦‚ä¸‹

![image-20240806160443814](./assets/image-20240806160443814.png)





å…·ä½“æ¥è¯´ï¼Œç¨‹åºçš„æ€æƒ³å°±æ˜¯é€šè¿‡condition variableåŒæ­¥çº¿ç¨‹è¾“å‡º

åŒæ—¶æ³¨æ„ï¼Œä¸ºäº†ä¿è¯è¾“å‡ºæ—¶(putchar)ä¸ä¼šæœ‰å¹²æ‰°å¯¼è‡´è¾“å‡ºæ··ä¹±ï¼Œå› æ­¤æ·»åŠ äº†quotaæ¥æ ‡å¿—ä¸€ä¸ªçº¿ç¨‹æ˜¯å¦è¾“å‡ºå®Œæˆ

å³ï¼Œä½¿ç”¨fish_beforeä½œä¸ºproducerï¼Œå¦‚æœè¯¥çº¿ç¨‹æ»¡è¶³æ¡ä»¶åˆ™å…è®¸å…¶å‘å¸ƒä»»åŠ¡

ä½¿ç”¨fish_afterä½œä¸ºconsumerï¼Œç”¨æ¥ç¡®ä¿è¯¥çº¿ç¨‹è¾“å‡ºæ—¶ä¸ä¼šå—åˆ°å¹²æ‰°

ä»»åŠ¡é˜Ÿåˆ—ä»…å…è®¸ä¸€ä¸ªä»»åŠ¡



ä»£ç å¦‚ä¸‹

å¯¹äºæ¯ä¸ªçº¿ç¨‹ï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦èƒ½è·å–é”ï¼Œè·å–é”çš„çº¿ç¨‹åˆ¤æ–­è¯¥çº¿ç¨‹æŒæœ‰çš„charæ˜¯å¦æ»¡è¶³å½“å‰æ‰“å°åˆ°çš„ä½ç½®æ‰€éœ€è¦çš„æ¡ä»¶ï¼Œè‹¥æ˜¯æ»¡è¶³åˆ™æŒæœ‰è¾“å‡ºæƒï¼ˆquota--ï¼‰ï¼Œç„¶åé‡Šæ”¾é”ï¼ˆæ­¤æ—¶é‡Šæ”¾é”ï¼Œå› ä¸ºå æœ‰äº†è¾“å‡ºæƒï¼Œå› æ­¤å…¶ä»–çº¿ç¨‹ä¹Ÿæ²¡æœ‰åŠæ³•é€šè¿‡whileï¼‰

è¯¥çº¿ç¨‹è¾“å‡ºchar

è¯¥çº¿ç¨‹é‡æ–°å°è¯•è·å–é”ï¼Œå¹¶å°†è¾“å‡ºæƒå½’è¿˜ï¼ˆquota++ï¼‰ï¼Œç„¶åå”¤é†’åœ¨whileä¸­æ²‰ç¡çš„çº¿ç¨‹

```c++
#include "thread.h"

#define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

enum { A = 1, B, C, D, E, F, };

struct rule {
  int from, ch, to;
};

struct rule rules[] = {
  { A, '<', B },
  { B, '>', C },
  { C, '<', D },
  { A, '>', E },
  { E, '<', F },
  { F, '>', D },
  { D, '_', A },
};
int current = A, quota = 1;

pthread_mutex_t lk   = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cond = PTHREAD_COND_INITIALIZER;

int next(char ch) {
  for (int i = 0; i < LENGTH(rules); i++) {
    struct rule *rule = &rules[i];
    if (rule->from == current && rule->ch == ch) {
      return rule->to;
    }
  }
  return 0;
}

void fish_before(char ch) {
  pthread_mutex_lock(&lk);
  while (!(next(ch) && quota)) {
    // can proceed only if (next(ch) && quota)
    pthread_cond_wait(&cond, &lk);
  }
  quota--;
  pthread_mutex_unlock(&lk);
}

void fish_after(char ch) {
  pthread_mutex_lock(&lk);
  quota++;
  current = next(ch);
  assert(current);
  pthread_cond_broadcast(&cond);
  pthread_mutex_unlock(&lk);
}

const char roles[] = ".<<<<<>>>>___";

void fish_thread(int id) {
  char role = roles[id];
  while (1) {
    fish_before(role);
    putchar(role); // can be long; no lock protection
    fish_after(role);
  }
}

int main() {
  setbuf(stdout, NULL);
  for (int i = 0; i < strlen(roles)-1; i++)
    create(fish_thread);
}
```



### 3.5 ä¿¡å·é‡

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›é¿å…åŒç±»çº¿ç¨‹å”¤é†’è€Œä½¿ç”¨åŒ condition variableï¼ˆæ¡ä»¶å˜é‡ï¼‰ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•ä¾èµ–äºé”çš„å­˜åœ¨ã€‚æœ‰ä¸€ç§æœºåˆ¶å¯ä»¥åœ¨ä¸ä½¿ç”¨é”çš„æƒ…å†µä¸‹ç®€å•åœ°ç»´æŠ¤ condition variableï¼Œè¿™å°±æ˜¯ä¿¡å·é‡ã€‚ä¿¡å·é‡é€šå¸¸ç”¨äºèµ„æºå‹çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ä¸­ï¼Œå¯ä»¥ä¸ä½¿ç”¨é”æ¥å®ç°åŒæ­¥ã€‚

ä¿¡å·é‡æ˜¯ä¸€ç§ç”¨äºåŒæ­¥å¹¶å‘æ“ä½œçš„æœºåˆ¶ï¼Œå®ƒçš„åº•å±‚å®ç°é€šå¸¸æ¶‰åŠä»¥ä¸‹å‡ ä¸ªå…³é”®éƒ¨åˆ†ï¼š

1. **è®¡æ•°å™¨**ï¼šä¿¡å·é‡ç»´æŠ¤ä¸€ä¸ªæ•´å‹è®¡æ•°å™¨ï¼Œç”¨äºè¡¨ç¤ºèµ„æºçš„å¯ç”¨æ•°é‡ã€‚å¯¹äºäºŒå…ƒä¿¡å·é‡ï¼ˆbinary semaphoreï¼‰ï¼Œè¿™ä¸ªè®¡æ•°å™¨è¦ä¹ˆæ˜¯0è¦ä¹ˆæ˜¯1ï¼›å¯¹äºè®¡æ•°ä¿¡å·é‡ï¼ˆcounting semaphoreï¼‰ï¼Œè¿™ä¸ªè®¡æ•°å™¨å¯ä»¥æ˜¯ä»»æ„éè´Ÿæ•´æ•°ã€‚
2. **ç­‰å¾…é˜Ÿåˆ—**ï¼šå½“ä¿¡å·é‡çš„è®¡æ•°å™¨å€¼ä¸º0æ—¶ï¼Œè¯•å›¾å‡å°ä¿¡å·é‡çš„çº¿ç¨‹ä¼šè¢«é˜»å¡å¹¶æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚ç­‰å¾…é˜Ÿåˆ—é€šå¸¸æ˜¯ä¸€ä¸ªFIFOé˜Ÿåˆ—ï¼Œä»¥ç¡®ä¿å…¬å¹³æ€§ã€‚
3. **åŸå­æ“ä½œ**ï¼šä¸ºäº†ç¡®ä¿ä¿¡å·é‡æ“ä½œçš„åŸå­æ€§ï¼Œé€šå¸¸ä¼šä½¿ç”¨ç¡¬ä»¶æä¾›çš„åŸå­æ“ä½œæŒ‡ä»¤ï¼Œå¦‚Test-and-Setã€Fetch-and-Addã€Compare-and-Swapç­‰ã€‚è¿™äº›æŒ‡ä»¤ç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯¹ä¿¡å·é‡è®¡æ•°å™¨çš„æ“ä½œæ˜¯ä¸å¯åˆ†å‰²çš„ã€‚







ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä½¿ç”¨ä¿¡å·é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹çš„ä»£ç ç¤ºä¾‹ï¼š

```c++
#include "thread.h"
#include <semaphore.h>
// ä½¿ç”¨fillå’Œemptyæ¥ä¸ºproducerå’Œconsumerç»´æŠ¤ä¸¤ä¸ªçŠ¶æ€ï¼Œå…·ä½“æ¥è¯´
// ä½¿ç”¨emptyæ¥è¡¨ç¤ºè¿˜èƒ½å‘å¸ƒçš„ä»»åŠ¡æ•°ï¼Œæ¯æ¬¡å‘å¸ƒä¸€ä¸ªä»»åŠ¡åˆ™ä¸ºfillåŠ ä¸€ï¼Œemptyå‡ä¸€
// ä½¿ç”¨fillæ¥è¡¨ç¤ºè¿˜èƒ½é¢†å–çš„ä»»åŠ¡ä¹¦ï¼Œæ¯æ¬¡é¢†å–ä»»åŠ¡fillå‡ä¸€ï¼ŒemptyåŠ ä¸€
sem_t fill, empty;

void producer() {
  while (1) {
    // é˜»å¡ç›´åˆ°emptyå¤§äº0
    // å¦‚æœemptyå¤§äº0ï¼Œå‡1ç»§ç»­
    sem_wait(&empty);
    printf("(");
	// å¢åŠ fillçš„è®¡æ•°
    sem_post(&fill);
  }
}

void consumer() {
  while (1) {
    //è°ƒç”¨ sem_wait(&fill) æ¥ç­‰å¾…å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒã€‚
    //å¦‚æœ fill ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œåˆ™å‡ 1 å¹¶ç»§ç»­ï¼›
    //å¦åˆ™ï¼Œæ¶ˆè´¹è€…ä¼šé˜»å¡ç›´åˆ° fill ä¿¡å·é‡çš„å€¼å¤§äº 0ã€‚
    sem_wait(&fill);
    printf(")");
    //è°ƒç”¨ sem_post(&empty) æ¥å¢åŠ ç©ºçš„ç¼“å†²åŒºå•å…ƒçš„è®¡æ•°ï¼Œå³å°† empty ä¿¡å·é‡çš„å€¼åŠ  1ã€‚
    sem_post(&empty);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  //ä½¿ç”¨ sem_init(&fill, 0, 0) åˆå§‹åŒ– fill ä¿¡å·é‡ä¸º 0ï¼Œè¡¨ç¤ºåˆå§‹æ—¶æ²¡æœ‰å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒ
  sem_init(&fill, 0, 0);
  //ä½¿ç”¨ sem_init(&empty, 0, atoi(argv[1])) åˆå§‹åŒ– empty ä¿¡å·é‡ä¸ºå‘½ä»¤è¡Œå‚æ•°æŒ‡å®šçš„å€¼ï¼Œè¡¨ç¤ºåˆå§‹æ—¶æœ‰å¤šå°‘ç©ºçš„ç¼“å†²åŒºå•å…ƒã€‚
  sem_init(&empty, 0, atoi(argv[1]));
  for (int i = 0; i < 8; i++) {
    create(producer);
    create(consumer);
  }
}

```

- `sem_wait(&empty)`ï¼šé˜»å¡ç›´åˆ° `empty` ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œç„¶åå°† `empty` å‡ 1ã€‚è¿™è¡¨ç¤ºç”Ÿäº§è€…ç­‰å¾…ç©ºçš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_post(&fill)`ï¼šå¢åŠ  `fill` ä¿¡å·é‡çš„å€¼ 1ã€‚è¿™è¡¨ç¤ºç”Ÿäº§è€…ç”Ÿäº§äº†ä¸€ä¸ªæ–°çš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_wait(&fill)`ï¼šé˜»å¡ç›´åˆ° `fill` ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œç„¶åå°† `fill` å‡ 1ã€‚è¿™è¡¨ç¤ºæ¶ˆè´¹è€…ç­‰å¾…å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_post(&empty)`ï¼šå¢åŠ  `empty` ä¿¡å·é‡çš„å€¼ 1ã€‚è¿™è¡¨ç¤ºæ¶ˆè´¹è€…æ¶ˆè´¹äº†ä¸€ä¸ªç¼“å†²åŒºå•å…ƒï¼Œä½¿å…¶å˜ä¸ºç©ºã€‚

é€šè¿‡ä½¿ç”¨ä¿¡å·é‡ï¼Œå¯ä»¥æœ‰æ•ˆåœ°ç®¡ç†ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´çš„åŒæ­¥ï¼Œè€Œæ— éœ€ä½¿ç”¨é”ã€‚è¿™ç§æ–¹æ³•ç®€åŒ–äº†ä»£ç ï¼Œå¹¶ä¸”åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥æé«˜æ€§èƒ½ã€‚

* `int sem_init(sem_t *sem, int pshared, unsigned int value)`: 
  * semæŒ‡å‘ä¿¡å·é‡å¯¹è±¡çš„æŒ‡é’ˆï¼Œ
  * psharedæŒ‡ç¤ºä¿¡å·é‡æ˜¯ç”¨äºè¿›ç¨‹é—´å…±äº«è¿˜æ˜¯çº¿ç¨‹é—´å…±äº«
    * pshared=0ä»£è¡¨ä¿¡å·é‡çº¿ç¨‹é—´å…±äº«ï¼Œä»…èƒ½å¤Ÿåœ¨å•ä¸ªè¿›ç¨‹çš„çº¿ç¨‹é—´ä½¿ç”¨
    * pshared=1ä»£è¡¨ä¿¡å·é‡è¿›ç¨‹é—´å…±äº«
  * `value`è¡¨ç¤ºèµ„æºçš„åˆå§‹å¯ç”¨æ•°é‡
  * æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1å¹¶è®¾ç½®`errno`æŒ‡ç¤ºé”™è¯¯





### ä¿¡å·é‡ä¸æ¡ä»¶å˜é‡



ä¿¡å·é‡æ›´é€‚åˆåœ¨==è®¡æ•°èµ„æº==æƒ…å†µä¸‹å–ä»£æ¡ä»¶å˜é‡ã€‚

* ä¿¡å·é‡æ›´é€‚åˆç”¨äºè®¡æ•°èµ„æºçš„å¯ç”¨æ€§ï¼ˆå¦‚æœ‰å¤šå°‘ç©ºç¼“å†²åŒºå•å…ƒï¼‰ã€‚

  ä¿¡å·é‡é€šå¸¸å®ç°é€šå¸¸è¾ƒä¸ºç®€å•ï¼Œå®ƒé€šè¿‡å¯¹ä¸€ä¸ªè™šæ‹Ÿèµ„æºæ± çš„ç»´æŠ¤æ¥å®ç°ç±»ä¼¼é”çš„æ•ˆæœã€‚å®ƒé€šå¸¸ä¸æ¶‰åŠå…±äº«å˜é‡ï¼Œè€Œåªæ˜¯ç»´æŠ¤ä¸€ä¸ªè™šæ‹Ÿæƒé™çš„åˆ†é…ã€‚

```c++
sem_t empty, full, mutex;

void producer() {
    while (1) {
        sem_wait(&empty);
        // ç”Ÿäº§äº§å“
        sem_post(&full);
    }
}

void consumer() {
    while (1) {
        sem_wait(&full);
        // æ¶ˆè´¹äº§å“
        sem_post(&empty);
    }
}

```



* æ¡ä»¶å˜é‡æ›´é€‚åˆç”¨äºç­‰å¾…æŸä¸ªç‰¹å®šçš„çŠ¶æ€æˆ–æ¡ä»¶ã€‚

  æ¡ä»¶å˜é‡é€šå¸¸ä¼šç»´æŠ¤ä¸€ä¸ªå…±äº«å˜é‡ï¼Œå› æ­¤å¿…é¡»æ­é…é”æ¥å®ç°ã€‚å®ƒä¸æ­¢èƒ½å¤Ÿå®Œæˆè™šæ‹Ÿæƒé™çš„åˆ†é…ï¼ˆè®¡æ•°çš„èµ„æºï¼‰ï¼Œä¹Ÿèƒ½å¤Ÿå®Œæˆå¤æ‚çŠ¶æ€çš„ç»´æŠ¤ã€‚

```c++
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond_producer = PTHREAD_COND_INITIALIZER;
pthread_cond_t cond_consumer = PTHREAD_COND_INITIALIZER;
int count = 0;
int buffer_size = 10;

void producer() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (count == buffer_size) {
            pthread_cond_wait(&cond_producer, &mutex);
        }
        // ç”Ÿäº§äº§å“
        count++;
        pthread_cond_signal(&cond_consumer);
        pthread_mutex_unlock(&mutex);
    }
}

void consumer() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (count == 0) {
            pthread_cond_wait(&cond_consumer, &mutex);
        }
        // æ¶ˆè´¹äº§å“
        count--;
        pthread_cond_signal(&cond_producer);
        pthread_mutex_unlock(&mutex);
    }
}

```













### 3.6 å“²å­¦å®¶åƒé¥­é—®é¢˜:ä¿¡å·é‡çš„å±€é™



#### é—®é¢˜æè¿°

è¿™æ˜¯å¦ä¸€ä¸ªç»å…¸çš„å¹¶å‘é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜è¦æ±‚ä¸¤ä¸ªé”çš„æŒæœ‰æƒ

![image-20240807134707394](./assets/image-20240807134707394.png)



#### ä¿¡å·é‡è§£æ³•

ä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯ä½¿ç”¨å®¹é‡ä¸º1çš„ä¿¡å·é‡æ¥ä¸ºæ¯ä¸ªå‰å­ä¸Šé”

```c++
#include "thread.h"
#include <semaphore.h>

#define N 3

sem_t locks[N];

// id in {1,2,...}
void Tphilosopher(int id){
    int lhs = (id - 1) % N;
    int rhs = (id) % N;
    
    while(1){
        sem_wait(&locks[lhs]);
        printf("T%d Got %d\n", id, lhs + 1);
        sem_wait(&locks[rhs]);
        printf("T%d Got %d\n", id, rhs + 1);
        
        sem_post(&locks[lhs]);
        sem_post(&locks[rhs]);
    }
}

int main(int argc, char *argv[]){
    for(int i = 0; i < N; i++){
        sem_init(&locks[i],0,1)
    }
    
    for(int i = 0; i < N; i++){
        create(Tphilosopher);
    }
}



```

å¯ä»¥å‘ç°ï¼Œå¾ˆå¿«å¡æ­»ï¼Œè¿™æ˜¯å› ä¸ºå¾ˆå®¹æ˜“å‡ºç°ä¸€ä¸ªæƒ…å†µï¼Œæ¯ä¸ªäººéƒ½æ‹¿äº†ä¸€ä¸ªå‰å­ï¼Œè¿™æ ·å°±æ­»é”äº†

![image-20240807143705674](./assets/image-20240807143705674.png)



ä¿¡å·é‡åªèƒ½å¤„ç†å•ä¸€èµ„æºçš„åˆ†é…ï¼Œè¿™é‡Œå¤šèµ„æºåˆ†é…å°±è¿‡äºå¤æ‚äº†ã€‚è¿˜å¥½ï¼Œæœ‰ä¸‡èƒ½çš„æ–¹æ³•ï¼Œå°±æ˜¯cvã€‚





#### condition variableè§£æ³•

ä¸€ä¸ªç®€å•çš„æƒ³æ³•å°±æ˜¯ç”¨ä¸€ä¸ªé”==å…è®¸ä¸€ä¸ªäººç”¨é¤==ï¼ˆå³ä¸ºè®¾ç½®availableä¸ºfalseï¼Œå³åˆ†é…ä»»åŠ¡ï¼‰ï¼Œç„¶åè®©è¿™ä¸ªäººç”¨é¤ï¼ˆä¹Ÿå°±æ˜¯å¤„ç†ä»»åŠ¡ï¼‰ï¼Œç­‰å¾…å®ƒå®Œæˆä»»åŠ¡åï¼Œå®ƒä¼šå†æ¬¡å°è¯•è·å–é”ï¼Œå°†å‰å­è¿˜å›å»ï¼ˆé‡ç½®ä»»åŠ¡æ± ï¼‰ï¼Œæ³¨æ„æ­¤æ—¶å› ä¸ºå‰å­å·²ç»å¯ç”¨ï¼Œæ‰€ä»¥å¯ä»¥å”¤é†’é‚£äº›æ²‰ç¡çº¿ç¨‹äº†ã€‚

```c++
#include "thread.h"
#include <semaphore.h>
#include <stdio.h>
#include<string.h>
#define N 3

pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lk = PTHREAD_MUTEX_INITIALIZER;

int available[N];

void Tphilosopher(int id) {
  int lhs = (id - 1) % N;
  int rhs = id % N;
  while (1) {
    pthread_mutex_lock(&lk);
    while(!(available[lhs] && available[rhs])){
        pthread_cond_wait(&cv, &lk);
    }
    available[rhs] = 0;
    available[lhs] = 0;

    pthread_mutex_unlock(&lk);


    printf("T%d Got %d\n", id, lhs + 1);
    printf("T%d Got %d\n", id, rhs + 1);


    pthread_mutex_lock(&lk);
    available[rhs] = 1;
    available[lhs] = 1;
    pthread_cond_broadcast(&cv);
    pthread_mutex_unlock(&lk);
  }
}

int main(int argc, char *argv[]) {

  memset(available, 1, sizeof(available));
  for (int i = 0; i < N; i++) {
    create(Tphilosopher);
  }
}
```





==æœ‰é€šç”¨çš„å°±åˆ«æ•´ç²¾å·§çš„æ–¹æ³•äº†ï¼Œå¤ªéš¾äº†==

è¿™ä¸ªæ–¹æ³•ä½¿ç”¨çš„æ˜¯æ¯ä¸ªPhilosopherè‡ªå‘çš„å»ç”³è¯·å‰å­çš„ä½¿ç”¨æƒï¼Œå®é™…ä¸Šæˆ‘ä»¬ä¹‹å‰è¯´è¿‡äº†ï¼Œ99%çš„å¹¶å‘é—®é¢˜éƒ½å¯ä»¥ä½¿ç”¨ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹æ¥è§£å†³ã€‚









#### ç”Ÿäº§è€…æ¶ˆè´¹è€…çš„ä¸€ç§ï¼šMaster-Slaveè§£æ³•

è¿™é‡Œæˆ‘ä»¬è®¾ç½®**ä¸€ä¸ª**ç”Ÿäº§è€…ï¼ˆMasterï¼‰æ¥åˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿåˆ†å‘å‰å­ï¼Œå’Œ**Nä¸ªPhilosopher**ï¼ˆSlaveï¼‰æ¥å—Masterçš„è°ƒåº¦

è¿™æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿä¸­éå¸¸å¸¸è§çš„è§£å†³æ€è·¯ï¼Œå› ä¸ºè¿™é‡Œæœ‰å¾ˆå¤§çš„æ“ä½œç©ºé—´ï¼ŒMasterèƒ½å¤Ÿæ–¹ä¾¿çš„è®¾ç½®ä¼˜å…ˆçº§å’Œåå¥½ï¼ˆä¾‹å¦‚æœ‰äººä¸Šä¸€æ¬¡åƒé¥­ç”¨äº†å¾ˆä¹…ï¼Œä¸‹ä¸€æ¬¡å¯èƒ½æˆ‘å°±åå‘äºæ”¶åˆ°å®ƒçš„è¯·æ±‚ä¹‹åæ™šä¸€äº›ç»™ä»–å‰å­çš„æƒé™ï¼‰

å¤§ä½“æ€è·¯å¦‚ä¸‹

```c++
void Tphilosopher(int id){
    send_request(id, EAT);
    P(allowed[id]);
    philosopher_eat();
    send_request(id,DONE);
}

void Twaiter(){
    while(1){
        (id,status) = reveive_request();
        if(status == EAT){}
        if(status == DONE){}
    }
}
```

æˆ‘ä»¬å¯ä»¥å…·ä½“çš„åˆ†æä¸€ä¸‹

å¯¹äºæ¶ˆè´¹è€…Slaveï¼š

* æ¯ä¸ªçº¿ç¨‹ä»£è¡¨ä¸€ä¸ªPhilosopher
* æ¯ä¸ªçº¿ç¨‹éœ€è¦åšçš„æ˜¯æäº¤ä¸€ä¸ªè¯·æ±‚ï¼Œç”³è¯·ç”¨é¤ï¼Œç­‰å¾…Masterå…è®¸åæ‰å¯ç”¨é¤
* æ¯ä¸ªçº¿ç¨‹åœ¨ç”¨å®Œé¤åéœ€è¦å†æ¬¡å‘é€ä¸€ä¸ªè¯·æ±‚ï¼Œç”³è¯·å½’è¿˜é¤å…·



å¯¹äºMaster/Waiterï¼š

* åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œä»£è¡¨æœåŠ¡ç”Ÿ
* è¯¥çº¿ç¨‹è´Ÿè´£æ¥å—æ¯ä¸ªPhilosopheræäº¤çš„ç”³è¯·ï¼Œç”³è¯·åŒ…æ‹¬ç”³è¯·ç”¨é¤å’Œå½’è¿˜é¤å…·
  * å¯¹äºç”¨é¤ç”³è¯·ï¼Œçº¿ç¨‹é¦–å…ˆåˆ¤æ–­å¯¹åº”idçš„philosopheræ‰€éœ€è¦çš„forkæ˜¯å¦æ»¡è¶³ï¼Œæ»¡è¶³åˆ™åˆ†é…ï¼Œä¸æ»¡è¶³åˆ™é©³å›
  * å¯¹äºå½’è¿˜é¤å…·ç”³è¯·ï¼Œçº¿ç¨‹ä½¿å¾—forkçš„çŠ¶æ€å˜ä¸ºå¯ç”¨



å¯¹äºè¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬åˆ†æå…±äº«å˜é‡ä¸é”

* å¯¹äºæ¶ˆè´¹è€…ï¼Œå…¶æäº¤ä¸€ä¸ªç”³è¯·ç”±å…±äº«å˜é‡ä¼ è¾¾ï¼Œå› æ­¤éœ€è¦é”

* å¯¹äºMasterï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–è€ƒè™‘æ¶ˆè´¹è€…çš„ç”³è¯·æ— æ³•æ»¡è¶³æ—¶è¯¥å¦‚ä½•å¤„ç†ã€‚

  * å¦‚æœæ˜¯å•çº¯çš„é©³å›ï¼Œé‚£ä¹ˆæ¶ˆè´¹è€…çº¿ç¨‹éœ€è¦è‡ªæ—‹çš„ä¸æ–­æäº¤ç”³è¯·ï¼Œæµªè´¹èµ„æº
  * å¦‚æœæ˜¯æç½®ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¿å­˜æ¶ˆè´¹è€…çº¿ç¨‹çš„ç”³è¯·å¹¶ç”¨ä¸€ä¸ªdirty bitæ ‡æ˜è¯¥ç”³è¯·æ˜¯å¦è¿˜æœ‰æ•ˆ

  æ˜¾ç„¶ç¬¬äºŒç§æƒ…å†µæ˜¯è¾ƒä¸ºåˆç†çš„ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªç»“æ„ä½“æ¥ä»£è¡¨æ¯ä¸ªæ¶ˆè´¹è€…çš„ç”³è¯·çŠ¶æ€ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜ï¼ŒMasterå¾ªç¯éå†æ•°ç»„ã€‚å®¹æ˜“å‘ç°Masterè®¿é—®æ•°ç»„ä¹Ÿéœ€è¦é”ï¼Œæˆ‘ä»¬ç§°ä¸º`lk_state`

  

  Masteråœ¨å‘ç°äº†ä¸€ä¸ªè¯·æ±‚å¯ä»¥æ‰¹å‡†ä¹‹åï¼Œå®ƒåº”è¯¥ä¼šé€šè¿‡ä¸€ä¸ªå…±äº«å˜é‡ä¼ é€’å›å»ï¼ˆæˆ–è€…ä¸€ä¸ªä¿¡å·é‡ï¼‰ï¼Œè¿™ä¸ªæ“ä½œä¹Ÿåº”è¯¥ä¸Šé”ï¼Œç§°ä¸º`lk_allowed`

  

  Masterç»´æŠ¤äº†ä¸€ä¸ªå‰å­ä½¿ç”¨æƒ…å†µçš„è¡¨ï¼Œè¿™ä¸ªè¡¨ä»…æœ‰Masterè‡ªå·±èƒ½å¤Ÿä¿®æ”¹è¯»å–ï¼Œå› æ­¤ä¸éœ€è¦ä¸Šé”



![image-20240808100952077](./assets/image-20240808100952077.png)

å› æ­¤ï¼Œè¿™ä¸ªè¿‡ç¨‹çš„ä»£ç ä½¿ç”¨cvçœ‹èµ·æ¥åº”è¯¥æ˜¯å¦‚ä¸‹

```c++
```



























































## 4. ç°å®ä¸–ç•Œä¸­çš„å¹¶å‘ç¼–ç¨‹

* é«˜æ€§èƒ½è®¡ç®—çš„å¹¶å‘

  * MPIï¼ŒOpenMP

    > Parallel and Distributed Computation: Numeric Methods

  * è®¡ç®—ä»»åŠ¡å¦‚ä½•åˆ†è§£

    * è®¡ç®—å›¾éœ€è¦å®¹æ˜“å¹¶è¡ŒåŒ–ï¼ˆæœºå™¨-çº¿ç¨‹ä¸¤çº§ä»»åŠ¡åˆ†è§£ï¼‰
    * ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹è§£å†³ä¸€åˆ‡

* æ•°æ®ä¸­å¿ƒçš„å¹¶å‘

  * å¤šå‰¯æœ¬æƒ…å†µä¸‹çš„é«˜å¯é ä½å»¶è¿Ÿæ•°æ®è®¿é—®

    åŒ…æ‹¬æ•°æ®çš„ä¸€è‡´æ€§(Consistency)

    æœåŠ¡æ—¶åˆ»ä¿æŒå¯ç”¨(Availability)

    å®¹å¿æœºå™¨ç¦»çº¿(Partition tolerance)

  * é€šå¸¸æ¥è¯´ï¼Œæ•°æ®ä¸­å¿ƒçš„å¹¶å‘åœ¨äºè®©ä¸€å°è®¡ç®—æœºèƒ½å¤Ÿå°½å¯èƒ½å¤šçš„æœåŠ¡å¹¶è¡Œçš„è¯·æ±‚

    ä¾‹å¦‚QPS(Query Per Second)ï¼ŒTail latency(å‡å°‘æœ€æ…¢å¤„ç†è¯·æ±‚çš„latency)







### æ•°æ®ä¸­å¿ƒçš„å¹¶å‘

#### åç¨‹

æåˆ°æ•°æ®ä¸­å¿ƒçš„å¹¶å‘ï¼Œå°±ä¸å¾—ä¸æåˆ°åç¨‹äº†

è™½ç„¶å¹¶å‘é€šå¸¸ä½¿ç”¨çº¿ç¨‹ï¼ˆåœ¨HPCä¸­æ›´æ˜¯å¦‚æ­¤ï¼‰ï¼Œä½†æ˜¯ä¸åŒäºHPCçš„è®¡ç®—å¯†é›†å‹ï¼Œå¦‚æœä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†ä¸€ä¸ªRequestè¿™æ ·çš„è¯ï¼Œçº¿ç¨‹åˆ‡æ¢çš„æ¶ˆè€—ç›¸æ¯”ä¹‹ä¸‹å°±æ˜¾å¾—å¾ˆå¤§äº†

> çº¿ç¨‹åˆ‡æ¢çš„æ¶ˆè€—åŒ…æ‹¬syscallï¼Œå†…æ ¸å¯¹çº¿ç¨‹å¯„å­˜å™¨ç©ºé—´çš„å¤åˆ¶ï¼ˆæ—¶é—´èµ„æºï¼‰ä»¥åŠä¸€ä¸ªçº¿ç¨‹æœ¬èº«å°±å¾ˆå¤§ï¼ˆè‡³å°‘8KBï¼Œç©ºé—´èµ„æºï¼‰

ä¸€ä¸ªæ–°çš„æ¦‚å¿µè¢«æäº†å‡ºæ¥ï¼Œè¿™å°±æ˜¯åç¨‹ã€‚

* åç¨‹**åœ¨ä¸€ä¸ªçº¿ç¨‹å†…å­˜åœ¨**
* åç¨‹ç”±**ç”¨æˆ·æ€è°ƒåº¦**

åç¨‹çš„åˆ‡æ¢ç”±å‡½æ•°æ¥å®ç°ï¼ˆ`yield()`ï¼‰ï¼Œè¿™æ„å‘³ç€åç¨‹æ‹¥æœ‰æ›´å¥½çš„åˆ‡æ¢æ€§èƒ½ï¼ˆå› ä¸ºæ˜¯åœ¨ä¸€ä¸ªçº¿ç¨‹å†…åˆ‡æ¢ï¼Œæ²¡æœ‰å†…æ ¸åˆ‡æ¢å¼€é”€ï¼‰ã€‚

åŒæ—¶ï¼Œåç¨‹çš„æ€§è´¨ä¹Ÿå†³å®šäº†åç¨‹å®¹æ˜“é€ æˆçº¿ç¨‹çš„å µå¡ã€‚

å½“ä¸€ä¸ªåç¨‹éœ€è¦ä¸€æ¬¡500msçš„è¯»å–æ—¶(`read()`)ï¼Œå®ƒé€šå¸¸ä¼šé˜»å¡æ•´ä¸ªçº¿ç¨‹ç›´åˆ°è·å¾—ç»“æœ

è€Œå½“ä¸€ä¸ªçº¿ç¨‹éœ€è¦ä¸€æ¬¡500msçš„è¯»å–æ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šç›´æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼ˆè¿™ä¹Ÿå°±æ˜¯æ“ä½œç³»ç»Ÿæ— æ³•è°ƒåº¦åç¨‹ï¼Œè¿™ä¸ªè¯´æ³•çš„ç”±æ¥ï¼Œåç¨‹é€šå¸¸ä¼šé€šè¿‡è‡ªå·±è°ƒç”¨yieldæ¥åˆ‡æ¢ï¼‰

![image-20240808162058320](./assets/image-20240808162058320.png)





å¯¹äºrequesté«˜å¹¶å‘è¿™ç§åœºæ™¯æ¥è¯´ï¼Œåç¨‹å› ä¸ºå…¶å»‰ä»·çš„åˆ‡æ¢ï¼Œæ— ç–‘æ˜¯ååˆ†åˆé€‚çš„ï¼Œä½†æ˜¯åç¨‹ä¼šé‡åˆ°å‡ ä¸ªé—®é¢˜

* åç¨‹è¯»å–æ—¶çš„çº¿ç¨‹å µå¡
* åç¨‹è¿è¡Œæ—¶çš„çº¿ç¨‹åˆ‡æ¢ï¼ˆæ¯•ç«Ÿä½ å¤šçº¿ç¨‹ï¼Œæ“ä½œç³»ç»Ÿå“ªé‡ŒçŸ¥é“ä½ åœ¨è·‘åç¨‹ï¼Œç»™ä½ åˆ‡æ¢äº†ï¼Œåç¨‹çš„ä¼˜åŠ¿è¡ç„¶æ— å­˜ï¼‰



Goè¯­è¨€å®ç°äº†Goroutineæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¿™ä½¿å¾—Goè¯­è¨€æˆä¸ºäº†é«˜å¹¶å‘åœºæ™¯ä¸‹çš„é¦™é¥½é¥½

ç®€å•æ¥è¯´ï¼Œ

* **Goroutineè°ƒåº¦å™¨**ï¼š
  - Goè¯­è¨€æœ‰ä¸€ä¸ªé«˜æ•ˆçš„è°ƒåº¦å™¨ï¼ˆGoroutine schedulerï¼‰ï¼Œè´Ÿè´£ç®¡ç†Goroutineçš„æ‰§è¡Œã€‚è°ƒåº¦å™¨ä½¿ç”¨Mï¼ˆMachineï¼‰-Pï¼ˆProcessorï¼‰-Gï¼ˆGoroutineï¼‰æ¨¡å‹ï¼š
    - **Mï¼ˆMachineï¼‰**ï¼šä»£è¡¨æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚
    - **Pï¼ˆProcessorï¼‰**ï¼šä»£è¡¨é€»è¾‘å¤„ç†å™¨ï¼Œç»‘å®šåˆ°å…·ä½“çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚
    - **Gï¼ˆGoroutineï¼‰**ï¼šä»£è¡¨åç¨‹ã€‚
* **æ¯ä¸ªå¤„ç†å™¨ç»‘å®šä¸€ä¸ªçº¿ç¨‹**ï¼š
  - Goè¯­è¨€çš„è°ƒåº¦å™¨å°†æ¯ä¸ªé€»è¾‘å¤„ç†å™¨ï¼ˆPï¼‰ç»‘å®šåˆ°ä¸€ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ˆMï¼‰ï¼Œä»è€Œå‡å°‘çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€ã€‚Goroutineåœ¨è¿™äº›ç»‘å®šçš„çº¿ç¨‹ä¸­è¿è¡Œï¼Œé¿å…äº†é¢‘ç¹çš„çº¿ç¨‹åˆ‡æ¢ã€‚
* **åç¨‹é˜»å¡æ—¶çš„è°ƒåº¦**ï¼š
  - å½“ä¸€ä¸ªGoroutineæ‰§è¡Œé˜»å¡çš„æ“ä½œï¼ˆå¦‚I/Oæ“ä½œï¼‰æ—¶ï¼Œè°ƒåº¦å™¨ä¼šå°†é˜»å¡çš„GoroutineæŒ‚èµ·ï¼Œå¹¶åˆ‡æ¢åˆ°å…¶ä»–å¯è¿è¡Œçš„Goroutineã€‚è¿™ç§æœºåˆ¶ç±»ä¼¼äºäº‹ä»¶é©±åŠ¨çš„åˆ‡æ¢ï¼Œç¡®ä¿é«˜æ•ˆçš„å¹¶å‘å¤„ç†ã€‚
* **äº‹ä»¶é©±åŠ¨çš„åˆ‡æ¢**ï¼š
  - è°ƒåº¦å™¨ä½¿ç”¨ç±»ä¼¼äºyieldçš„æœºåˆ¶ï¼Œå½“Goroutineè¢«é˜»å¡æ—¶ï¼Œè°ƒåº¦å™¨ä¼šåˆ‡æ¢åˆ°å…¶ä»–Goroutineç»§ç»­æ‰§è¡Œï¼Œç›´åˆ°é˜»å¡æ“ä½œå®Œæˆåå†åˆ‡æ¢å›åŸæ¥çš„Goroutineã€‚

![image-20240808163649714](./assets/image-20240808163649714.png)







#### Goè¯­è¨€çš„å“²å­¦

> Do not communicate by sharing memory; instead, share moemory by communicating

å…±äº«å†…å­˜=ä¸‡æ¶ä¹‹æºï¼Œå› ä¸ºå®ƒå…è®¸æ¯ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹ï¼Œä¸€ä¸ªæ²¡é”ä½å°±å‡ºäº‹

å¦å¤–è¿˜æœ‰å› ä¸ºOSè°ƒåº¦ä¸‹çš„å„ç§å¥‡æ€ªçš„å¹¶å‘bugs

* æ¡ä»¶å˜é‡ï¼šbroadcastæ€§èƒ½ä½ï¼Œsignalä¼šå› ä¸ºè°ƒåº¦åŸå› å®¹æ˜“é”™
* ä¿¡å·é‡ï¼šç®¡ç†å¤šç§èµ„æºæ—¶çƒ‚å®Œäº†

å› æ­¤ï¼Œgoè®¤ä¸ºï¼Œæ—¢ç„¶ç”Ÿäº§è€…æ¶ˆè´¹è€…å¯ä»¥è§£å†³ç»å¤§éƒ¨åˆ†é—®é¢˜ï¼Œé‚£ä¹ˆæä¾›ä¸€ä¸ªAPIå°±å¥½äº†

å…·ä½“æ¥è¯´ï¼Œ

* goä½¿ç”¨ä¸€ä¸ªchannelæ¥æè¿°å·¥ä½œé˜Ÿåˆ—ï¼Œä¾‹å¦‚åˆ›å»ºä¸€ä¸ªå®¹é‡ä¸º10çš„channel`var stream = make(chan int, 10)`
* æ·»åŠ ä»»åŠ¡ï¼ˆç”Ÿäº§è€…ï¼‰`stream<-i`
* å–å‡ºä»»åŠ¡ï¼ˆæ¶ˆè´¹è€…ï¼‰`x:=<-stream`

å¯ä»¥å‘ç°ç»è¿‡GOåŒ…è£…è¿‡çš„å¹¶å‘ç¨‹åºååˆ†çš„å®¹æ˜“é˜…è¯»

```go
package main

import "fmt"

var stream = make(chan int, 10)
const n = 4

func produce() {
    for i := 0; i < n; i++ {
        fmt.Println("produce", i)
        stream <- i
    }
}

func consume() {
    for {
        x := <-stream
        fmt.Println("consume", x)
    }
}

func main() {
    for i := 0; i < n; i++ {
        go produce()
    }
    consume()
}

```



Goè§£å†³äº†é«˜å¹¶å‘IOçš„é—®é¢˜ï¼Œ

**æ¦‚å¿µä¸Šæ˜¯çº¿ç¨‹ï¼Œå®é™…ä¸Šæ˜¯çº¿ç¨‹å’Œåç¨‹çš„æ··åˆä½“**

- Goroutine çš„çº¿ç¨‹å…¶å®å°±æ˜¯C++çš„åç¨‹ï¼ŒGoç»“åˆäº†çº¿ç¨‹å’Œåç¨‹çš„ä¼˜ç‚¹ï¼Œå®ç°é«˜æ•ˆçš„å¹¶å‘å¤„ç†ã€‚

**æ¯ä¸ª CPU ä¸Šæœ‰ä¸€ä¸ª Go Workerï¼Œè‡ªç”±è°ƒåº¦ goroutines**

- Go è¿è¡Œæ—¶ä¸ºæ¯ä¸ª CPU åˆ†é…ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ï¼ˆGo Workerï¼‰ï¼Œè¿™äº›çº¿ç¨‹è´Ÿè´£è°ƒåº¦å’Œæ‰§è¡Œ goroutineã€‚

**æ‰§è¡Œåˆ° blocking API æ—¶ï¼ˆä¾‹å¦‚ sleep, readï¼‰**

- å½“ Goroutine é‡åˆ°é˜»å¡çš„ API è°ƒç”¨ï¼ˆä¾‹å¦‚readï¼ˆï¼‰çš„syscallï¼‰ï¼ŒGoä¼šè½¬è€Œè°ƒç”¨non-blockçš„syscallç‰ˆæœ¬

  - æˆåŠŸï¼šå¦‚æœéé˜»å¡æ“ä½œæˆåŠŸï¼ŒGoroutine ä¼šç«‹å³ç»§ç»­æ‰§è¡Œã€‚
  - å¤±è´¥ï¼šå¦‚æœéé˜»å¡æ“ä½œå¤±è´¥ï¼ŒGoroutine ä¼šç«‹å³è®©å‡º CPUï¼Œåˆ‡æ¢åˆ°å¦ä¸€ä¸ªå¯è¿è¡Œçš„ Goroutineã€‚

  

































## 5. å¹¶å‘ç¨‹åºè°ƒè¯•

### å¯¹äºç®€å•å¹¶å‘ç¨‹åº

ä½¿ç”¨.pyéå†çŠ¶æ€æ ‘

> https://www.bilibili.com/video/BV15T4y1Q76V/?spm_id_from=333.788&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9
>
> 55:18

Model Checkerçš„é€šå¸¸**å‡è®¾æ˜¯æ¯ä¸€è¡Œçš„æ“ä½œæ˜¯åŸå­çš„**ï¼ˆæˆ–è€…ä¹Ÿå¯ä»¥æ‰‹åŠ¨åŒ…å«è‹¥å¹²ä¸ªè¿ç»­æ“ä½œä¸ºåŸå­çš„ï¼‰ï¼Œç„¶åé€šè¿‡generatorçš„æ–¹å¼è·å–çŠ¶æ€é˜Ÿåˆ—ã€‚





### å¯¹äºå¤æ‚å¹¶å‘ç¨‹åº

#### DeadLockï¼ˆæ­»é”ï¼‰

æ­»é”å°±æ˜¯çº¿ç¨‹äº’ç›¸ç­‰å¾…çš„æƒ…å†µã€‚

æ­»é”å¹¶ä¸é€šå¸¸æ˜¯é‚£ä¹ˆå®¹æ˜“å‘ç°çš„é”™è¯¯ï¼Œ ==å› ä¸ºå®ƒé€šå¸¸å¯èƒ½ä¸æ˜¯ä¸€ä¸ªé€»è¾‘é”™è¯¯ï¼Œè€Œæ˜¯ä¼šä¸æ“ä½œç³»ç»Ÿè‡ªå‘çš„æœºåˆ¶æœ‰å…³ã€‚==



##### å•çº¿ç¨‹æ­»é”ï¼šä¸­æ–­xè‡ªæ—‹é”

ä¸¾ä¾‹æ¥è¯´ï¼Œè‡ªæ—‹é”éœ€è¦å…³ä¸­æ–­ï¼Œå› ä¸ºä¸­æ–­å¸¸å¸¸ä¼šå¯¼è‡´æ­»é”ï¼Œè¿™ä¸ªåœ¨ä½ çš„æ­£å¸¸ç¨‹åºé€»è¾‘ä¸­é€šå¸¸æ˜¯å¾ˆéš¾è¢«å‘ç°çš„

> ä¸­æ–­ç¨‹åºï¼Œä¹Ÿç§°ä¸ºä¸­æ–­æœåŠ¡ç¨‹åºï¼ˆInterrupt Service Routine, ISRï¼‰æˆ–ä¸­æ–­å¤„ç†ç¨‹åºï¼Œæ˜¯ä¸€ä¸ªç”±ç¡¬ä»¶æˆ–è½¯ä»¶è§¦å‘ï¼Œ**ç”¨äºå“åº”ç‰¹å®šäº‹ä»¶å¹¶æ‰§è¡Œç›¸åº”æ“ä½œçš„ç¨‹åº**ã€‚åœ¨æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­ï¼Œä¸­æ–­ç¨‹åºæ˜¯éå¸¸é‡è¦çš„éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒä»¬ä½¿ç³»ç»Ÿèƒ½å¤ŸåŠæ—¶å“åº”ç¡¬ä»¶è®¾å¤‡å’Œå¤„ç†é«˜ä¼˜å…ˆçº§ä»»åŠ¡ã€‚
>
> ä¸­æ–­ç¨‹åºä¸€èˆ¬ç”¨äºå¤„ç†
>
> * ç¡¬ä»¶äº‹ä»¶ï¼šå¤„ç†ç”±ç¡¬ä»¶è®¾å¤‡è§¦å‘çš„ä¸­æ–­ï¼Œå¦‚é”®ç›˜æŒ‰é”®ã€é¼ æ ‡ç‚¹å‡»ã€ç½‘ç»œæ•°æ®åˆ°è¾¾ã€ç£ç›˜I/Oå®Œæˆç­‰ã€‚
> * ç³»ç»Ÿå‘¨æœŸæ€§ä»»åŠ¡
> * å¤šä»»åŠ¡è¿›ç¨‹è°ƒåº¦ï¼ˆè½®è½¬æ—¶é—´ç‰‡è°ƒåº¦ï¼‰
>
> ä¸­æ–­æœ‰æ—¶ä¼šéœ€è¦é”ï¼Œå› ä¸ºç¡¬ä»¶è®¾å¤‡è§¦å‘çš„ä¸­æ–­å¯èƒ½ä¼šéœ€è¦ä¿®æ”¹å…±äº«å˜é‡åŒº





å‡è®¾ä½ çš„spinlockä¸å°å¿ƒå‘ç”Ÿäº†ä¸­æ–­ï¼Œå…·ä½“æ¥è¯´

* åœ¨ä¸è¯¥æ‰“å¼€ä¸­æ–­çš„æ—¶å€™å¼€äº†ä¸­æ–­
* åœ¨ä¸è¯¥åˆ‡æ¢çš„æ—¶å€™æ‰§è¡Œäº†`yield`

åŒæ—¶å¾ˆä¸å¹¸çš„ï¼Œä½ çš„ä¸­æ–­ç¨‹åºå®ç°æ°å¥½éœ€è¦ä¸€ä¸ªé”ï¼Œå°±æœ‰å¯èƒ½å‘ç”Ÿæ­»é”ï¼ˆå› ä¸ºä¸­æ–­æ˜¯éšæœºå‡ºç°çš„ï¼Œå› æ­¤å¾ˆå®¹æ˜“è¢«å¿½ç•¥ï¼‰



ä»¥ä»¥ä¸‹ä»£ç ä¸ºä¾‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸çš„å®ç°ï¼Œå®ç°äº†ä¸€ä¸ªçº¿ç¨‹çš„æ­»é”ï¼Œ**å‡è®¾å…¶é”çš„è®¾è®¡ä¸ºåœ¨lockçš„æ—¶å€™å…³ä¸­æ–­ï¼Œåœ¨unlockçš„æ—¶å€™å¼€ä¸­æ–­**

é‚£ä¹ˆï¼Œè¿™é‡Œé”å¥—é”çš„æƒ…å†µï¼Œ**unlock Bé”å°±ä¼šæ‰“å¼€ä¸­æ–­**ï¼Œæ­¤æ—¶å°±å‘ç”Ÿäº†â€œåœ¨æŒæœ‰ä¸€ä¸ªé”çš„æ—¶å€™å…è®¸ä¸­æ–­â€çš„æƒ…å†µ

ç„¶åï¼Œå¾ˆä¸å¹¸çš„ï¼Œæ­¤æ—¶OSè°ƒç”¨äº†yieldæˆ–è€…æŸä¸ªç¡¬ä»¶è°ƒç”¨äº†ä¸­æ–­ï¼Œ`on_interrupt`ç¨‹åºè¢«è°ƒç”¨äº†, ç¨‹åºå°±ä¼šè¢«å¡åœ¨spin_lock(&A)ä¸­(line11)

```c++
void os_run(){
    spin_lock(&A);
    spin_lock(&B);
    spin_unlock(&B);
    // interrupt occurred and call on_interrupt
    spin_unlock(&A);    
}

// ä¸­æ–­å¤„ç†ç¨‹åº
void on_interrupt(){
    spin_lock(&A);
    spin_unlock(&A);
}
```



> ä¾‹å¦‚ï¼Œåœ¨ä¿¡å·ï¼ˆè½¯ä¸­æ–­ï¼‰ä¸­è°ƒç”¨printfå°±ä¼šå‡ºç°ä¸Šé¢æå‡ºçš„è¿™ç§bug
>
> é¦–å…ˆéœ€è¦æ˜ç¡®ä¸€ç‚¹ï¼Œ**printfåœ¨å•ä¸€æ‰§è¡Œçº¿ç¨‹ä¸­æ˜¯åŸå­çš„**ï¼Œä½†æ˜¯åœ¨å¹¶å‘ç¯å¢ƒä¸­å¹¶ä¸æ˜¯åŸå­çš„
>
> è¿™æ˜¯å› ä¸ºprintfæ¶‰åŠå¤šä¸ªæ­¥éª¤ï¼ŒåŒ…æ‹¬åŒ…æ‹¬æ ¼å¼åŒ–å­—ç¬¦ä¸²ã€è®¿é—®å…±äº«ç¼“å†²åŒºã€æ‰§è¡ŒI/Oæ“ä½œç­‰ï¼Œé€šå¸¸ä½¿ç”¨ä¸€ä¸ªé”æ¥ä¿è¯å…¶åœ¨å•ä¸€çº¿ç¨‹ç¯å¢ƒçš„åŸå­æ€§ã€‚
>
> ä½†æ˜¯ï¼Œåœ¨å¼‚æ­¥å¹¶å‘ç¯å¢ƒä¸‹ï¼Œä¾‹å¦‚ä¿¡å·å¤„ç†ç¨‹åºï¼Œå¦‚æœåœ¨å‰ä¸€ä¸ªprintfè·å–é”çš„æ—¶å€™ï¼Œæ‰§è¡Œä¿¡å·å¤„ç†ç¨‹åºï¼Œé‚£ä¹ˆä¿¡å·å¤„ç†ç¨‹åºä¸­çš„printfå°±ä¼šå†æ¬¡å°è¯•è·å–é”ï¼ˆè‡ªæ—‹é”ï¼‰å¹¶ä¸”å¡åœ¨é‚£é‡Œï¼Œå½¢æˆæ­»é”
>
> > Singal Handlerï¼Œå®ƒæ˜¯å¼‚æ­¥æ‰§è¡Œç¨‹åºå¯ä»¥åœ¨ç¨‹åºä»»æ„ç‚¹è¢«è§¦å‘ï¼Œä¹Ÿå°±æ˜¯åœ¨ä»»æ„æ—¶é—´ç‚¹ä¸­æ–­ç¨‹åº¦çš„æ­£å¸¸æ‰§è¡Œ











##### å¤šçº¿ç¨‹æ­»é”ï¼šABBA

```c++
void swap(int i,int j){
    spin_lock(&lock[i]);
    spin_lock(&lock[j]);
    
    arr[i] = NULL;
    arr[j] = arr[i];
    
    spin_unlock(&lock[j]);
    spin_unlock(&lock[i]);
}
```

è¿™ä¹Ÿæ˜¯å¾ˆå¸¸è§çš„ä¸€ä¸ªæ­»é”çš„ç±»å‹ï¼Œè€Œä¸”å¾ˆéš¾çœ‹å‡ºæ¥

==é—®é¢˜åœ¨äºï¼Œä¸Šä¸¤æŠŠé”çš„è¡Œä¸ºä¸æ˜¯åŸå­çš„==

æœ€ç®€å•çš„ï¼Œä¸¤ä¸ªçº¿ç¨‹åˆ†åˆ«æ‰§è¡Œ`swap(1,2)`å’Œ`swap(2,1)`ï¼Œä»–ä»¬éƒ½ä¼šå¡åœ¨line3ï¼Œä¹Ÿå°±æ˜¯éƒ½è·å–äº†ç¬¬ä¸€æŠŠé”è€Œæ²¡æœ‰è·å–ç¬¬äºŒæŠŠé”ï¼ˆå› ä¸ºåœ¨å¯¹æ–¹æ‰‹é‡Œï¼‰

æœ€å¸¸è§çš„ï¼Œä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«æ‰§è¡Œ`swap(1,2)`, `swap(2,3)`å’Œ`swap(3,1)`ï¼Œæ­¤æ—¶ä¹Ÿä¼šé€ æˆæ­»é”ï¼Œè¿™å°±æ˜¯ç”±ä¸Šé”é¡ºåºå†³å®šçš„

è¿™ä¸ªç±»å‹åœ¨ä¹‹å‰çš„[Philosopher Dinning](####ä¿¡å·é‡è§£æ³•)ä¸­å±•ç°è¿‡ï¼Œæ¯ä¸ªäººæŒæœ‰ä¸€ä¸ªå‰å­







##### æ­»é”äº§ç”Ÿçš„å¸¸è§æ¡ä»¶

å¿…è¦æ¡ä»¶ï¼š

* äº’æ–¥ï¼šä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨

* è¯·æ±‚ä¸ä¿æŒï¼šä¸€ä¸ªè¿›ç¨‹è¯·æ±‚èµ„æºé˜»å¡æ—¶ï¼Œä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº

  ```c++
  //å³ä¸ºä¸ä¼šè¿™ä¹ˆå†™
  void swap(int i,int j){
      spin_lock(&lock[i]);
      
      //spin_unlock(&lock[i]);
      // ä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº
      spin_lock(&lock[j]);
      
      arr[i] = NULL;
      arr[j] = arr[i];
      
      spin_unlock(&lock[j]);
      spin_unlock(&lock[i]);
  }
  ```

* ä¸å‰¥å¤ºï¼šè¿›ç¨‹å·²è·å¾—çš„èµ„æºä¸èƒ½å¼ºè¡Œå‰¥å¤º

* å¾ªç¯ç­‰å¾…ï¼šè‹¥å¹²è¿›ç¨‹ä¹‹é—´å½¢æˆå¤´å°¾ç›¸æ¥çš„å¾ªç¯ç­‰å¾…èµ„æºå…³ç³»









##### ä¼˜ç§€çš„é˜²å¾¡æ€§ç¼–ç¨‹ï¼šAA-DeadLock

è¿™ä¸ªè‡ªæ—‹é”æ¥è‡ªxv6çš„è‡ªæ—‹é”ï¼Œæˆ‘ä»¬å°†å±•ç¤ºå…¶é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œå¹¶å­¦ä¹ å¦‚ä½•é¿å…æ­»é”

é¦–å…ˆçœ‹ä¸€ä¸ªç®€å•çš„è‡ªæ—‹é”

```c++
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<stadatomic.h>

typedef struct{
    atomic_flag locked;
}spinlock_t;

void initlock(spinlock_t *lock){
    atomic_flag_clear(&lock->locked);
}

void acquire(spinloc_t *lock){
    while(atomic_flag_test_and_Set(&lock->locked)){
        
    }
}

void release(spinlock_t *lock){
    atomic_flag_clear(&lock->locked);
}

```

* `atomic_flag_clear`è¡¨ç¤ºå°†æ ‡å¿—æ¸…é™¤ï¼Œè¡¨ç¤ºé”å¤„äºæœªé”å®šçŠ¶æ€
* `atomic_flag_test_and_set`å°†lockedæ ‡å¿—è®¾ç½®ä¸º1å¹¶è¿”å›ä¹‹å‰çš„å€¼ï¼Œæ¨¡æ‹Ÿæ¯ä¸ªçº¿ç¨‹å°è¯•å°†é”æ‹¿è¿‡æ¥å¹¶è®¾ç½®å…¬ç”¨é’¥åŒ™ä¸ºä¸å¯ç”¨çš„åšæ³•

è¿™ä¸ªç®€å•çš„ç¨‹åºå»ºç«‹äº†ä¸€ä¸ªè‡ªæ—‹é”ï¼Œé€šå¸¸æ¥è¯´ï¼Œä¸€ä¸ªçº¿ç¨‹æ˜¯å¦‚ä¸‹ä½¿ç”¨è¿™é”çš„

```c++
void *worker(void *arg) {
    spinlock_t *lock = (spinlock_t *)arg;
    acquire(lock);
    // ä¸´ç•ŒåŒºå¼€å§‹
    printf("Lock acquired by thread %lu\n", pthread_self());
    // ä¸´ç•ŒåŒºç»“æŸ
    release(lock);
    return NULL;
}

```





xv6ä¸»è¦æ·»åŠ äº†ä»¥ä¸‹ä¸‰ä¸ªéƒ¨åˆ†

* æ·»åŠ CPUä¿¡æ¯æ–¹ä¾¿è°ƒè¯•

* ä¸Šé”å‰å…³é—­ä¸­æ–­ï¼Œå…³é”åæ‰“å¼€ä¸­æ–­

* ä½¿ç”¨å†…å­˜å±éšœä¿è¯ä¸è¦å°†`load`æˆ–è€…`store`æ“ä½œé€¾è¶Šè¯¥æŒ‡ä»¤ï¼Œä¿è¯ä¸Šé”åå†…å­˜ä¿®æ”¹ä¸¥æ ¼çš„å¤„äºé”å†…ã€‚

  > Tell the C compiler and the processor to not move loads or stores past this point, to ensure that the critical section's memory references happen strictly after the lock is acquired. 

```c++
// Mutual exclusion spin locks.

#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "spinlock.h"
#include "riscv.h"
#include "proc.h"
#include "defs.h"

void
initlock(struct spinlock *lk, char *name)
{
  lk->name = name;
  lk->locked = 0;
  lk->cpu = 0;
}

// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic("acquire");

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &lk->locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk->cpu = mycpu();
}

// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic("release");

  lk->cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk->locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &lk->locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&lk->locked);
    
  pop_off();
}

// Check whether this cpu is holding the lock.
// Interrupts must be off.
int
holding(struct spinlock *lk)
{
  int r;
  r = (lk->locked && lk->cpu == mycpu());
  return r;
}

// push_off/pop_off are like intr_off()/intr_on() except that they are matched:
// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts
// are initially off, then push_off, pop_off leaves them off.

void
push_off(void)
{
  int old = intr_get();

  intr_off();
  if(mycpu()->noff == 0)
    mycpu()->intena = old;
  mycpu()->noff += 1;
}

void
pop_off(void)
{
  struct cpu *c = mycpu();
  if(intr_get())
    panic("pop_off - interruptible");
  if(c->noff < 1)
    panic("pop_off");
  c->noff -= 1;
  if(c->noff == 0 && c->intena)
    intr_on();
}
```

> `panic`å‡½æ•°æ˜¯ä¸€ç§ç”¨äºå¤„ç†ä¸¥é‡é”™è¯¯çš„æœºåˆ¶ï¼Œé€šå¸¸åœ¨æ“ä½œç³»ç»Ÿå†…æ ¸æˆ–ä½çº§ç³»ç»Ÿç¼–ç¨‹ä¸­ä½¿ç”¨ã€‚å½“ç³»ç»Ÿé‡åˆ°æ— æ³•æ¢å¤çš„é”™è¯¯æ—¶ï¼Œä¼šè°ƒç”¨`panic`å‡½æ•°ä»¥åœæ­¢ç³»ç»Ÿè¿è¡Œå¹¶æä¾›é”™è¯¯ä¿¡æ¯ã€‚
>
> å½“è°ƒç”¨`panic`å‡½æ•°æ—¶ï¼Œç³»ç»Ÿä¼šåœæ­¢æ‰€æœ‰æ­£å¸¸æ“ä½œã€‚è¿™é€šå¸¸åŒ…æ‹¬åœæ­¢æ‰€æœ‰è¿›ç¨‹ã€ä¸­æ–­æ‰€æœ‰è®¾å¤‡æ“ä½œç­‰ã€‚
>
> `panic`å‡½æ•°é€šå¸¸ä¼šè¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼Œå¸®åŠ©å¼€å‘è€…æˆ–ç³»ç»Ÿç®¡ç†å‘˜è¯Šæ–­é—®é¢˜ã€‚è¿™äº›ä¿¡æ¯é€šå¸¸åŒ…æ‹¬é”™è¯¯çš„æè¿°ã€å‘ç”Ÿé”™è¯¯çš„ä»£ç ä½ç½®ç­‰ã€‚
>
> è°ƒç”¨`panic`å‡½æ•°åï¼Œç³»ç»Ÿè¿›å…¥ä¸€ç§ä¸å¯æ¢å¤çš„çŠ¶æ€ï¼Œéœ€è¦é€šè¿‡é‡å¯æ¥æ¢å¤æ­£å¸¸æ“ä½œã€‚













##### ä¼˜ç§€çš„é˜²å¾¡æ€§ç¼–ç¨‹:ABBA Deadlock

å¯¹äºè¿™ç§ç±»å‹çš„dead lockï¼Œé€šå¸¸æ˜¯å› ä¸ºæ¯ä¸ªçº¿ç¨‹ä¸åŸå­çš„ä¸Šå¤šä¸ªé”å¯¼è‡´çš„ï¼Œä¸€äº›çº¿ç¨‹è·å–äº†ç¬¬ä¸€ä¸ªé”ä¹‹åï¼Œè·å–ä¸äº†ç¬¬äºŒä¸ªé”ï¼Œå› æ­¤å¯¼è‡´æ­»é”ã€‚



è€ƒè™‘åˆ°ç³»ç»Ÿä¸­çš„é”éƒ½æ˜¯æœ‰é™çš„ï¼Œå› æ­¤æœ‰ä¸€ä¸ªé€šç”¨æ–¹æ³•ï¼Œå°±æ˜¯==ä¸¥æ ¼æŒ‰ç…§å›ºå®šçš„é¡ºåºè·å¾—æ‰€æœ‰çš„é”==



ä»¥å“²å­¦å®¶åƒé¥­ä¸ºä¾‹ï¼Œä¾‹å¦‚æœ‰ä¸‰ä¸ªå“²å­¦å®¶è·å–0ï¼Œ1ï¼Œ2ä¸‰ä¸ªå‰å­ï¼Œåº”è¯¥è®¾ç½®ä¸ºè·å–å‰å­çš„é¡ºåºä¸º012

å¯¹äºç¬¬ä¸‰ä¸ªå“²å­¦å®¶ï¼Œä»–éœ€è¦è·å¾—2å’Œ0ï¼Œä½†æ˜¯å®ƒè·å–é”çš„é¡ºåºåº”è¯¥è§„å®šä¸º`0,2`

è¿™ä¸ªåšæ³•çš„å¥½å¤„å°±æ˜¯ï¼Œ==å¦‚æœä¸€ä¸ªçº¿ç¨‹è·å–äº†ä¸€ä¸ªé”ï¼Œä¸€å®šæ²¡æœ‰å…¶ä»–çº¿ç¨‹å¯ä»¥è·å–è¿™ä¸ªé”é¡ºåºæ»åçš„é”ï¼Œä¹Ÿå°±ä¿è¯äº†å½“å‰çº¿ç¨‹ä¸€å®šèƒ½è·å–ä¹‹åçš„é”==

















#### Data Race(æ•°æ®ç«äº‰)

æ•°æ®ç«äº‰å‘ç”Ÿåœ¨ä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ®µå†…å­˜ï¼Œ**ä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™**ã€‚

![image-20240813142442233](./assets/image-20240813142442233.png)

å…·ä½“æ¥è¯´ï¼Œå¦‚æœä¸¤ä¸ªçº¿ç¨‹åœ¨åŒä¸€æ—¶åˆ»å¯¹åŒä¸€åœ°å€è‡³å°‘æœ‰ä¸€ä¸ªå†™æ“ä½œï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªçº¿ç¨‹å…¶å®å°±æ˜¯åœ¨èµ›è·‘ç«äº‰ï¼Œç¨‹åºçš„ç»“æœå°±æ˜¯ä¸ç¡®å®šçš„ï¼Œå–å†³äºäºŒè€…çš„èµ›è·‘ç»“æœï¼ˆå…ˆåé¡ºåºï¼‰ã€‚

Petersonç®—æ³•å°±æ˜¯æ˜¯åˆ©ç”¨äº†Data Raceï¼Œä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹æ ‡å¿—ä½ï¼Œè°å…ˆä¿®æ”¹è°å°±èƒ½å¤Ÿè·å–è®¿é—®æƒã€‚

ä½†æ˜¯ï¼ŒPetersonç®—æ³•éœ€è¦æ— æ•°çš„å†…å­˜å±éšœæ¥ä¿è¯å…¶æ­£ç¡®æ€§ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸‹æ–­è®ºäº†ï¼Œæ— é”å¹¶å‘å°±æ˜¯å†™ä¸å¯¹çš„

å› æ­¤ï¼Œdata raceçš„è§£å†³æ–¹æ³•å°±å¾ˆç®€å•ï¼Œ==ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«æ•°æ®==



å¸¸è§çš„ä¸Šäº†é”ä¹‹åä»ç„¶æœ‰æ•°æ®ç«äº‰çš„bugçš„æƒ…å†µå°±æ˜¯ä»¥ä¸‹ä¸¤ç§

```c++
//ä¸Šé”™é”
void thread1(){spin_lock(&lk1);sum++;spin_unlock(&lk1);}
void thread2(){spin_lock(&lk2);sum++;spin_unlock(&lk2);}
```

```c++
//å¯¹äºæŸä¸€ä¸ªåœ°æ–¹å¿˜è®°ä¸Šé”
void thread1(){spin_lock(&lk1);sum++;spin_unlock(&lk1);}
void thread2(){sum++;}
```











#### æ€»ç»“

å®ç°å¹¶å‘æ§åˆ¶çš„å·¥å…·ï¼š

* äº’æ–¥é”(lock/unlock)
* æ¡ä»¶å˜é‡(wait/signal,broadcast)ï¼ˆåŒæ­¥ï¼‰



å¿˜è®°ä¸Šé”å°±ä¼šè¿ååŸå­æ€§ï¼ˆAtomicity Violationï¼‰

å¿˜è®°åŒæ­¥å°±ä¼šè¿åé¡ºåºæ€§ï¼ˆOrder Violationï¼‰

ç»è¿‡ç»Ÿè®¡è¿™ä¸¤ä¸ªbugè¦†ç›–äº†97%çš„éæ­»é”å¹¶å‘bug



å…·ä½“æ¥è¯´





##### **AVï¼š"ABA"**

![image-20240813150027279](./assets/image-20240813150027279.png)

çº¿ç¨‹ä¸€åˆ¤æ–­å®Œä¹‹åï¼Œå…¶åˆ¤æ–­æ¡ä»¶å› ä¸ºçº¿ç¨‹äºŒçš„ä¿®æ”¹è€Œå¤±æ•ˆ



##### **AVï¼š"TOCTTOU": time of check to time of use**

ä¸Šé”ä¹Ÿä¸æ˜¯ä¸‡èƒ½çš„ï¼Œä¾‹å¦‚æ¶‰åŠåˆ°syscall

ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œè¿™æ˜¯ä¸€ä¸ªç»å…¸çš„ï¼Œéš¾ä»¥è§£å†³çš„TOCTTOUæ¼æ´ï¼ˆç”šè‡³åœ¨2023å¹´é»‘å®¢å¤§èµ›ä¸­è¢«ç”¨äºæ”»ç ´teslaï¼‰ã€‚

å…·ä½“æ¥è¯´ï¼Œæœ‰ä¸€ä¸ªå…·æœ‰rootæƒé™çš„è¿›ç¨‹ï¼Œç§°ä¸ºsendmail

* sendmailä»¥ç”¨æˆ·æ€è¿›ç¨‹å½¢å¼è¿è¡Œ

* sendmailé€šè¿‡ç³»ç»Ÿè°ƒç”¨ä¸æ“ä½œç³»ç»Ÿå†…æ ¸äº¤äº’æ¥æ‰§è¡Œä»»åŠ¡

* sendmailé¦–å…ˆè°ƒç”¨syscallæ£€æŸ¥ä¸€ä¸ªç¬¦å·é“¾æ¥çš„åˆæ³•æ€§ï¼Œç„¶åè°ƒç”¨syscallå‘è¿™ä¸ªé“¾æ¥çš„æ–‡ä»¶å†™å…¥ä¿¡æ¯

  > ç¬¦å·é“¾æ¥æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„æ–‡ä»¶ï¼Œå®ƒåŒ…å«äº†å¦ä¸€ä¸ªæ–‡ä»¶æˆ–è€…ç›®å½•çš„è·¯å¾„ï¼ŒæŒ‡å‘é‚£ä¸ªç›®æ ‡

ä½†æ˜¯ï¼Œåœ¨æ£€æŸ¥å®Œè¿”å›å†…æ ¸æ€æ—¶ï¼ŒAttackerå¡å‡†æ—¶æœºå¯ä»¥è°ƒç”¨syscallä¿®æ”¹ç›®æ ‡ç¬¦å·é“¾æ¥mailboxä¸­çš„æŒ‡å‘ï¼Œä¾‹å¦‚æŒ‡å‘etc/passwd

æ­¤æ—¶sendmailå°±ä¼šæ¥ç€æ‰§è¡ŒUseï¼Œå‘é”™è¯¯çš„æ–‡ä»¶å†™å…¥

æ¢å¥è¯è¯´ï¼ŒTOCTTOUæ¼æ´æ˜¯å› ä¸ºæ“ä½œç³»ç»Ÿè°ƒåº¦æœºåˆ¶å­˜åœ¨çš„ï¼Œè€ŒHackerèƒ½å¤Ÿå¾ˆå®¹æ˜“çš„å¡è¿™ä¸ªæ—¶é—´

![image-20240813150054757](./assets/image-20240813150054757.png)



è¿™ä¸ªåšæ³•æ˜¯ä¸èƒ½é€šè¿‡`LOCK-Check-Use-Unlock`æ¥è§£å†³çš„ï¼Œå› ä¸ºç”¨æˆ·æ€è¿›ç¨‹å†…lockåªèƒ½ä¿è¯è¿›ç¨‹å†…çš„èµ„æºä¸è¢«å…±äº«ï¼Œ è€Œè¿™é‡ŒSendmailæ˜¯é€šè¿‡è°ƒç”¨syscallæ¥åˆ¤æ–­å†…æ ¸æ€çš„èµ„æºï¼Œå› æ­¤lockå¹¶ä¸èƒ½ç®¡çš„ä¸Šã€‚









##### OV: "BA"

ä¸ç”¨condition variableå¯¼è‡´çš„é¡ºåºè¿åä¹Ÿæ˜¯å¾ˆå¸¸è§çš„é”™è¯¯

ä¾‹å¦‚å¦‚ä¸‹çš„ä¸€ä¸ªä¾‹å­ï¼Œåœ¨æœŸæœ›ä¸‹

* çº¿ç¨‹1é¦–å…ˆå¯åŠ¨ä¸€ä¸ªå¼‚æ­¥çš„ä»»åŠ¡(S1)
* ç„¶åè®¾ç½®æ ‡å¿—ä½io_pendingä¸ºTRUE(S2)
* ç„¶åè¿›å…¥while(S3)ï¼Œç›´åˆ°å¼‚æ­¥ä»»åŠ¡å®Œæˆï¼Œ(S4)io_pendingä¼šè¢«è®¾ç½®ä¸ºfalseï¼Œthread1ç»§ç»­å·¥ä½œ

![image-20240813154505486](./assets/image-20240813154505486.png)

ç°åœ¨é—®é¢˜å‡ºç°äº†ï¼ŒThread2çš„ä»»åŠ¡å¯èƒ½è¿‡æ—©ç»“æŸï¼Œæˆ–è€…å› ä¸ºè°ƒåº¦æœºåˆ¶ï¼ŒS4åœ¨S2ä¹‹å‰æ‰§è¡Œäº†

è¿™å°±æ„å‘³ç€æ­»å¾ªç¯ã€‚è¿™é‡Œå› ä¸ºæ²¡æœ‰ä½¿ç”¨é”æ¥ä¿è¯S4å¯¹io_pendingçš„ä¿®æ”¹ä¸€å®šåœ¨S2ä¹‹åï¼Œæ‰ä¼šå¯¼è‡´åŒæ­¥å¤±è´¥

ä¸€ä¸ªå®ç°å°±å¦‚ä¸‹

```c++
int ReadWriteProc(â€¦) {
    // PBReadAsyncå¿…é¡»åœ¨é”å†…ï¼Œå› ä¸ºå®ƒä¸io-pendingæœ‰å…³ç³»ï¼Œæ”¾åœ¨é”å¤–å¹¶ä¸èƒ½ä¿è¯é¡ºåº
    pthread_mutex_lock(&lock);
    S1: PBReadAsync(&p);
    S2: io_pending = TRUE;// è¿™é‡Œä¿è¯äº†å½“è°ƒç”¨å¼‚æ­¥ä»»åŠ¡æ—¶ï¼Œå°±ç®—æ­¤æ—¶å¼‚æ­¥ä»»åŠ¡å·²ç»å®Œæˆï¼Œå®ƒä¹Ÿä¸èƒ½è®¿é—®åˆ°io_pending
    pthread_mutex_unlock(&lock);
    
    pthread_mutex_lock(&lock);
    while (io_pending) {
        // ä½¿ç”¨cvæ¥è§£é”lockï¼Œä¸ç„¶ä¼šä¸€ç›´å ç”¨é”å¯¼è‡´æ­»é”
        pthread_cond_wait(&cond, &lock);
    }
    pt  hread_mutex_unlock(&lock);
    â€¦
}

void DoneWaiting(â€¦) {
    pthread_mutex_lock(&lock);
    S4: io_pending = FALSE;
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&lock);
}
```

 











### é˜²å¾¡æ€§ç¼–ç¨‹é€šæ³•ï¼šè¿è¡Œæ—¶æ£€æŸ¥

å‰é¢çš„åšæ³•åœ¨å°å‹é¡¹ç›®ä¸­è¿˜å¤Ÿç”¨ï¼Œä¸€æ—¦é”å’Œå¹¶å‘æ¡ä»¶ä¸èƒ½æ»¡è¶³ï¼Œæ›´åŠ éš¾ä»¥æ’æŸ¥é”™è¯¯

äº‹å®ä¸Šï¼Œlock orderingæ— æ³•å½»åº•é¿å…æ­»é”ï¼Œå¹¶å‘é‚£ä¹ˆå¤æ‚ï¼Œç¨‹åºå‘˜å“ªèƒ½å……åˆ†æµ‹è¯•å•Š

è¿™ä¸ªæ—¶å€™ï¼Œå°±éœ€è¦å€ŸåŠ©å·¥å…·äº†

#### Lockdepè§„çº¦(Specification)

è¿™ä¸ªåšæ³•çš„æƒ³æ³•æ˜¯ä¸ºæ¯ä¸€ä¸ªé”ç¡®å®šä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ï¼Œé€šå¸¸æ˜¯ç¡®å®šä¸€ä¸ªå”¯ä¸€çš„`allocate site`

ç„¶åè·Ÿè¸ªåŒä¸€ä¸ªallocate siteçš„é”å­˜åœ¨å…¨å±€çš„å”¯ä¸€çš„ä¸Šé”é¡ºåº

```c++
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

typedef struct lock {
  int locked;
  const char *site;
} lock_t;

#define STRINGIFY(s) #s
#define TOSTRING(s)  STRINGIFY(s)
#define LOCK_INIT() \
  ( (lock_t) { .locked = 0, .site = __FILE__ ":" TOSTRING(__LINE__), } )

lock_t lk1 = LOCK_INIT();
lock_t lk2 = LOCK_INIT();

void lock(lock_t *lk) {
  printf("LOCK   %s\n", lk->site);
}

void unlock(lock_t *lk) {
  printf("UNLOCK %s\n", lk->site);
}

struct some_object {
  lock_t lock;
  int data;
};

void object_init(struct some_object *obj) {
  obj->lock = LOCK_INIT();
}

int main() {
  lock(&lk1);
  lock(&lk2);
  unlock(&lk1);
  unlock(&lk2);

  struct some_object *obj = malloc(sizeof(struct some_object));
  assert(obj);
  object_init(obj);
  lock(&obj->lock);

  lock(&lk2);
  lock(&lk1);
}
```

ä¸Šé¢çš„ç¨‹åºæ¨¡æ‹Ÿäº†è¯¥å¦‚ä½•è®¾è®¡lockå’Œunlockï¼Œå…·ä½“æ¥è¯´å°±æ˜¯ä¸ºlock_tæ·»åŠ ä¿¡æ¯è¡Œï¼Œä½¿ç”¨lock_initåœ¨æ¯æ¬¡ç”³è¯·æ–°lockæ—¶ç”¨ç”³è¯·æ—¶çš„è¡Œæ•°ä½œä¸ºè¯¥lockçš„å”¯ä¸€æ ‡è¯†ç¬¦

é¢å¤–çš„ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æ·»åŠ çº¿ç¨‹id(data)ï¼ŒåŠ ä»¥æ ‡è¯†ï¼Œæ­¤æ—¶æˆ‘ä»¬å°±å¯ä»¥è·å¾—æ‰€æœ‰ä¸Šé”çš„å…ˆåé¡ºåº

![image-20240814101721880](./assets/image-20240814101721880.png)

æ³¨æ„ï¼Œå³ä½¿æ˜¯å¤šçº¿ç¨‹ï¼Œé”ä»ç„¶æ˜¯å”¯ä¸€çš„ã€‚å‡è®¾å­˜åœ¨æ‰€æœ‰é”çš„ä¸€ä¸ªå…¨å±€é¡ºåºï¼Œé‚£ä¹ˆæ ¹æ®æ‰“å°å‡ºçš„lockä¿¡æ¯å°±èƒ½å‘ç°lockèŠ‚ç‚¹å½¢æˆçš„å›¾æ˜¯æ— ç¯çš„

ä»¥å…¨å±€é”X,Y,Zä¸ºä¾‹ï¼Œæˆ‘ä»¬è®¾è®¡å…¨å±€é¡ºåºä¸º`X->Y->Z`

å…·ä½“è¾“å‡ºæ—¶è¾“å‡ºå¦‚ä¸‹

`LOCK(x)`		å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X]`

`LOCK(Y)`		å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X,Y]`

`LOCK(Z)`		å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X,Y,Z]`

`UNLOCK(Z)`		å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X,Y]`

`UNLOCK(Y)`		å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X]`

`LOCK(Z)`			å¯¹åº”çš„é”é˜Ÿåˆ—ä¸º`[X,Z]`

æ­¤æ—¶å¯ä»¥å‘ç°è¿™ä¹ˆå‡ ä¸ªé¡ºåºæ˜¯å­˜åœ¨çš„

`X->Y`,`X->Z`,`Y->Z`

æˆ‘ä»¬ç”¨å…¶ç”»å‡ºä¸€å¼ æœ‰å‘å›¾ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æœ‰ç¯å³å¯



> ä¸¥è°¨çš„è¯´ï¼Œè®°å½•æ‰€æœ‰è§‚å¯Ÿåˆ°çš„ä¸Šé”é¡ºåºï¼Œä¾‹å¦‚
> $$
> [x,y,z]\Rightarrow x\rightarrow y, x\rightarrow z,y\rightarrow z
> $$
> è¿™è¡¨ç¤ºçº¿ç¨‹å…ˆåè·å–äº†é” x, y å’Œ zï¼Œå¹¶ä¸”åœ¨è·å– y ä¹‹å‰å·²ç»è·å–äº† xï¼Œåœ¨è·å– z ä¹‹å‰å·²ç»è·å–äº† x å’Œ yã€‚
>
> ä¸ºäº†æ£€æµ‹æ˜¯å¦å­˜åœ¨æ½œåœ¨çš„æ­»é”ï¼Œ`lockdep` ä¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨ä»¥ä¸‹å½¢å¼çš„å¾ªç¯ä¾èµ–ï¼š
> $$
> x\leadsto y\and y\leadsto x
> $$
> æ­¤å¤„$\rightarrow$ä»£è¡¨ç›´æ¥çš„ä¸Šé”é¡ºåºï¼Œ$\leadsto$ä»£è¡¨happens beforeå…³ç³»ã€‚ä¾‹å¦‚$x\rightarrow y$å’Œ$y\rightarrow z$å¯ä»¥æ¨å¯¼å‡º$x\leadsto z$
>
> ä¹Ÿå°±æ˜¯ï¼Œè§‚å¯Ÿæ‰€æœ‰çš„ç›´æ¥ä¸Šé”é¡ºåºï¼Œè§‚æµ‹æ˜¯å¦å­˜åœ¨æˆç¯çš„x happens before yä¸y happens before xåŒæ—¶å­˜åœ¨



å¯èƒ½å­˜åœ¨æŠ¥é”™ä½†æ˜¯æ²¡æœ‰æ­»é”ï¼ˆè¿™é€šå¸¸æ˜¯æ²¡æœ‰æ»¡è¶³å…¨å±€æ‹¥æœ‰ä¸€ä¸ªç»å¯¹çš„é¡ºåºï¼‰ï¼Œä½†æ˜¯æ²¡æœ‰æŠ¥é”™ä¸€å®šæ²¡æœ‰æ­»é”ã€‚





> åœ¨linuxå†…æ ¸ä¸­ï¼ŒLockdepå·²ç»æˆä¸ºäº†é»˜è®¤å·¥å…·ã€‚ä¸€ä¸ªç®€çŸ­çš„ç¿»è¯‘åœ¨ä¸‹é¢æä¾›
>
> > https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt
>
> LOCKæ˜¯æ“ä½œç³»ç»Ÿä¸­å¿…ä¸å¯å°‘çš„é‚ªæ¶;å¦‚æœæ²¡æœ‰åšå®çš„é”å®šåˆ¶åº¦ï¼Œåœ¨å°è¯•è®¿é—®ç›¸åŒçš„èµ„æºæ—¶ï¼Œç³»ç»Ÿçš„ä¸åŒéƒ¨åˆ†å°†å‘ç”Ÿå†²çªï¼Œä»è€Œå¯¼è‡´æ•°æ®æŸåå’Œæ™®éçš„æ··ä¹±ã€‚ä½†æ˜¯é”å®šæœ‰å…¶è‡ªèº«çš„å±é™©;ç²—å¿ƒå®æ–½çš„é”å®šå¯èƒ½ä¼šå¯¼è‡´ç³»ç»Ÿæ­»é”ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œè€ƒè™‘ä¸¤ä¸ªé” ğ¿1 å’Œ ğ¿2 ã€‚ä»»ä½•éœ€è¦ä¸¤æŠŠé”çš„ä»£ç éƒ½å¿…é¡»æ³¨æ„ä»¥æ­£ç¡®çš„é¡ºåºè·å–é”ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°åœ¨ ä¹‹å‰ ğ¿2 è·å–ï¼Œ ğ¿1 ä½†å¦ä¸€ä¸ªå‡½æ•°ä»¥ç›¸åçš„é¡ºåºè·å–å®ƒä»¬ï¼Œæœ€ç»ˆç³»ç»Ÿå°†å‘ç°è‡ªå·±å¤„äºä¸€ç§æƒ…å†µï¼Œå³æ¯ä¸ªå‡½æ•°éƒ½è·å¾—äº†ä¸€ä¸ªé”ï¼Œå¹¶åœ¨ç­‰å¾…å¦ä¸€ä¸ªé”æ—¶è¢«é˜»å¡ - è¿™å°±æ˜¯æ­»é”ã€‚
>
> åƒä¸Šè¿°è¿™æ ·çš„ç«äº‰æ¡ä»¶å¯èƒ½æ˜¯ç™¾ä¸‡åˆ†ä¹‹ä¸€çš„å¯èƒ½æ€§ï¼Œä½†æ˜¯ï¼Œå¯¹äºè®¡ç®—æœºæ¥è¯´ï¼Œæ‰§è¡Œä¸€ç™¾ä¸‡æ¬¡ä»£ç è·¯å¾„å¹¶ä¸éœ€è¦å¤ªé•¿æ—¶é—´ã€‚è¿Ÿæ—©ï¼ŒåŒ…å«æ­¤ç±»é”™è¯¯çš„ç³»ç»Ÿä¼šé”å®šï¼Œè®©ç”¨æˆ·æƒ³çŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œå†…æ ¸å¼€å‘äººå‘˜å°è¯•å®šä¹‰è·å–é”çš„é¡ºåºè§„åˆ™ã€‚ä½†æ˜¯ï¼Œåœ¨ä¸€ä¸ªæ‹¥æœ‰æ•°åƒä¸ªé”çš„ç³»ç»Ÿä¸­ï¼Œå®šä¹‰ä¸€å¥—å…¨é¢çš„è§„åˆ™å……å…¶é‡æ˜¯å…·æœ‰æŒ‘æˆ˜æ€§çš„ï¼Œè€Œæ‰§è¡Œå®ƒä»¬ç”šè‡³æ›´åŠ å›°éš¾ã€‚å› æ­¤ï¼Œé”å®šé”™è¯¯ä¼šæ‚„æ‚„æ¸—é€åˆ°å†…æ ¸ä¸­ï¼Œæ½œä¼åˆ°ä¸€äº›çœŸæ­£ä¸æ–¹ä¾¿çš„æ—¶å€™ï¼Œæœ€ç»ˆè®©ä¸€äº›æ¯«æ— æˆ’å¿ƒçš„ç”¨æˆ·æ„Ÿåˆ°æƒŠè®¶ã€‚
>
> éšç€æ—¶é—´çš„æµé€ï¼Œå†…æ ¸å¼€å‘äººå‘˜è¶Šæ¥è¶Šå¤šåœ°ä½¿ç”¨è‡ªåŠ¨åŒ–ä»£ç åˆ†æå·¥å…·ï¼Œå› ä¸ºè¿™äº›å·¥å…·å¯ç”¨ã€‚æœ€æ–°çš„æ˜¯[é”éªŒè¯å™¨è¡¥ä¸çš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬](http://lwn.net/Articles/185605/)ï¼Œç”± Ingo Molnar ï¼ˆè¿™ä½ä¹Ÿæ˜¯ Complete-Fair-Scheduler çš„ä½œè€…ï¼‰ å‘å¸ƒã€‚è¿™ä¸ªè¡¥ä¸ï¼ˆå®é™…ä¸Šæ˜¯ä¸€ä¸ªç”±61ä¸ªéƒ¨åˆ†ç»„æˆçš„è¡¥ä¸é›†ï¼‰ä¸ºå†…æ ¸æ·»åŠ äº†ä¸€ä¸ªå¤æ‚çš„åŸºç¡€è®¾æ–½ï¼Œç„¶åå¯ä»¥ç”¨æ¥è¯æ˜åœ¨æ­£åœ¨è¿è¡Œçš„ç³»ç»Ÿä¸­è§‚å¯Ÿåˆ°çš„ä»»ä½•é”å®šæ¨¡å¼éƒ½ä¸ä¼šä½¿å†…æ ¸æ­»é”ã€‚
>
> ä¸ºæ­¤ï¼Œé”éªŒè¯å™¨å¿…é¡»è·Ÿè¸ªå†…æ ¸ä¸­çš„çœŸå®é”å®šæ¨¡å¼ã€‚ç„¶è€Œï¼Œè·Ÿè¸ªæ¯ä¸ªå•ç‹¬çš„é”æ˜¯æ²¡æœ‰æ„ä¹‰çš„ - æœ‰æ•°åƒä¸ªé”ï¼Œä½†å†…æ ¸ä»¥å®Œå…¨ç›¸åŒçš„æ–¹å¼å¤„ç†å…¶ä¸­è®¸å¤šé”ã€‚ä¾‹å¦‚ï¼Œæ¯ä¸ª inode ç»“æ„éƒ½åŒ…å«ä¸€ä¸ªæ—‹è½¬é”ï¼Œæ¯ä¸ªæ–‡ä»¶ç»“æ„ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸€æ—¦å†…æ ¸äº†è§£äº†å¦‚ä½•å¤„ç†ä¸€ä¸ª inode ç»“æ„çš„é”å®šï¼Œå®ƒå°±çŸ¥é“å°†å¦‚ä½•å¤„ç†æ¯ä¸ª inode ç»“æ„çš„é”å®šã€‚å› æ­¤ï¼Œä¸çŸ¥ä½•æ•…ï¼Œé”éªŒè¯å™¨éœ€è¦èƒ½å¤Ÿè¯†åˆ«åŒ…å«åœ¨ï¼ˆä¾‹å¦‚ï¼‰inode ç»“æ„ä¸­çš„æ‰€æœ‰è‡ªæ—‹é”æœ¬è´¨ä¸Šéƒ½æ˜¯ç›¸åŒçš„ã€‚
>
> ä¸ºæ­¤ï¼Œç³»ç»Ÿä¸­çš„æ¯ä¸ªé”ï¼ˆç°åœ¨åŒ…æ‹¬ rwlocks å’Œäº’æ–¥é”ï¼‰éƒ½è¢«åˆ†é…äº†ä¸€ä¸ªç‰¹å®šçš„é”®ã€‚å¯¹äºé™æ€å£°æ˜çš„é”ï¼ˆä¾‹å¦‚ï¼Œfiles_lockï¼Œç”¨äºä¿æŠ¤æ‰“å¼€çš„æ–‡ä»¶åˆ—è¡¨ï¼‰ï¼Œé”çš„åœ°å€ç”¨ä½œå¯†é’¥ã€‚ä½†æ˜¯ï¼ŒåŠ¨æ€åˆ†é…çš„é”ï¼ˆå¦‚åµŒå…¥ç»“æ„ä¸­çš„å¤§å¤šæ•°é”ï¼‰æ— æ³•ä»¥è¿™ç§æ–¹å¼è¿›è¡Œè·Ÿè¸ª;å¯èƒ½æ¶‰åŠå¤§é‡çš„åœ°å€ï¼Œå¹¶ä¸”åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œä¸ç‰¹å®šç»“æ„å­—æ®µå…³è”çš„æ‰€æœ‰é”éƒ½åº”æ˜ å°„åˆ°å•ä¸ªé”®ã€‚è¿™æ˜¯é€šè¿‡è®¤è¯†åˆ°è¿™äº›é”åœ¨è¿è¡Œæ—¶åˆå§‹åŒ–æ¥å®ç°çš„ï¼Œå› æ­¤ï¼Œä¾‹å¦‚ï¼Œ`spin_lock_init()`è¢«é‡æ–°å®šä¹‰ä¸ºï¼š
>
> ```c++
> # define spin_lock_init(lock) \
> do { \
>   static struct lockdep_type_key __key; \
>   __spin_lock_init((lock), #lock, &__key); \
> } while (0)
> ```
>
> å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªé”åˆå§‹åŒ–ï¼Œæ­¤ä»£ç éƒ½ä¼šåˆ›å»ºä¸€ä¸ªé™æ€å˜é‡ ï¼ˆ`__key`ï¼‰ï¼Œå¹¶å°†å…¶åœ°å€ç”¨ä½œæ ‡è¯†é”ç±»å‹çš„é”®ã€‚ç”±äºä»»ä½•ç‰¹å®šç±»å‹çš„é”éƒ½å€¾å‘äºåœ¨ä¸€ä¸ªåœ°æ–¹åˆå§‹åŒ–ï¼Œå› æ­¤æ­¤æŠ€å·§å°†ç›¸åŒçš„å¯†é’¥ä¸ç›¸åŒç±»å‹çš„æ¯ä¸ªé”ç›¸å…³è”ã€‚
>
> æ¥ä¸‹æ¥ï¼ŒéªŒè¯å™¨ä»£ç æ‹¦æˆªæ¯ä¸ªé”å®šæ“ä½œå¹¶æ‰§è¡Œä¸€äº›æµ‹è¯•ï¼š
>
> * è¯¥ä»£ç æŸ¥çœ‹åœ¨ä½¿ç”¨æ–°é”æ—¶å·²ç»æŒæœ‰çš„æ‰€æœ‰å…¶ä»–é”ã€‚å¯¹äºæ‰€æœ‰è¿™äº›é”ï¼ŒéªŒè¯è€…ä¼šæŸ¥æ‰¾è¿‡å»å‡ºç°çš„æƒ…å†µï¼Œå…¶ä¸­ä»»ä½•ä¸€ä¸ªæ˜¯åœ¨æ–°é”*ä¹‹å*è¢«å¸¦èµ°çš„ã€‚å¦‚æœå‘ç°ä»»ä½•æ­¤ç±»æƒ…å†µï¼Œåˆ™è¡¨æ˜è¿åäº†é”å®šé¡ºåºè§„åˆ™ï¼Œå¹¶æœ€ç»ˆå‡ºç°æ­»é”ã€‚
> * ç»´æŠ¤äº†ä¸€ç»„å½“å‰æŒæœ‰çš„é”ï¼Œå› æ­¤é‡Šæ”¾çš„ä»»ä½•é”éƒ½åº”ä½äºå †æ ˆçš„é¡¶éƒ¨;å…¶ä»–ä»»ä½•äº‹æƒ…éƒ½æ„å‘³ç€æ­£åœ¨å‘ç”Ÿä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ã€‚
> * å¯ç”¨ä¸­æ–­æ—¶ï¼Œç¡¬ä»¶ä¸­æ–­å¤„ç†ç¨‹åºè·å–çš„ä»»ä½•è‡ªæ—‹é”éƒ½ä¸èƒ½è¢«ä¿ç•™ã€‚è€ƒè™‘ä¸€ä¸‹å½“è¿åæ­¤è§„åˆ™æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­è¿è¡Œçš„å†…æ ¸å‡½æ•°è·å–ç‰¹å®šçš„é”ã€‚ä¸­æ–­åˆ°è¾¾ï¼Œå…³è”çš„ä¸­æ–­å¤„ç†ç¨‹åºåœ¨åŒä¸€ CPU ä¸Šè¿è¡Œ;ç„¶åï¼Œè¯¥å¤„ç†ç¨‹åºå°è¯•è·å–ç›¸åŒçš„é”ã€‚ç”±äºé”ä¸å¯ç”¨ï¼Œå¤„ç†ç¨‹åºå°†æ—‹è½¬ï¼Œç­‰å¾…é”é‡Šæ”¾ã€‚ä½†æ˜¯ï¼Œå¤„ç†ç¨‹åºå·²ç»æŠ¢å äº†å”¯ä¸€å¯ä»¥é‡Šæ”¾è¯¥é”çš„ä»£ç ï¼Œå› æ­¤å®ƒå°†æ°¸è¿œæ—‹è½¬ï¼Œä½¿è¯¥å¤„ç†å™¨æ­»é”ã€‚
>
> ä¸ºäº†æ•è·è¿™ç§ç±»å‹çš„é—®é¢˜ï¼ŒéªŒè¯å™¨ä¸ºå®ƒçŸ¥é“çš„æ¯ä¸ªé”è®°å½•ä¸¤ä¸ªä¿¡æ¯ä½ï¼šï¼ˆ1ï¼‰é”æ˜¯å¦æ›¾ç»åœ¨ç¡¬ä»¶ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­è¢«è·å–è¿‡ï¼Œä»¥åŠï¼ˆ2ï¼‰é”æ˜¯å¦æ›¾ç»è¢«åœ¨å¯ç”¨ç¡¬ä»¶ä¸­æ–­çš„æƒ…å†µä¸‹è¿è¡Œçš„ä»£ç æŒæœ‰ã€‚å¦‚æœä¸¤ä¸ªä½éƒ½è®¾ç½®äº†ï¼Œåˆ™è¡¨ç¤ºé”™è¯¯åœ°ä½¿ç”¨äº†é”ï¼Œå¹¶å‘å‡ºé”™è¯¯ä¿¡å·ã€‚
>
> * Similar tests are made for software interrupts, which present the same problems.
>
> ä¸­æ–­æµ‹è¯•ç›¸å¯¹ç®€å•ï¼Œæ¯ä¸ªé”åªéœ€è¦å››ä½ä¿¡æ¯ï¼ˆå°½ç®¡å¯¹äº rwlocksï¼Œæƒ…å†µç¨å¾®å¤æ‚ä¸€äº›ï¼‰ã€‚ä½†æ˜¯ordering testéœ€è¦æ›´å¤šçš„å·¥ä½œã€‚å¯¹äºæ¯ä¸ªå·²çŸ¥çš„é”é”®ï¼ŒéªŒè¯å™¨ç»´æŠ¤ä¸¤ä¸ªåˆ—è¡¨ã€‚å…¶ä¸­ä¸€ä¸ªåŒ…å«åœ¨è·å–æ„Ÿå…´è¶£çš„é”ï¼ˆç§°ä¸º *L*ï¼‰æ—¶æ›¾ç»æŒæœ‰çš„æ‰€æœ‰é”;å› æ­¤ï¼Œå®ƒåŒ…å«äº†å¯èƒ½åœ¨ *L* ä¹‹å‰è·å¾—çš„æ‰€æœ‰é”çš„é’¥åŒ™ã€‚å¦ä¸€ä¸ªåˆ—è¡¨ï¼ˆâ€œä¹‹åâ€åˆ—è¡¨ï¼‰åŒ…å«æŒæœ‰ *L* æ—¶è·å¾—çš„æ‰€æœ‰é”ã€‚å› æ­¤ï¼Œè¿™ä¸¤ä¸ªåˆ—è¡¨æ¦‚æ‹¬äº†å¦‚ä½•ç›¸å¯¹äº *L* è·å–å…¶ä»–é”çš„æ­£ç¡®é¡ºåºã€‚
>
> æ¯å½“è·å– *L* æ—¶ï¼ŒéªŒè¯è€…éƒ½ä¼šæ£€æŸ¥ä¸ *L* å…³è”çš„â€œä¹‹åâ€åˆ—è¡¨ä¸Šæ˜¯å¦å·²ç»æŒæœ‰ä»»ä½•é”ã€‚å®ƒä¸åº”è¯¥æ‰¾åˆ°ä»»ä½•é”ï¼Œå› ä¸ºâ€œä¹‹åâ€åˆ—è¡¨ä¸Šçš„æ‰€æœ‰é”éƒ½åº”è¯¥åœ¨è·å– *L* ä¹‹åè·å–ã€‚å¦‚æœå®ƒæ‰¾åˆ°ä¸€ä¸ªä¸åº”è¯¥è¢«æŒæœ‰çš„é”ï¼Œå°±ä¼šå‘å‡ºé”™è¯¯ä¿¡å·ã€‚éªŒè¯å™¨ä»£ç è¿˜è·å– *L* çš„ â€œafterâ€ åˆ—è¡¨ï¼Œå°†å…¶ä¸å½“å‰æŒæœ‰çš„é”çš„ â€œbeforeâ€ åˆ—è¡¨è¿æ¥èµ·æ¥ï¼Œå¹¶è¯´æœè‡ªå·±è¯¥é“¾ä¸­çš„ä»»ä½•åœ°æ–¹éƒ½ä¸å­˜åœ¨æ’åºæˆ–ä¸­æ–­è¿è§„ã€‚å¦‚æœæ‰€æœ‰æµ‹è¯•éƒ½é€šè¿‡ï¼ŒéªŒè¯å™¨å°†æ›´æ–°å„ç§â€œä¹‹å‰â€å’Œâ€œä¹‹åâ€åˆ—è¡¨ï¼Œå†…æ ¸å°†ç»§ç»­è¿è¡Œã€‚
>
> æ¯‹åº¸ç½®ç–‘ï¼Œæ‰€æœ‰è¿™äº›æ£€æŸ¥éƒ½ä¼šå¸¦æ¥ä¸€å®šçš„å¼€é”€;è¿™ä¸æ˜¯äººä»¬æƒ³è¦åœ¨ç”Ÿäº§å†…æ ¸ä¸Šå¯ç”¨çš„ä¸œè¥¿ã€‚ç„¶è€Œï¼Œå®ƒå¹¶ä¸åƒäººä»¬æƒ³è±¡çš„é‚£ä¹ˆç³Ÿç³•ã€‚å½“å†…æ ¸æ‰§è¡Œå…¶æ“ä½œæ—¶ï¼Œé”éªŒè¯å™¨ä¼šç»´æŠ¤å…¶å½“å‰æŒæœ‰çš„é”å †æ ˆã€‚å®ƒè¿˜ä»è¯¥ç³»åˆ—é”ç”Ÿæˆä¸€ä¸ª 64 ä½å“ˆå¸Œå€¼ã€‚æ¯å½“éªŒè¯ç‰¹å®šçš„é”ç»„åˆæ—¶ï¼Œå…³è”çš„å“ˆå¸Œå€¼éƒ½ä¼šå­˜å‚¨åœ¨è¡¨ä¸­ã€‚ä¸‹æ¬¡é‡åˆ°è¯¥é”å®šåºåˆ—æ—¶ï¼Œä»£ç å¯ä»¥åœ¨è¡¨ä¸­æ‰¾åˆ°å…³è”çš„å“ˆå¸Œå€¼ï¼Œå¹¶çŸ¥é“å·²ç»æ‰§è¡Œäº†æ£€æŸ¥ã€‚è¿™ç§æ•£åˆ—å¤§å¤§åŠ å¿«äº†è¯¥è¿‡ç¨‹ã€‚
>
> å½“ç„¶ï¼Œæ­£å¦‚éªŒè¯è€…æ‰€ç†è§£çš„é‚£æ ·ï¼Œé”å®šè§„åˆ™æœ‰å¾ˆå¤šä¾‹å¤–ã€‚å› æ­¤ï¼ŒéªŒè¯å™¨è¡¥ä¸é›†çš„å¾ˆå¤§ä¸€éƒ¨åˆ†æ—¨åœ¨æ¶ˆé™¤é”™è¯¯çš„é”™è¯¯æŠ¥å‘Šã€‚ä¾‹å¦‚ï¼Œå¦‚æœåŒæ—¶æŒæœ‰å¤šä¸ªå…·æœ‰ç›¸åŒå¯†é’¥çš„é”ï¼ŒéªŒè¯è€…é€šå¸¸ä¼šæŠ±æ€¨ - è¿™æ ·åšå°±æ˜¯è¦æ±‚æ­»é”ã€‚ä½†æ˜¯ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¿™ç§æ¨¡å¼æ˜¯åˆæ³•çš„ã€‚ä¾‹å¦‚ï¼Œå—å­ç³»ç»Ÿé€šå¸¸ä¼šé”å®šå—è®¾å¤‡ï¼Œç„¶åé”å®šè¯¥è®¾å¤‡ä¸­çš„åˆ†åŒºã€‚ç”±äºåˆ†åŒºçœ‹èµ·æ¥ä¹Ÿåƒä¸€ä¸ªå—è®¾å¤‡ï¼Œå› æ­¤éªŒè¯å™¨ä¼šå‘å‡ºé”™è¯¯ä¿¡å·ã€‚ä¸ºäº†é˜²æ­¢è¿™ç§æƒ…å†µå‘ç”Ÿï¼ŒéªŒè¯å™¨å®ç°äº†é”â€œå­ç±»å‹â€çš„æ¦‚å¿µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåˆ†åŒºè®¾å¤‡ä¸Šçš„é”å¯ä»¥ç”¨ä¸åŒçš„å­ç±»å‹è¿›è¡Œæ ‡è®°ï¼Œä»è€Œå¯ä»¥æ­£ç¡®éªŒè¯å…¶ä½¿ç”¨æƒ…å†µã€‚è¿™ç§æ ‡è®°æ˜¯é€šè¿‡ä½¿ç”¨æ–°ç‰ˆæœ¬çš„é”å®šå‡½æ•°ï¼ˆä¾‹å¦‚spin_lock_nestedï¼ˆï¼‰å®Œæˆçš„ï¼Œè¯¥å‡½æ•°é‡‡ç”¨å­ç±»å‹å‚æ•°ã€‚
>
> é”éªŒè¯å™¨å·²æ·»åŠ åˆ° [2.6.17-rc5-mm1](http://lwn.net/Articles/185572/) ä¸­ï¼Œå› æ­¤æ„Ÿå…´è¶£çš„äººå¯ä»¥ä½¿ç”¨å®ƒã€‚ç„¶è€Œï¼Œç­‰å¾…å¦ä¸€ä¸ª -mm å‘å¸ƒå¯èƒ½ä¸æ˜¯ä¸€ä¸ªåä¸»æ„;ä»é‚£ä»¥åï¼Œå·²ç»å‘å¸ƒäº†ä¸€ç³»åˆ—ç›¸å½“é•¿çš„éªŒè¯å™¨ä¿®å¤ç¨‹åºã€‚
>
> æ‰€æœ‰è¿™ä¸€åˆ‡èƒŒåçš„å…³é”®ç‚¹æ˜¯ï¼Œ**æ— éœ€å®é™…é”å®šå†…æ ¸ï¼Œå°±å¯ä»¥æ‰¾åˆ°æ­»é”æƒ…å†µã€‚**é€šè¿‡è§‚å¯Ÿè·å–é”çš„åºåˆ—ï¼ŒéªŒè¯è€…å¯ä»¥æ¨æ–­å‡ºæ›´å¤§çš„å¯èƒ½åºåˆ—é›†ã€‚å› æ­¤ï¼Œå³ä½¿ç‰¹å®šçš„æ­»é”å¯èƒ½åªæ˜¯ç”±äºå¥‡æ€ªçš„ç¡¬ä»¶ã€ä¸€ç»„ç½•è§çš„é…ç½®é€‰é¡¹ã€220V ç”µæºã€ç•¥å¾®ä¸ç¨³å®šçš„è§†é¢‘æ§åˆ¶å™¨ã€ç«æ˜Ÿç©¿è¿‡ç‹®å­åº§ã€æ—§ç‰ˆæœ¬çš„ gccã€ä¸€ä¸ªä¸¥é‡ç»™ç³»ç»Ÿå¸¦æ¥å‹åŠ›çš„åº”ç”¨ç¨‹åºï¼ˆæ¯”å¦‚è¯´ yumï¼‰ä»¥åŠç‰¹åˆ«ç³Ÿç³•çš„ Darl McBride å‘å‹æ—¥é€ æˆçš„ä¸å¹¸æ—¶åºé€ æˆçš„ï¼Œ éªŒè¯è€…å¾ˆæœ‰å¯èƒ½æŠ“ä½å®ƒã€‚å› æ­¤ï¼Œæ­¤ä»£ç åº”å¯¼è‡´ä»å†…æ ¸ä»£ç åº“ä¸­æ¶ˆé™¤ä¸€æ•´ç±»é”™è¯¯;è¿™åªèƒ½æ˜¯ä¸€ä»¶å¥½äº‹ã€‚







#### ThreadSanitizer(æ•°æ®ç«äº‰æ£€æŸ¥)

 <img src="./assets/image-20240814112317569.png" alt="image-20240814112317569" style="zoom:50%;" />



å¦‚å›¾ï¼Œæˆ‘ä»¬å‡è®¾éå†`a`åœ¨ä¸‰ä¸ªåœ°æ–¹è¢«ä¿®æ”¹ï¼Œå¹¶ä¸”èƒ½å¤Ÿæœ‰å¦‚ä¸‹å®šè®º

* åŒä¸€ä¸ªé”ä¹‹é—´å¿…å®šæœ‰å…ˆåé¡ºåº
* åŒä¸€ä¸ªçº¿ç¨‹çš„åŒä¸€ä¸ªå˜é‡å¿…å®šæœ‰å…ˆåé¡ºåº
  * åŒä¸€ä¸ªå˜é‡æœ¬èº«å°±æœ‰è®¡ç®—çš„å…ˆåé¡ºåºï¼Œå³ä½¿æ˜¯ä¹±åºæ‰§è¡Œã€‚è¿™æ˜¯ç”±CPUå†…éƒ¨çš„æŒ‡ä»¤æ± dependency graphå†³å®šçš„ã€‚

é‚£ä¹ˆå°±å¯ä»¥é€šè¿‡ä¼ é€’é—­åŒ…ç”»å‡ºå…¶ä¾èµ–å…³ç³»ã€‚

æ­¤å¤„çš„ä¾èµ–å…³ç³»å°±æ˜¯$a_1 \rightarrow a_2$,$a_1\rightarrow a_3$â€‹

å¯¹äºåŒä¸€ä¸ªå˜é‡ï¼Œå¦‚æœå…¶å­˜åœ¨ä¸€ä¸ªèŠ‚ç‚¹ä¸èƒ½æ’åºï¼Œé‚£ä¹ˆæ„å‘³ç€è¿™ä¸ªèŠ‚ç‚¹è‚¯å®šå­˜åœ¨å¦ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¹‹æ•°æ®ç«äº‰ã€‚

> $$
> x\prec y \vee y \prec x
> $$
>
> æ£€æŸ¥æ˜¯å¦å­˜åœ¨ x happens before yyy æˆ– y happens before xxx çš„å…³ç³»ã€‚
>
> å¦‚æœå­˜åœ¨ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ï¼Œæ—¢æ²¡æœ‰ $x\prec y$ï¼Œä¹Ÿæ²¡æœ‰$y\prec x$â€‹ï¼ˆä¸¤ä¸ªæ“ä½œä¸èƒ½æ’åºï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ“ä½œå°±å¯èƒ½å‘ç”Ÿæ•°æ®ç«äº‰
>
> Thread Sanitizeré€šè¿‡æ£€æµ‹$x\prec y \vee y \prec x$æ˜¯å¦ä¸ºçœŸæ¥å‘ç°è¿™ç§ç«äº‰
>
> * å¦‚æœæ²¡æœ‰åŒæ­¥åŸè¯­ï¼ˆå¦‚é”ï¼Œæ¡ä»¶å˜é‡ï¼‰æ¥ç¡®ä¿xå’Œyçš„é¡ºåºï¼Œé‚£ä¹ˆå°±æŠ¥å‘Šæ•°æ®ç«äº‰











#### åŠ¨æ€ç¨‹åºåˆ†æ

é™æ€ç¨‹åºåˆ†ææ˜¯åœ¨ä¸è¿è¡Œç¨‹åºçš„æƒ…å†µä¸‹ï¼Œé€šè¿‡æ£€æŸ¥ä»£ç çš„ç»“æ„å’Œè¯­æ³•æ¥å‘ç°æ½œåœ¨çš„é—®é¢˜ã€‚é™æ€åˆ†æå¯ä»¥å‘ç°è¯­æ³•é”™è¯¯ã€ç±»å‹é”™è¯¯ã€æœªä½¿ç”¨çš„å˜é‡ã€æ½œåœ¨çš„å®‰å…¨æ¼æ´ç­‰ã€‚å®ƒé€šå¸¸åœ¨ç¼–è¯‘ä¹‹å‰æˆ–ç¼–è¯‘è¿‡ç¨‹ä¸­è¿›è¡Œã€‚

ä¾‹å¦‚`-r -err`ï¼Œå®ƒå¦‚æœå‘ç°æŸä¸€ä¸ªåˆ†æ”¯æ²¡æœ‰è¿”å›å€¼ï¼Œå°±ä¼šæ‰“å°å‡ºæ¥æé†’ä½ ï¼Œ

æˆ–è€…ä¸€ä¸ªå£°æ˜ä½†æœªä½¿ç”¨å˜é‡ï¼Œä¹Ÿä¼šæé†’ä½ 



åŠ¨æ€ç¨‹åºåˆ†ææ˜¯åœ¨ç¨‹åºè¿è¡Œæ—¶å¯¹å…¶è¡Œä¸ºè¿›è¡Œåˆ†æã€‚å®ƒå¯ä»¥æ£€æµ‹åœ¨å®é™…æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°çš„é—®é¢˜ï¼Œä¾‹å¦‚å†…å­˜æ³„æ¼ã€æ•°æ®ç«äº‰ã€è¿è¡Œæ—¶é”™è¯¯ç­‰ã€‚åŠ¨æ€åˆ†æé€šå¸¸ä¾èµ–äºè¿è¡Œæ—¶çš„ç¯å¢ƒå’Œè¾“å…¥æ•°æ®ã€‚

å°±å¦‚åŒä¸Šé¢è¯´çš„lockdepå’ŒThreadSanitizerï¼Œä»–ä»¬å¯¹ä»£ç ä¿®æ”¹ï¼Œé¦–å…ˆåœ¨äº‹ä»¶å‘ç”Ÿæ—¶è®°å½•ï¼Œç„¶åè§£æè®°å½•æ¥æ£€æŸ¥é—®é¢˜ã€‚



| å·¥å…·                              | åŠŸèƒ½                                                         | ç±»åˆ«     | å‘½ä»¤                                                   |
| --------------------------------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------ |
| AddressSanitizer(Asan)            | æ£€æµ‹å†…å­˜é”™è¯¯ï¼ˆå¦‚è¶Šç•Œè®¿é—®ã€é‡Šæ”¾åä½¿ç”¨ã€åŒé‡é‡Šæ”¾ç­‰ï¼‰           | åŠ¨æ€åˆ†æ | `gcc -fsanitize=address`                               |
| ThreadSanitizer(Tsan)             | ç›‘æµ‹æ•°æ®ç«äº‰å’Œå…¶ä»–çº¿ç¨‹é”™è¯¯(é€šå¸¸ä¼šæ­é…`./a.out > /dev/null`æ¸…é™¤è¾“å‡ºæ¥ç”¨) | åŠ¨æ€åˆ†æ | `gcc -fsanitize=thread`                                |
| MemorySanitizer(Msan)             | ç›‘æµ‹æœªåˆå§‹åŒ–å†…å­˜ä½¿ç”¨(Msan)                                   | åŠ¨æ€åˆ†æ | `clang -fsanitize=memory`ä¸æ”¯æŒgcc                     |
| UndefinedBahaviorSanitizer(UBSan) | ç›‘æµ‹æœªå®šä¹‰è¡Œä¸ºï¼Œä¾‹å¦‚æ•´æ•°æº¢å‡ºï¼Œéæ³•ç±»å‹è½¬æ¢                   | åŠ¨æ€åˆ†æ | `gcc -fsanitize=undifined`                             |
| LeakSanitizer(LSan)               | æ£€æµ‹å†…å­˜æ³„æ¼                                                 | åŠ¨æ€åˆ†æ | `gcc -fsanitize=leak`                                  |
| GCC static Analyzer               | æ£€æµ‹C/C++ä»£ç ä¸­çš„æ½œåœ¨é—®é¢˜ï¼Œå¦‚å†…å­˜æ³„æ¼ã€æœªåˆå§‹åŒ–å˜é‡ã€æ­»ä»£ç ç­‰ã€‚ | é™æ€åˆ†æ | `gcc -fanalyzer`                                       |
| Warningsç¼–è¯‘æ—¶è­¦å‘Š                | æ£€æµ‹å¸¸è§çš„ç¼–è¯‘æ—¶é”™è¯¯å’Œæ½œåœ¨é—®é¢˜ã€‚                             | é™æ€åˆ†æ | `gcc -Wall -Wextra -Werror`                            |
| Static Analyzer Plugins           | GCCå…è®¸åŠ è½½å’Œä½¿ç”¨è‡ªå®šä¹‰çš„é™æ€åˆ†ææ’ä»¶ï¼Œä»¥æ‰©å±•å…¶é™æ€åˆ†æèƒ½åŠ›ã€‚ | é™æ€åˆ†æ | `gcc -fplugin=my_plugin.so -o my_program my_program.c` |

> Asanæ£€æŸ¥è¶Šç•Œä½¿ç”¨çš„æ–¹æ³•è¢«ç§°ä¸ºCanaryï¼Œæ¥è‡ªäºç…¤çŸ¿é‡Œçš„é‡‘ä¸é›€å…¸æ•…ï¼Œå…¶ç›®æ ‡æ˜¯ç‰ºç‰²ä¸€äº›å†…å­˜å•å…ƒæ¥é¢„è­¦ï¼Œä¾‹å¦‚è®¾ç½®æœªåˆ†é…åœ°å€å€¼ä¸º`0xdeadbeaf`ï¼Œç„¶åé€šè¿‡åˆ¤æ–­æ˜¯å¦ä¸ºè¿™ä¸ªMagic numberæ¥åˆ¤æ–­æ˜¯å¦è¶Šç•Œ
>
> ä»¥ä¿æŠ¤æ ˆç©ºé—´ä¸ºä¾‹,æ¯æ¬¡ç”³è¯·äº†ä¸€å—æ ˆç©ºé—´å­˜å‚¨å±€éƒ¨å˜é‡ï¼Œå®ƒé¢å¤–ç”³è¯·ä¸€äº›ï¼Œå°†å¤´éƒ¨å’Œå°¾éƒ¨ç‰ºç‰²ä¸€äº›å•å…ƒæ ¼å¡«å……MAGIC number
>
> ```c++
> #define MAGIC 0xdeadbeaf
> #define BOTTOM (STK_SZ / sizeof(u32) - 1)
> struct stack { char data[STK_SZ]; };
> 
> void canary_init(struct stack *s) {
>   u32 *ptr = (u32 *)s;
>   for (int i = 0; i < CANARY_SZ; i++)
>     ptr[BOTTOM - i] = ptr[i] = MAGIC;
> }
> 
> void canary_check(struct stack *s) {
>   u32 *ptr = (u32 *)s;
>   for (int i = 0; i < CANARY_SZ; i++) {
>     panic_on(ptr[BOTTOM - i] != MAGIC, "underflow");
>     panic_on(ptr[i] != MAGIC, "overflow");
>   }
> }
> 
> 
> ```
>
> 
>
> MSVCå°±æ˜¯è¿™ä¹ˆåšçš„ï¼Œå®ƒä½¿ç”¨
>
> - æœªåˆå§‹åŒ–æ ˆ: `0xcccccccc`
> - æœªåˆå§‹åŒ–å †: `0xcdcdcdcd`
> - å¯¹è±¡å¤´å°¾: `0xfdfdfdfd`
> - å·²å›æ”¶å†…å­˜: `0xdddddddd`
>
> å…¶å®çƒ«çƒ«çƒ«å°±æ˜¯0xccccccccçš„gb2312è§£ç 
>
> ä¸è¿‡msvcä¸æ˜¯å¤´å°¾ï¼Œå®ƒæ˜¯ç›´æ¥ç»™è¿›ç¨‹æ ˆç©ºé—´èµ‹å€¼ï¼Œæ¯•ç«Ÿç‰ºç‰²å­˜å‚¨å•å…ƒæœ‰ç‚¹å¤ªå¥¢ä¾ˆäº†





#### æ›´å¤šç®€å•åœºæ™¯çš„è°ƒè¯•æ–¹æ³•

è¿™é‡Œï¼Œä½ çš„ç¨‹åº1sè·å–ä¸åˆ°é”ä¸å¯èƒ½å‘ç”Ÿï¼Œå¯ä»¥ç”¨è¿™ä¸ªæ–¹æ³•

å†…æ ¸å†…æ˜¯å¯èƒ½å‘ç”Ÿçš„ï¼Œå› æ­¤å†…æ ¸ç¼–ç¨‹ä¸èƒ½ç”¨

![image-20240814154843343](./assets/image-20240814154843343.png)

ä½¿ç”¨Canaryæ¥ç›‘æµ‹å†…å­˜åˆ†é…å™¨

![image-20240814154923155](./assets/image-20240814154923155.png)