## 1. Peterson Algorithm

### é—®é¢˜

è€ƒè™‘å¯¹äºä¹‹å‰çš„Race Conditionçš„ä»£ç 

```c
#include "thread.h"

#define N 10000000

void Tsum(){
    for(int i = 0; i < N; i++){
        sum++;
    }
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```

ç°åœ¨æˆ‘ä»¬å¸Œæœ›ç»™è¿™ä¸ªsum++åŠ ä¸€ä¸ªäº’æ–¥é”

```c
#include "thread.h"

#define N 10000000

void Tsum(){
    for(int i = 0; i < N; i++){
        lock();
        sum++;
        unlock();
    }
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```

äº’æ–¥é”çš„ä½œç”¨æ˜¯ï¼Œå½“è¿›å…¥lockä¹‹åï¼Œå‘Šè¯‰å…¶ä»–çº¿ç¨‹ä¸å…è®¸å¹¶å‘æ‰§è¡ŒæŸä¸€ä¸ªä»£ç æ®µï¼ˆæˆ–è€…è®¿é—®ç‰¹å®šçš„èµ„æºï¼‰ï¼Œä¹Ÿå°±æ˜¯æ‰§è¡ŒæŸä¸€æ®µæ—¶å¼ºåˆ¶ä¸²è¡Œï¼Œä»¥é¿å…race conditionã€‚

ä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªå€¼æ¥è¡¨ç¤ºæ˜¯å¦è§£é”ï¼Œä¸æ˜¯çš„è¯å°±æ­»å¾ªç¯ï¼Œä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæˆ‘ä»¬ä»¥ä¸€æ¬¡sum++ä¸ºä¾‹

```c
#include "thread.h"

#define N 10000000

int locked = UNLOCK;
void Tsum(){
retry:
    if(locked != UNLOCK){
        goto retry;
    }
    locked = LOCK;
    
    sum++;
    
    locked = UNLOCK;
}

int main(){
    create(Tsum);
    create(Tsum);
    join();
    printf("sum = %ld\n", sum);
}
```



è¿™ä¸ªæ–¹å¼çœ‹èµ·æ¥å¾ˆç¾å¥½ï¼Œå®é™…ä¸Šæ˜¯é”™çš„ï¼ŒåŸå› æ˜¯å’Œä¹‹å‰fake alipayçš„ä¾‹å­ä¸€æ ·ï¼Œ==åˆ¤æ–­çš„è¿‡ç¨‹æ˜¯ä¸€ä¸ªéåŸå­æ€§çš„æ“ä½œ==

ä¾‹å¦‚æœ‰ä¸¤ä¸ªçº¿ç¨‹T1ï¼ŒT2

* T1æ‰§è¡Œç¬¬8è¡Œï¼Œåˆ¤æ–­æˆåŠŸï¼Œè¿›å…¥ç¬¬åè¡Œï¼Œä½†æ˜¯æ²¡æœ‰lockä¸Š
* æ­¤æ—¶ï¼Œåˆ‡æ¢ä¸Šä¸‹æ–‡ï¼ŒT2åˆ¤æ–­ç¬¬8è¡Œï¼Œåˆ¤æ–­æˆåŠŸï¼Œè¿›å…¥ç¬¬åè¡Œï¼Œæ­¤æ—¶ï¼ŒT1å’ŒT2éƒ½è¿›å…¥äº†lockåçš„ç¯å¢ƒï¼Œè¿™æ˜¯ä¸€ä¸ªå¤±è´¥çš„é”

äº‹å®ä¸Šï¼Œä¸Šé¢æåˆ°çš„æ˜¯å•å¤„ç†å™¨çš„æƒ…å†µï¼Œå¦‚æœä½ æ˜¯å¤šå¤„ç†å™¨å¹¶è¡Œçš„æƒ…å†µï¼Œä¸¤ä¸ªå¤„ç†å™¨åŒæ—¶è¿›å…¥lockæ˜¯å¾ˆå¸¸è§çš„ã€‚

å› æ­¤ï¼Œæ™®é€šçš„æ“ä½œæ˜¯æ— æ³•æ¨¡æ‹Ÿé”çš„ï¼Œå½’æ ¹åˆ°åº•æ˜¯ä»–ä»¬ä¸èƒ½åŸå­çš„å®Œæˆï¼Œåªè¦ä¸æ˜¯åŸå­çš„æ“ä½œï¼ˆéä¸€æ­¥å®Œæˆï¼‰ï¼Œå°±ä¼šå‡ºé—®é¢˜ã€‚å› æ­¤é€šå¸¸éœ€è¦ç”¨åˆ°ç¡¬ä»¶åº•å±‚çš„lockå‘½ä»¤ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰åªä½¿ç”¨éåŸå­æ€§çš„æ“ä½œå®Œæˆçš„é”çš„æ–¹å¼å‘¢ï¼Ÿæ˜¯æœ‰çš„ï¼Œè¿™å°±æ˜¯Petersonç®—æ³•ã€‚



**å†™åœ¨å‰é¢ï¼ŒPetersonç®—æ³•çš„è¦æ±‚ååˆ†è‹›åˆ»ï¼ŒåŒ…æ‹¬ä½†ä¸é™äº**

* **å˜é‡çš„å˜åŒ–éœ€è¦ä¿è¯ç¼“å­˜ä¸€è‡´æ€§**

  åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªå¤„ç†å™¨éƒ½æœ‰è‡ªå·±çš„ç¼“å­˜ã€‚Petersonç®—æ³•ä¾èµ–äºå…±äº«å˜é‡çš„æ›´æ–°ï¼Œè¿™äº›å˜é‡éœ€è¦åœ¨å„ä¸ªå¤„ç†å™¨çš„ç¼“å­˜ä¸­ä¿æŒä¸€è‡´ã€‚è¿™ä¼šå¯¼è‡´å¤§é‡çš„ç¼“å­˜ä¸€è‡´æ€§æµé‡ï¼Œå½±å“æ€§èƒ½ã€‚

* **ä¸¥æ ¼çš„å†…å­˜é¡ºåºä¿è¯**

  ç°ä»£å¤„ç†å™¨å¯èƒ½ä¼šé‡æ–°æ’åºæŒ‡ä»¤ä»¥ä¼˜åŒ–æ€§èƒ½ã€‚Petersonç®—æ³•éœ€è¦ä¸¥æ ¼çš„å†…å­˜é¡ºåºä¿è¯ï¼Œä»¥ç¡®ä¿æ ‡å¿—å˜é‡å’Œè½®è½¬å˜é‡çš„æ“ä½œæŒ‰é¢„æœŸé¡ºåºå‘ç”Ÿã€‚å¦åˆ™ï¼Œå¯èƒ½ä¼šå‡ºç°æ— æ³•é¢„æ–™çš„ç«æ€æ¡ä»¶ã€‚è¿™éœ€è¦ä½¿ç”¨å†…å­˜å±éšœæˆ–ç¼–è¯‘å™¨æŒ‡ä»¤æ¥ä¿è¯é¡ºåºä¸€è‡´æ€§ï¼Œè¿™åœ¨å®é™…ç¼–ç¨‹ä¸­å¢åŠ äº†å¤æ‚æ€§ã€‚

* **ä»…é€‚ç”¨äºä¸¤ä¸ªçº¿ç¨‹**





**åŒæ—¶ï¼Œè¯´æ˜å¤šå¤„ç†å™¨ä¸‹çš„ä¸€ä¸ªloadæ“ä½œ(æš‚æ—¶è®¤ä¸ºæ˜¯åŸå­æ“ä½œ)æ˜¯å¦‚ä½•å‘ç”Ÿçš„**

* å½“å¤šä¸ªå¤„ç†å™¨åŒæ—¶å°è¯•å†™å…¥åŒä¸€ä¸ªå˜é‡æ—¶ï¼Œç³»ç»Ÿä¼šè¿›è¡Œä»²è£ï¼Œç¡®ä¿åªæœ‰ä¸€ä¸ªå¤„ç†å™¨èƒ½æˆåŠŸæ‰§è¡Œå†™æ“ä½œã€‚

  - **ä»²è£æœºåˆ¶**ï¼šç¡¬ä»¶ä½¿ç”¨ä»²è£æœºåˆ¶æ¥å†³å®šå“ªä¸ªå¤„ç†å™¨ä¼˜å…ˆè¿›è¡Œå†™æ“ä½œï¼Œ==å…¶ä»–å¤„ç†å™¨ä¼šè¢«æš‚æ—¶é˜»å¡ï¼Œç›´åˆ°å†™æ“ä½œå®Œæˆã€‚==

* è®©æˆ‘ä»¬å…·ä½“åˆ†æä¸€ä¸‹åœ¨ä¸¤ä¸ªå¤„ç†å™¨åŒæ—¶å‘å˜é‡ `A` å†™å…¥å€¼æ—¶å¯èƒ½å‘ç”Ÿçš„æƒ…å†µï¼š

  1. **åŒæ—¶å†™å…¥å°è¯•**ï¼š

     - å¤„ç†å™¨ P1 å’Œ P2 éƒ½å°è¯•å†™å…¥å˜é‡ `A`ï¼Œå‡è®¾å†™å…¥çš„å€¼åˆ†åˆ«æ˜¯ `1` å’Œ `2`ã€‚

  2. **ç¼“å­˜ä¸€è‡´æ€§åè®®ä½œç”¨**ï¼š

     - ä¸¤ä¸ªå¤„ç†å™¨çš„ç¼“å­˜æ§åˆ¶å™¨ä¼šé€šè¿‡ç¼“å­˜ä¸€è‡´æ€§åè®®æ¥åè°ƒå†™å…¥æ“ä½œã€‚

       > **ç¼“å­˜è¡Œæ— æ•ˆ**ï¼šå¦‚æœä¸€ä¸ªå¤„ç†å™¨ä¿®æ”¹äº†æŸä¸ªç¼“å­˜è¡Œï¼Œå…¶ä»–å¤„ç†å™¨ä¸­çš„è¯¥ç¼“å­˜è¡Œä¼šè¢«æ ‡è®°ä¸ºæ— æ•ˆã€‚
       >
       > **ç¼“å­˜è¡Œæ›´æ–°**ï¼šå½“ä¸€ä¸ªå¤„ç†å™¨å†™å…¥å…±äº«å˜é‡æ—¶ï¼Œå®ƒä¼šå‘å…¶ä»–å¤„ç†å™¨å‘é€æ¶ˆæ¯ï¼Œæ›´æ–°å®ƒä»¬çš„ç¼“å­˜æˆ–ä½¿å®ƒä»¬çš„ç¼“å­˜è¡Œæ— æ•ˆã€‚

     - å¦‚æœ P1 å…ˆè·å–åˆ°å†™å…¥æƒé™ï¼Œå®ƒå°†å†™å…¥ `1`ï¼Œå¹¶é€šè¿‡ä¸€è‡´æ€§åè®®é€šçŸ¥ P2ï¼Œä½¿ P2 çš„ç¼“å­˜è¡Œæ— æ•ˆã€‚

     - æ¥ä¸‹æ¥ï¼ŒP2 å°è¯•å†™å…¥ `2` æ—¶ï¼Œå¿…é¡»å…ˆä»å†…å­˜è¯»å–æœ€æ–°çš„å€¼ï¼Œæˆ–ç›´æ¥è¿›è¡Œå†™å…¥ã€‚

  3. **ä»²è£æœºåˆ¶**ï¼š

     - å¤„ç†å™¨ä¹‹é—´é€šè¿‡ä»²è£æœºåˆ¶å†³å®šå†™å…¥çš„é¡ºåºã€‚å‡è®¾ P1 è·èƒœï¼Œå®ƒå®Œæˆå†™å…¥ `1` åï¼ŒP2 å†è¿›è¡Œå†™å…¥ `2`ã€‚
     - æœ€ç»ˆå†…å­˜ä¸­çš„å€¼æ˜¯ `2`ï¼Œå› ä¸º P2 çš„å†™å…¥è¦†ç›–äº† P1 çš„å†™å…¥ã€‚

  4. **æ€»çº¿é”æˆ–ç¼“å­˜é”**ï¼š

     - ç¡®ä¿å†™å…¥æ“ä½œçš„åŸå­æ€§ï¼Œé€šè¿‡é”ä½æ€»çº¿æˆ–ç¼“å­˜è¡Œï¼Œé˜²æ­¢å…¶ä»–å¤„ç†å™¨å¹²æ‰°ã€‚

==è¿™ä½“ç°äº†å¤šå¤„ç†å™¨çš„loadæ“ä½œå®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä¸å•å¤„ç†å™¨å¹¶å‘çœ‹ä½œæ˜¯ç±»ä¼¼çš„æ“ä½œï¼Œå³ä¸ºâ€œå¤„ç†å™¨æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªçº¿ç¨‹çš„ä¸€ä¸ªæŒ‡ä»¤è¿è¡Œâ€ï¼Œä¸€åŒè®¨è®ºã€‚==ï¼ˆå› ä¸ºä¸»è¦å‘ç”Ÿäº‰è®®çš„ç‚¹å°±æ˜¯æ¶‰åŠåˆ°å…±äº«å†…å­˜ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†æ˜¯å®Œå…¨å¹¶è¡Œè¿˜æ˜¯å•å¤„ç†å™¨å¹¶å‘æ— å…³ç´§è¦ï¼‰







### Petersonç®—æ³•

Petersonç®—æ³•æå‡ºäº†ä¸€ç§äº’æ–¥çš„åè®®ï¼Œå®ƒçš„æ¨¡å‹æ˜¯åŸºäºå…±äº«å†…å­˜æ¨¡å‹ï¼Œ

ç®€å•æ¥è¯´ï¼Œä¸ºäº†è§£å†³ä¹‹å‰æåˆ°çš„â€œä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿›å…¥äº†é”â€çš„æƒ…å†µï¼ŒPetersonç®—æ³•ä½¿ç”¨äº†ä¸€æ¬¡é¢å¤–çš„åˆ¤æ–­æ¥å¤„ç†è¿™ç§æƒ…å†µã€‚

* ä¸¤ä¸ªçº¿ç¨‹è‹¥æ˜¯éœ€è¦è¿›å…¥é”éƒ½éœ€è¦å£°æ˜(flag = true)
* ä¸¤ä¸ªçº¿ç¨‹åœ¨è¿›è¡Œæ“ä½œå‰éœ€è¦é¦–å…ˆåœ¨ä¸€ä¸ªå…¬å…±boardä¸Šå†™ä¸Šå¯¹æ–¹çº¿ç¨‹çš„åå­—
* ä¸¤ä¸ªçº¿ç¨‹åœ¨è¿›è¡Œæ“ä½œå‰éœ€è¦åˆ¤æ–­
  * å¯¹æ–¹æ˜¯å¦ä¹Ÿè¿›å…¥é”ï¼ˆflag == true)
  * å¦‚æœå¯¹æ–¹ä¹Ÿè¿›å…¥é”ï¼Œåˆ¤æ–­boardæ˜¯å¦ä¸ºè‡ªå·±çš„åå­—ï¼Œå¦‚æœä¸æ˜¯åˆ™ç­‰å¾…ï¼ˆè°¦è®©ï¼‰
  * å¦‚æœå¯¹æ–¹æœªè¿›å…¥é”ï¼Œç›´æ¥æ‰§è¡Œ
  * ç»“æŸåé‡ç½®è‡ªå·±çš„flag=false

```c
#include "thread.h"

#define A 1
#define B 2

atomic_int nested;
atomic_long count;

/*
    è¿™ä¸ªå‡½æ•°å®ç°äº†ä¸€ä¸ªå¯¹countåŸå­åŠ å’ŒåŸå­å‡çš„è¿‡ç¨‹ï¼Œç”¨äºéªŒè¯å¯¹ä¸´ç•ŒåŒºçš„è®¿é—®æ§åˆ¶ã€‚
    - `count` å˜é‡ç”¨äºè®°å½•è¿›å…¥ä¸´ç•ŒåŒºçš„æ¬¡æ•°ã€‚
    - `nested` å˜é‡ç”¨äºç¡®ä¿ä¸´ç•ŒåŒºçš„äº’æ–¥è®¿é—®ï¼Œå³åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨ä¸´ç•ŒåŒºå†…ã€‚

    å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š
    1. å°†countçš„å€¼å¢åŠ 1ï¼Œè¿”å›å¢åŠ å‰çš„å€¼ï¼Œå¹¶å°†å…¶èµ‹ç»™`cnt`ã€‚
    2. å°†nestedçš„å€¼å¢åŠ 1ï¼Œå¹¶æ–­è¨€å¢åŠ å‰çš„å€¼ä¸º0ï¼ˆç¡®ä¿æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨ä¸´ç•ŒåŒºå†…ï¼‰ã€‚
    3. å°†nestedçš„å€¼å‡å°‘1ï¼Œä»¥è¡¨ç¤ºçº¿ç¨‹ç¦»å¼€äº†ä¸´ç•ŒåŒºã€‚
    
    å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹åœ¨ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆç¨‹åºå°±ä¼šè§¦å‘æ–­è¨€assertï¼Œè¿™ä¸ªå‡½æ•°ä¸€å®šç¨‹åº¦ä¸Šèƒ½å±•ç°ç¨‹åºçš„çŠ¶æ€æœºï¼Œä½†æ˜¯å¹¶ä¸èƒ½ä¿è¯ç®—æ³•çš„æ­£ç¡®æ€§
*/
void critical_section(){
    long cnt = atomic_fetch_add(&count, 1);
    assert(atomic_fetch_add(&nested, 1) == 0);
    atomic_fetch_add(&nested, -1);
}

// volatileå…³é—­äº†ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œä¸»è¦ç›®çš„æ˜¯é˜²æ­¢ç¼–è¯‘å™¨ç¼“å­˜è¿™äº›å˜é‡åˆ°å¯„å­˜å™¨ä¸­
// è¿™å°±å¯èƒ½ä¼šå¯¼è‡´ï¼Œä¸€ä¸ªçº¿ç¨‹å¯¹å˜é‡çš„ä¿®æ”¹å¯¹å¦ä¸€ä¸ªçº¿ç¨‹ä¸å¯è§
// volatileå¼ºåˆ¶ä¿è¯ä¸¤ä¸ªçº¿ç¨‹ä»å†…å­˜è¯»å–
int volatile x = 0, y = 0, turn = A;


void TA(){
    while(1){
        x = 1;					// å£°æ˜éœ€è¦å†™å…¥
        turn = B;				// å°†å…±äº«çŠ¶æ€è½¬æ¢ä¸ºB
        while(y && turn == B);	// åˆ¤æ–­æ˜¯å¦å¯ä»¥è¿›å…¥é”åŒº
        critical_section();		// æ‰§è¡Œä»»åŠ¡
        x = 0;					// å£°æ˜ä»»åŠ¡å®Œæˆ
    }
}

void TB(){
    while(1){
        y=1;					
        turn = A;
        while(x && turn == A);
        critical_section();
        y=0;
    }
}
```

å¯ä»¥å‘ç°ï¼ŒPetersonç®—æ³•é€šè¿‡ä¸€ä¸ªâ€œè°¦è®©â€æœºåˆ¶ï¼Œå·§å¦™åœ°æŠ¹å»äº†ä¹‹å‰`x=1`å’Œ`turn = B`çš„éåŸå­æ€§

å¦‚æœæ²¡æœ‰è¿™ä¸ªè°¦è®©æœºåˆ¶ï¼ˆä¾‹å¦‚å¯¹äºThreadA`x = 1;turn=A;while(y && turn==B);`)ï¼Œæ­¤æ—¶å­˜åœ¨ä¸€ä¸ªæ‰§è¡Œé¡ºåº

`TA:x=1`

`TB:y=1`

`TA:turn=A`

`TA:while(y && turn==B);`:æ­¤æ—¶turn=Aï¼Œå› æ­¤ç›´æ¥è¿›å…¥é”

`TB:turn=B`

`TB:while(x && turn==A);`ï¼šæ­¤æ—¶turn=B,å› æ­¤ç›´æ¥è¿›å…¥é”



è¿™é‡Œå¹¶ä¸å‡å®š `while (flag[1] && turn == 1);` æ˜¯åŸå­çš„ã€‚ç›¸åï¼Œ**Petersonç®—æ³•åˆ©ç”¨äº†ç°ä»£å¤„ç†å™¨æä¾›çš„åŸºæœ¬å†…å­˜æ“ä½œçš„åŸå­æ€§æ¥å®ç°å®ƒçš„äº’æ–¥æœºåˆ¶ã€‚**æˆ–è€…è¯´Petersonç®—æ³•çš„åŸºç¡€æ˜¯è¯»å†™æ“ä½œåœ¨ç°ä»£å¤„ç†å™¨ä¸­çš„ä¸²è¡Œæ€§ï¼ˆå³ä¸¤ä¸ªçº¿ç¨‹å¯¹ä¸€ä¸ªå…±äº«å˜é‡çš„å†™å…¥ä¸€å®šä¼šè®©è¿™ä¸ªå…±äº«å˜é‡ç»å†ä¸¤æ¬¡çŠ¶æ€çš„å˜æ¢ï¼‰



å…·ä½“çš„petersonç®—æ³•çš„çŠ¶æ€æ ‘å¯ä»¥è¢«ç”»å‡ºä»¥è¯æ˜å…¶æ­£ç¡®æ€§ï¼ŒçŠ¶æ€å¤ªå¤šæ‡’çš„ç”»äº†

![image-20240731164204710](./assets/image-20240731164204710.png)

### ç°ä»£å¤„ç†å™¨ä¸ŠPetersonç®—æ³•çš„å±€é™æ€§

å®ƒçš„å±€é™æ€§å°±ä½“ç°åœ¨æ²Ÿæ§½çš„ç¼–è¯‘å™¨ä¼˜åŒ–å’Œä¹±åºæ‰§è¡Œ

æ¢å¥è¯è¯´ï¼Œå®ƒçš„å†…å­˜åºæ— æ³•è¢«ä¿è¯

å¯ä»¥å‘ç°

![image-20240731164904002](./assets/image-20240731164904002.png)

å®ƒè¿è¡Œäº†å¤§æ¦‚22359328æ¬¡å°±ä¼šå‡ºé”™ï¼Œä¹Ÿå°±æ˜¯å®ƒå†…éƒ¨è¿è¡Œæ—¶æ ¹æœ¬ä¸è·Ÿç€çŠ¶æ€æœºå·²æœ‰çŠ¶æ€æ¥æ‰§è¡Œ





è¿™ä¸ªçš„è§£å†³æ–¹å¼æ˜¯æ·»åŠ barrier

```c++

#include "thread.h"

#define A 1
#define B 2

#define BARRIER __sync_synchronize()

atomic_int nested;
atomic_long count;

void critical_section() {
  long cnt = atomic_fetch_add(&count, 1);
  int i = atomic_fetch_add(&nested, 1) + 1;
  if (i != 1) {
    printf("%d threads in the critical section @ count=%ld\n", i, cnt);
    assert(0);
  }
  atomic_fetch_add(&nested, -1);
}

int volatile x = 0, y = 0, turn;

void TA() {
  while (1) {
    x = 1;                   BARRIER;
    turn = B;                BARRIER; // <- this is critcal for x86
    while (1) {
      if (!y) break;         BARRIER;
      if (turn != B) break;  BARRIER;
    }
    critical_section();
    x = 0;                   BARRIER;
  }
}

void TB() {
  while (1) {
    y = 1;                   BARRIER;
    turn = A;                BARRIER;
    while (1) {
      if (!x) break;         BARRIER;
      if (turn != A) break;  BARRIER;
    }
    critical_section();
    y = 0;                   BARRIER;
  }
}

int main() {
  create(TA);
  create(TB);
}
```

è¿™é‡Œæ·»åŠ BARRIERä¹‹åï¼Œå¯ä»¥å‘ç°ï¼Œwhileä¸­çš„åˆ¤æ–­é¡ºåºä¹Ÿæ˜¯éœ€è¦äººä¸ºè§„å®šçš„ã€‚å¿…é¡»æ˜¯å…ˆåˆ¤æ–­flagååˆ¤æ–­turnã€‚

![image-20240731165050071](./assets/image-20240731165050071.png)

æ­¤æ—¶å°±èƒ½æ­£å¸¸æ‰§è¡Œäº†ã€‚

`__sync_synchronize()`ä¸ä»…ä¸å…è®¸ç¼–è¯‘å™¨éšæ„reorderï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªmemory_barrier







## 2. å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ï¼ˆè‡ªæ—‹é”ï¼Œäº’æ–¥é”ä¸Futexï¼‰



### 2.1 Motivation

Petersonçš„å¹¶å‘å®ç°æ˜¯å¾ˆä½æ•ˆçš„ï¼ŒçœŸæ­£çš„å¹¶å‘

ä½†æ˜¯Petersonç®—æ³•ç»™äº’æ–¥æä¾›äº†ä¸€ä¸ªä»£ç å±‚é¢çš„å®ç°



äº’æ–¥ï¼ˆmutual exclusionï¼‰åŸºæœ¬ä¸Šå°±æ˜¯å®ç°ä¸€ä¸ªlock/unlockçš„APIï¼Œè¿™ä¸ªlock/unlockä¹‹é—´æ˜¯é”çš„å¯¹è±¡ï¼Œè¿™æ˜¯ä¸€ä¸ªå…·æœ‰æ’ä»–æ€§çš„é”ï¼Œè¿™æ„å‘³ç€å¯¹äºé”çš„å¯¹è±¡ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„lock**ä¸èƒ½è¿”å›ã€‚**



ä»ç¬¬ä¸€ç« ä¸­Petersonç®—æ³•çš„ç¤ºä¾‹å¯ä»¥çœ‹å‡ºï¼Œå®ç°äº’æ–¥é”çš„æ ¹æœ¬å›°éš¾åœ¨äºloadå’Œstoreæ˜¯åˆ†å¼€çš„ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½åŒæ—¶è¯»å†™å…±äº«å†…å­˜ï¼Œè¿™å¯¼è‡´äº†ç¨‹åºè·å¾—çš„æ‰€æœ‰ä¿¡æ¯éƒ½æ˜¯â€œå†å²ä¿¡æ¯â€ï¼Œä½ å¹¶ä¸èƒ½ä¿è¯å®ƒåœ¨å½“å‰æƒ…å†µä¸‹ä¸éœ€æ±‚ç¬¦åˆã€‚



ç°åœ¨ï¼Œä½ éœ€è¦åšçš„å°±æ˜¯å¯¹äºç¬¦åˆè¦æ±‚çš„å¤šä¸ªçº¿ç¨‹ï¼Œè®©ä»–ä»¬è¿›å…¥ç­‰å¾…åŒºï¼ˆé”ï¼‰ï¼Œä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿæ“ä½œã€‚



è¦å®Œæˆè¿™ä¸ªç›®æ ‡ï¼Œ

* è¦ä¹ˆæ˜¯æå‡ºç®—æ³•ï¼ˆPetersonï¼‰ï¼Œ

* è¦ä¹ˆå°±æ˜¯æ±‚å·±ä¸å¦‚æ±‚äººï¼ˆæˆ‘ä»¬**ç›´æ¥è®©ç¡¬ä»¶å¤šä¸€ä¸ªæ“ä½œï¼Œä½¿å¾—storeå’Œloadèƒ½å¤Ÿæˆä¸ºåŸå­æ“ä½œ**ï¼‰

  æ¢å¥è¯è¯´ï¼Œæ­¤æ—¶æœ‰å¤šä¸ªçº¿ç¨‹è¯·æ±‚å°†sum+1ï¼Œåœ¨è¿™ä¸€ä¸ªæ—¶é—´æ­¥ï¼Œç¡¬ä»¶ç›´æ¥æ—¶åœï¼Œå®ƒä¼šçœ‹ä¸€çœ‹æœ‰å“ªäº›çº¿ç¨‹è¯·æ±‚+1ï¼Œç„¶åé€‰ä¸€ä¸ªå¹¸è¿å„¿åœ¨è¿™ä¸ªæ—¶é—´æ­¥å®Œæˆ`load,calculate,store`ï¼Œå¹¶å°†å…¶ä»–è¯·æ±‚å»¶åã€‚è¿™æ ·å°±å®Œç¾çš„è§£å†³äº†race conditionçš„é—®é¢˜

  > è¿™ä¹Ÿæ˜¯x86æ¶æ„çš„å“²å­¦ï¼Œæ—¢ç„¶è¿™ä¸ªå®ç°å¾ˆéº»çƒ¦ï¼Œé‚£ä¸å¦‚åŠ ä¸€æ¡æŒ‡ä»¤äº¤ç»™ç¡¬ä»¶åš

```c++
#include "thread.h"

#define N 10000000

long sum = 0;

void Tsum(){
        for(int i = 0; i < N; i++)
        {
                asm volatile("lock addq $1, %0" : "+m"(sum));
        }

}

int main(){
        create(Tsum);

        create(Tsum);

        join();

        printf("sum = %ld\n", sum);

}
```



![image-20240801155925763](./assets/image-20240801155925763.png)

æ­¤å¤„çš„lockæ˜¯ä¸€ä¸ª**x86æ±‡ç¼–æŒ‡ä»¤å‰ç¼€**ï¼Œç”¨äºç¡®ä¿åç»­æŒ‡ä»¤åœ¨å¤šå¤„ç†å™¨ç¯å¢ƒä¸­çš„åŸå­æ€§ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™æ„å‘³ç€ `lock` å‰ç¼€ä½¿å¾—éšåçš„æŒ‡ä»¤åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«å…¶ä»–å¤„ç†å™¨ä¸­æ–­ï¼Œä»è€Œç¡®ä¿å¯¹å…±äº«å†…å­˜çš„æ“ä½œæ˜¯åŸå­çš„ã€‚

* `addq $1, %0` çš„æ„æ€æ˜¯å°†ç«‹å³æ•° 1 åŠ åˆ°æ“ä½œæ•° `%0` ä¸Šã€‚
* `%0` æ˜¯å†…è”æ±‡ç¼–ä¸­çš„å ä½ç¬¦ï¼Œç”± `"+m"(sum)` æŒ‡å®šã€‚`sum` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œ`+m` è¡¨ç¤ºè¯¥æ“ä½œæ•°æ˜¯å†…å­˜æ“ä½œæ•°ï¼Œå¹¶ä¸”å°†è¢«è¯»å†™ã€‚









### 2.2 è‡ªæ—‹é” (Spin lock)

> **ç®€å•æ¥è¯´ï¼Œè‡ªæ—‹é”å°±æ˜¯ï¼Œä½ è‡ªå·±çŠ¶æ€ä¸ºlockï¼Œæœ‰ä¸€ä¸ªå…¬å…±çŠ¶æ€ä¸ºunlockï¼Œæ¯ä¸ªçº¿ç¨‹æ­»å¾ªç¯çš„ä¸å…¬å…±çŠ¶æ€äº¤æ¢ï¼Œè‹¥è‡ªå·±çš„çŠ¶æ€å˜ä¸ºunlockå³è§†ä¸ºè¿›å…¥é”ã€‚**
>
> è¿™é‡Œæ˜¯åˆ©ç”¨äº†åŸå­æŒ‡ä»¤xchgå®ç°çš„

`xchg`

```c
// è¯¥æ“ä½œå°†ä¸€ä¸ªæ–°å€¼å­˜å‚¨åˆ°æŒ‡å®šçš„å†…å­˜ä½ç½®ï¼Œå¹¶è¿”å›è¯¥ä½ç½®ä¹‹å‰çš„æ—§å€¼ã€‚è®©æˆ‘ä»¬è¯¦ç»†è§£æè¿™æ®µä»£ç ï¼š
int xchg(volatile int *adder, int newval){
    // è¿™é‡Œxchgæœ¬æ¥å°±æ˜¯åŸå­çš„ï¼Œå¯ä»¥ä¸ç”¨lock
	asm volatile("lock xchg %0, %1" : "+m"(*adder), "=a"(result) : "1"(newval));
    return result
}
```

å…·ä½“çš„åŸå­æŒ‡ä»¤å‚è€ƒæ‰‹å†Œ`stdatomic.h`

åˆ©ç”¨è¿™äº›åŸå­æŒ‡ä»¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç®€åŒ–ä¹‹å‰çš„åè®®

```c
int table  = YES;
void lock(){
retry:
    // å°†flagé€šè¿‡äº¤æ¢è®¾ç½®ä¸ºNOPEå¹¶è·å–åŸæœ¬tableä¸­çš„å€¼
    int got = xchg(&table, NOPE);
    // got == YESåˆ™è¿›å…¥é”
    if(got == NOPE){
        goto retry;
    }
    assert(got == YES);
}

void unlock(){
    xchg(&table, YES);
}
```

æ›´ç®€åŒ–ä¸€äº›å¯ä»¥è·å¾—

```c
int lock = 0;
void lock(){while(xchg(&locked,1));}
void unlock(){xchg(&locked,0);}
```

è¿™å°±è·å¾—äº†ä¸€ä¸ªè‡ªæ—‹é”







### 2.3 åŸå­æŒ‡ä»¤çš„æ¨¡å‹

#### æŒ‡ä»¤å‰ç¼€lock

![image-20240801190425848](./assets/image-20240801190425848-1722510267269-1.png)

æ‰€æœ‰çš„åŸå­æŒ‡ä»¤ï¼ŒåŒ…æ‹¬lock å£°æ˜ï¼Œå¯¹äºå•å¤„ç†å™¨å’Œå¤šå¤„ç†å™¨æ¨¡å‹éƒ½æ»¡è¶³ä¸¤æ¡å®šå¾‹ï¼š

* **lockæ»¡è¶³åŸå­æ€§ï¼š**å³åŒä¸€ç§ç±»å‹çš„lockå¿…å®šä¸²è¡Œå¤„ç†

* **lockä¿è¯ç›¸å¯¹å†…å­˜åºï¼š**å¯¹äºä¸€ä¸ªçº¿ç¨‹ä¸Šä¸åŒçš„lockï¼ˆä¾‹å¦‚å…ˆæ‰§è¡Œlock1ï¼Œåæ‰§è¡Œlock2ï¼‰ï¼Œåæ‰§è¡Œçš„lock2å¿…å®šèƒ½ä¿è¯å…ˆæ‰§è¡Œçš„lock1ä¹‹å‰çš„æ‰€æœ‰æŒ‡ä»¤å·²æ‰§è¡Œ

  è¿™é‡Œç›¸å¯¹å†…å­˜åºè¡¨ç¤ºçš„æ˜¯

  * lock1ä¹‹å‰çš„å·²å®Œæˆ
  * lock2åˆ°lock1ä¹‹é—´çš„å†…å­˜åºæ— æ³•ä¿è¯







#### x86çš„åŸå­æŒ‡ä»¤å®ç°

åŸå­æŒ‡ä»¤é€šå¸¸æ˜¯é€šè¿‡Bus Lockå®ç°çš„ã€‚

<img src="./assets/image-20240801192033793.png" alt="image-20240801192033793" style="zoom:50%;" />

ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªå¤šå¤„ç†å™¨å•memoryçš„æ¨¡å‹ï¼Œæ¯ä¸ªå¤„ç†å™¨é€šè¿‡æ€»çº¿å‘memoryå‘å‡ºæŒ‡ä»¤è¯·æ±‚ã€‚

ä»¥addä¸ºä¾‹ï¼Œé€šå¸¸æ˜¯`load->calculate->store`

ä¸ºäº†åº”å¯¹å¤šå¤„ç†å™¨æ¨¡å‹ä¸­å¯¹åŒä¸€ä¸ªå˜é‡çš„å¤šä¸ªaddè¯·æ±‚ï¼Œx86åœ¨ç¡¬ä»¶ä¸Šå®ç°äº†é”ï¼Œå…·ä½“æ¥è¯´ï¼Œæ˜¯ä¸ºmemoryæ·»åŠ äº†é”ï¼ˆ1bitçš„æŒ‡ç¤ºä½ï¼‰ï¼Œå½“æ€»çº¿ä¸­æœ‰å¤šä¸ªè¯·æ±‚æ—¶ï¼Œæ€»çº¿å†³å®šè®©ä¸€ä¸ªå¤„ç†å™¨çš„è¯·æ±‚é€šè¿‡ã€‚

å¯¹äºä¸€ä¸ª`lock [instruction]`è¯­å¥ï¼Œå®ƒé€šå¸¸é¦–å…ˆè¯»å–lockï¼Œåœ¨è·å–åˆ°memory lockæƒé™ä¹‹åæ‰ä¼šæ‰§è¡Œåé¢çš„instructionã€‚è¿™ç§å®ç°æ—©æœŸåœ¨8086å’Œä¸€äº›æœåŠ¡å™¨ä¸Šå‡ºç°ã€‚



ç°ä»£Intel CPUå…·æœ‰æé‡çš„å†å²åŒ…è¢±ï¼Œè¿™æ˜¯å› ä¸ºæ¯ä¸ªå¤„ç†å™¨éƒ½æœ‰ä¸€ä¸ªcacheã€‚å½“æ¯ä¸ªå¤„ç†å™¨çš„cacheéƒ½hitäº†å…±äº«å˜é‡æ—¶ï¼Œbusä¼šé¦–å…ˆé€‰æ‹©ä¸€ä¸ªå¤„ç†å™¨ï¼ˆä¸€ä¸ªçº¿ç¨‹ï¼‰å…è®¸å…¶è®¿é—®memoryï¼Œå¹¶ä¸ºmemoryä¸Šé”ï¼ŒåŒæ—¶ï¼Œåˆ é™¤å…¶ä»–cacheä¸­çš„å¯¹åº”cache lineï¼Œå¼ºè¿«ä»–ä»¬åœ¨é”ç»“æŸåè§¦å‘cache missï¼Œä»memoryé‡æ–°è¯»å–æœ€æ–°çš„å€¼ã€‚

* L1 cacheå±‚ä¿æŒä¸€è‡´æ€§

  * æ¯ä¸ªcache lineæœ‰åˆ†åˆ«çš„é”
  * store(x)è¿›å…¥L1ç¼“å­˜å³ä¿è¯å¯¹å…¶ä»–å¤„ç†å™¨å¯è§ï¼Œéœ€è¦å°å¿ƒstore bufferå’Œä¹±åºæ‰§è¡Œ

* L1 cache lineæ ¹æ®çŠ¶æ€è¿›è¡Œåè°ƒ

  çŠ¶æ€åŒ…æ‹¬

  * **M**odifiesï¼Œ dirty bitï¼Œè¡¨ç¤ºæ˜¯å¦ä¿®æ”¹
  * **E**xclusive, ç‹¬å è®¿é—®
  * **S**hared, åªè¯»å…±äº«
  * **I**nvalid, cache lineæ— æ•ˆ

<img src="./assets/image-20240801192025151.png" alt="image-20240801192025151" style="zoom:50%;" />







#### RISCVçš„åŸå­æŒ‡ä»¤è®¾è®¡

ä¸åŒäºx86çš„æ€»çº¿é”ï¼ŒRSIC-Vä½¿ç”¨äº†å¦ä¸€ç§æ–¹å¼æ›´ç»†ç²’åŒ–çš„å®Œæˆäº†ä¸€ä¸ªé”ã€‚

è§‚å¯Ÿä¹‹å‰æåˆ°çš„å‡ ä¸ªåŸå­æ“ä½œ

* atomic test-and-set: `reg = load(x); if(reg == xx){store(x,YY);}`
* lock xchg: `reg = load(x); store(x,XX);`
* lock add:`t = load(x); t++; store(x,t);`

å¯ä»¥å‘ç°ï¼Œæ‰€æœ‰çš„race conditionå½’æ ¹åˆ°åº•æ˜¯â€æ¥è‡ªloadåˆ°å¯„å­˜å™¨â€œ åï¼Œå…±äº«å˜é‡å¯èƒ½è¢«å…¶ä»–äººä¿®æ”¹ï¼Œå¯¼è‡´â€storeå›å»â€œçš„æ—¶å€™æœ¬åœ°å˜é‡å’Œå…±äº«å˜é‡å¯¹åº”çš„åˆå§‹çŠ¶æ€ä¸ä¸€è‡´ã€‚

x86åšçš„æ˜¯åªå…è®¸ä¸€ä¸ªçº¿ç¨‹`è¯»å–ï¼Œå¤„ç†ï¼Œå†™å›`å…±äº«å˜é‡

è€ŒRISC-Våšçš„äº‹å…è®¸æ‰€æœ‰çº¿ç¨‹`è¯»å–`å…±äº«å˜é‡å¹¶åœ¨æœ¬åœ°`å¤„ç†`ï¼Œä½†æ˜¯å†™å›æ—¶ï¼Œè‹¥æ˜¯å…±äº«å˜é‡å·²ç»è¢«å¤„ç†è¿‡ï¼Œé‚£ä¹ˆå°±é‡æ–°`è¯»å–`å¹¶`å¤„ç†`ï¼Œå¦åˆ™ç›´æ¥å†™å›ã€‚

å®¹æ˜“å‘ç°ï¼Œæ ‡è®°ä¸èƒ½æ˜¯1bitæ ‡å¿—ä½ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªçº¿ç¨‹æ•°ä½æ•°çš„æ ‡å¿—ç»„ã€‚å¦åˆ™ä¼šå­˜åœ¨çº¿ç¨‹Aæ‰“ä¸Šreservedæ ‡è®°ï¼Œçº¿ç¨‹Bå†™å›æ¶ˆé™¤reservedæ ‡è®°ï¼Œçº¿ç¨‹C loadåˆæ‰“ä¸Šreservedæ ‡è®°ï¼Œè¿™ä¼šå¯¼è‡´çº¿ç¨‹Aè®¤ä¸ºå…±äº«å˜é‡æœªè¢«ä¿®æ”¹ã€‚



RISC-Væœ‰**Load-Reserved(LR)**å’Œ**Store-Conditional**ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹è¯»å–å…±äº«å˜é‡æ—¶ï¼Œå®ƒä¼šåœ¨å†…å­˜ä¸Šæ‰“ä¸Šæ ‡è®°ï¼ˆreservedï¼‰ï¼Œå…¶ä»–çº¿ç¨‹çš„å†™å…¥éƒ½ä¼šå¯¼è‡´æ ‡è®°æ¶ˆé™¤ã€‚

```
lr.w rd, (rs1)
rd = M[rs1]
reserve M[rs1]
```

å½“è¯¥çº¿ç¨‹å¤„ç†å®Œå…±äº«å˜é‡åï¼Œè‹¥æ˜¯reservedæ ‡è®°å­˜åœ¨åˆ™ç›´æ¥å†™å›ï¼Œå¦åˆ™é‡æ–°æ‰§è¡Œè¯»å–å¤„ç†ã€‚

```
sc.w rd, rs2, (rs1)
if still reserved:
	M[rs1] = rs2
	rd = 0
elseï¼›
	rd = nonzero
```



ä¸€ä¸ªç®€å•çš„å®ç°å¦‚ä¸‹

```c
int cas(int *addr, int cmp_val, int new_val){
    int old_val = *addr;
    if(old_val == cmp_val){
        *addr = new_val; return 0;
    }else{
        return 1;
    }
}
```





### è‡ªæ—‹é”çš„åŠ£åŠ¿

**ä½æ€§èƒ½**ï¼šè‡ªæ—‹é”å› ä¸ºåœ¨ä¸åœçš„ä¿®æ”¹å…±äº«å˜é‡ï¼ˆæ ‡å¿—ä½ï¼‰ï¼Œåœ¨ç°ä»£å¤šå¤„ç†å™¨ï¼ˆå¸¦cacheï¼‰ä¸­ä¼šå› ä¸ºç¼“å­˜åŒæ­¥å¯¼è‡´å»¶è¿Ÿå¢åŠ ï¼Œæ€§èƒ½ä¸‹é™ã€‚

**æ— æ•ˆè´Ÿè½½**ï¼šåœ¨è‡ªæ—‹é”ä¸­ï¼Œåªæœ‰è·å–é”çš„çº¿ç¨‹æ‰æ˜¯æœ‰æ•ˆè´Ÿè½½ï¼Œå…¶ä»–çº¿ç¨‹åªæ˜¯åœ¨ç©ºè½¬ï¼Œå ç”¨CPUèµ„æºã€‚è¿™æ„å‘³ç€äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½ã€‚

**å ç€èŒ…å‘ä¸æ‹‰å±**ï¼šåœ¨è‡ªæ—‹é”ä¸­ï¼Œè·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹$\color{red}{å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»}$ã€‚å› ä¸ºè½®è½¬æ—¶é—´ç‰‡æœºåˆ¶ï¼Œåœ¨æ“ä½œç³»ç»Ÿçœ¼é‡Œï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è¦å¿™çš„äº‹ï¼Œæœ‰äº›å¿™ç©ºè½¬ï¼Œæœ‰äº›å¿™æ­£äº‹ï¼Œä½†æ˜¯æ“ä½œç³»ç»Ÿä¸çŸ¥é“ï¼Œå¦‚æœæŠŠè‡ªæ—‹é”åˆ‡å‡ºå»äº†ï¼Œè¿™ä¸‹å°±æ˜¯100%çš„èµ„æºæµªè´¹äº†ã€‚





å› æ­¤ï¼Œè‡ªæ—‹é”çš„åº”ç”¨åœºæ™¯æ˜¯ä½œä¸ºâ€å¾ˆå°‘å‘ç”Ÿå†²çªçš„åœºæ™¯â€œä¸­ä½¿ç”¨ã€‚

* ä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µ
* æŒæœ‰è‡ªæ—‹é”æ—¶è¯¥çº¿ç¨‹ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢ï¼ˆå› æ­¤æ™®é€šè¿›ç¨‹æ˜¯ä¸å¯èƒ½çš„ï¼‰

è‡ªæ—‹é”é€šå¸¸ç”¨äº**æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„**ï¼Œè¿™äº›æ•°æ®ç»“æ„å…·æœ‰çŸ­ä¸´ç•ŒåŒºï¼Œä¹Ÿå°±æ˜¯ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å¯èƒ½éœ€è¦100nsï¼Œè®¡ç®—å¯èƒ½éœ€è¦100msï¼Œå¾ˆä¸é¢‘ç¹çš„å–ä»»åŠ¡æ—¶ï¼Œä»»åŠ¡å†²çªå°±å¾ˆå°‘æ­¤æ—¶å°±æ˜¯ä¸€ä¸ªçŸ­ä¸´ç•ŒåŒºã€‚

* æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å ï¼Œä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”









### æ€§èƒ½ç»´åº¦ï¼šScalability

å¯¹äºåŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ï¼ˆCPU cyclesï¼‰å’Œç©ºé—´ï¼ˆmapped memoryï¼‰ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚

æ ¹æ®2.2ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—ä¸€ä»½è‡ªæ—‹é”çš„å®ç°

```c
#include <semaphore.h>

// Spinlock
typedef int spinlock_t;
#define SPIN_INIT() 0

static inline int atomic_xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1":
    "+m"(*addr), "=a"(result) : "1"(newval) : "memory");
  return result;
}

void spin_lock(spinlock_t *lk) {
  while (1) {
    intptr_t value = atomic_xchg(lk, 1);
    if (value == 0) {
      break;
    }
  }
}
void spin_unlock(spinlock_t *lk) {
  atomic_xchg(lk, 0);
}

// Mutex
typedef pthread_mutex_t mutex_t;
#define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER
void mutex_lock(mutex_t *lk)   { pthread_mutex_lock(lk); }
void mutex_unlock(mutex_t *lk) { pthread_mutex_unlock(lk); }

// Conditional Variable
typedef pthread_cond_t cond_t;
#define COND_INIT() PTHREAD_COND_INITIALIZER
#define cond_wait pthread_cond_wait
#define cond_broadcast pthread_cond_broadcast
#define cond_signal pthread_cond_signal

// Semaphore
#define P sem_wait
#define V sem_post
#define SEM_INIT(sem, val) sem_init(sem, 0, val)
~                                                     
```

ä½¿ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥æµ‹è¯•æ€§èƒ½

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
spinlock_t lock = SPIN_INIT();
long n, sum = 0;

void Tsum(){
    // è‡ªæ—‹é”ä¿æŠ¤ä¸‹çš„sum++
    for(int i = 0; i < n; i++){
        spin_lock(&lock);
        sum++;
        spin_unlock(&lock);
    }
}

int main(int argc, char*argv[]){
    assert(argc==2);
    // åˆ†é…nthreadä¸ªçº¿ç¨‹åˆ†åˆ«å®Œæˆnæ¬¡sum++
    int nthread = atoi(argv[1]);
    n = N/nthread;
    for(int i = 0; i < nthread; i++){
        create(Tsum);
    }
    join();
    assert(sum == n * nthread);
}
```

![image-20240801205633178](./assets/image-20240801205633178.png)

å¯ä»¥å‘ç°ï¼Œçº¿ç¨‹è¶Šå¤šï¼Œè€—æ—¶è¶Šé•¿

![image-20240801210422158](./assets/image-20240801210422158.png)





### ç¡çœ é”/äº’æ–¥é”ï¼šå®ç°è‡ªæ—‹é”é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥

è¿™é‡Œçš„æƒ³æ³•æ˜¯ï¼Œè®©ç©ºè½¬çš„çº¿ç¨‹æ”¾æƒï¼Œå°†èµ„æº(CPU)è®©ç»™å…¶ä»–ä½œä¸šï¼ˆçº¿ç¨‹ï¼‰æ‰§è¡Œã€‚

å¯ä»¥å‘ç°ï¼Œè¿™é‡Œå­˜åœ¨â€å‡ºè®©èµ„æºâ€œçš„è¡Œä¸ºï¼Œè¿™ä¸ªè¡Œä¸ºä¸€å®šä¸æ˜¯è¿›ç¨‹æœ¬èº«ï¼ˆå‡ºè®©CPUèµ„æºæ§åˆ¶æƒï¼‰å¯ä»¥åšçš„ï¼Œè¿™ä¸ªè¡Œä¸ºæ˜¯æ“ä½œç³»ç»Ÿè¿›ç¨‹æ‰èƒ½åšçš„ï¼ˆCè¯­è¨€ä»£ç åªèƒ½è®¡ç®—ï¼‰

å› æ­¤ï¼Œé€šå¸¸è¿™äº›è¿›ç¨‹ä¼šä½¿ç”¨system call

* `syscall(SYSCALL_lock, &lk);`

  è¯•å›¾è·å¾—lkï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹

* `syscall(SYSCALL_unlock,&lk);`

  é‡Šæ”¾lkï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

> * å…ˆåˆ°çš„çº¿ç¨‹è¿›å…¥é”ï¼Œ`lk=ğŸ”’`ï¼Œç³»ç»Ÿè°ƒç”¨ç›´æ¥è¿”å›
> * å…¶ä»–çš„çº¿ç¨‹å‘ç°`lk=ğŸ”’`ï¼Œçº¿ç¨‹è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ‰§è¡Œçº¿ç¨‹åˆ‡æ¢(yield)
> * å½“ç¬¬ä¸€ä¸ªçº¿ç¨‹å®Œæˆ
>   * è‹¥ç­‰å¾…é˜Ÿåˆ—ä¸ç©ºï¼Œä»ç­‰å¾…é˜Ÿåˆ—å–å‡ºä¸€ä¸ªçº¿ç¨‹å…è®¸æ‰§è¡Œ
>   * è‹¥ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œè®¾ç½®`lk=ç©º`
> * OSä½¿ç”¨è‡ªæ—‹é”ä¿è¯è‡ªå·±å¤„ç†lkçš„è¿‡ç¨‹æ˜¯åŸå­çš„





### è‡ªæ—‹é”ä¸ç¡çœ é”

**è‡ªæ—‹é”**ï¼ˆçº¿ç¨‹ç›´æ¥å…±äº«lockedï¼‰

* æ›´å¿«çš„fast path
  * xchgæˆåŠŸï¼ˆä»…ä¸€æ¡åŸå­æŒ‡ä»¤åï¼‰$\rightarrow$ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
* æ›´æ…¢çš„slow path
  * xchgå¤±è´¥$\rightarrow$ æµªè´¹CPUè‡ªæ—‹





**ç¡çœ é”**ï¼ˆé€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—®locked)

* æ›´å¿«çš„slow path
  * ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨CPU
* æ›´æ…¢çš„fast path
  * å³ä½¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸(syscall)





### æŠ˜ä¸­çš„æ–¹æ¡ˆï¼šFutex(Fast Userspace muTexes)

Fast Pathï¼šä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›

Slow Pathï¼šä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 

è¿™ä¸ªæ–¹æ³•åˆ†ç¦»äº†ä¸Šé”å’Œsyscallï¼Œé¿å…äº†ç¡çœ é”ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦syscallï¼Œä¹Ÿé¿å…äº†è‡ªæ—‹é”ä¸Šé”å¤±è´¥æŒç»­å ç”¨CPU

> ### å·¥ä½œæœºåˆ¶
>
> 1. **ç”¨æˆ·ç©ºé—´çš„è‡ªæ—‹é”**ï¼š åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œçº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´ä½¿ç”¨è‡ªæ—‹é”è¿›è¡ŒåŒæ­¥ã€‚å¦‚æœé”å¾ˆå¿«å¯ç”¨ï¼Œçº¿ç¨‹åªåœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹å‡ æ¬¡ï¼Œä¸ä¼šè¿›å…¥å†…æ ¸ï¼Œä»è€Œå‡å°‘äº†ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚
> 2. **å†…æ ¸ç©ºé—´çš„ç¡çœ é”**ï¼š å½“çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹ä¸€æ®µæ—¶é—´åä»æœªè·å–åˆ°é”ï¼Œå°±ä¼šé€šè¿‡`futex`ç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸ã€‚å†…æ ¸ä¸­çš„`futex`æœºåˆ¶ä¼šå°†çº¿ç¨‹ç½®äºç¡çœ çŠ¶æ€ï¼Œç­‰å¾…é”å˜å¾—å¯ç”¨ã€‚å½“é”å¯ç”¨æ—¶ï¼Œå†…æ ¸ä¼šå”¤é†’ç­‰å¾…çš„çº¿ç¨‹ã€‚
>
> ### è¯¦ç»†æ­¥éª¤
>
> 1. **å°è¯•è·å–é”**ï¼š
>    - çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´å°è¯•è·å–é”ã€‚å¦‚æœæˆåŠŸï¼Œåˆ™è¿›å…¥ä¸´ç•ŒåŒºã€‚
>    - å¦‚æœé”è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼Œåˆ™è¿›è¡Œè‡ªæ—‹ç­‰å¾…ã€‚
> 2. **ç”¨æˆ·ç©ºé—´è‡ªæ—‹**ï¼š
>    - çº¿ç¨‹åœ¨ç”¨æˆ·ç©ºé—´è‡ªæ—‹ä¸€æ®µæ—¶é—´ï¼Œå°è¯•å¤šæ¬¡è·å–é”ã€‚å¦‚æœåœ¨æŒ‡å®šçš„è‡ªæ—‹æ¬¡æ•°å†…è·å–åˆ°é”ï¼Œåˆ™è¿›å…¥ä¸´ç•ŒåŒºã€‚
>    - å¦‚æœè‡ªæ—‹ç­‰å¾…è¶…è¿‡æŒ‡å®šæ¬¡æ•°ä»æœªè·å–åˆ°é”ï¼Œåˆ™è¿›å…¥å†…æ ¸æ€ã€‚
> 3. **è¿›å…¥å†…æ ¸æ€**ï¼š
>    - çº¿ç¨‹è°ƒç”¨`futex`ç³»ç»Ÿè°ƒç”¨ï¼Œå°†è‡ªèº«é˜»å¡åœ¨é”ä¸Šï¼Œè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç­‰å¾…é”å˜å¾—å¯ç”¨ã€‚
> 4. **é”é‡Šæ”¾å’Œå”¤é†’**ï¼š
>    - å½“æŒæœ‰é”çš„çº¿ç¨‹é‡Šæ”¾é”æ—¶ï¼Œä¼šé€šè¿‡`futex`ç³»ç»Ÿè°ƒç”¨é€šçŸ¥å†…æ ¸ï¼Œå†…æ ¸ä¼šå”¤é†’ç­‰å¾…é”çš„çº¿ç¨‹ã€‚
>    - è¢«å”¤é†’çš„çº¿ç¨‹ä»å†…æ ¸æ€è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œé‡æ–°å°è¯•è·å–é”ã€‚

```c
#include "thread.h"
#include "thread-sync.h"

#define N 10000000
mutex_t lock = MUTEX_INIT();
long n, sum = 0;

void Tsum(){
    // è‡ªæ—‹é”ä¿æŠ¤ä¸‹çš„sum++
    for(int i = 0; i < n; i++){
        mutex_lock(&lock);
        sum++;
        mutex_unlock(&lock);
    }
}

int main(int argc, char*argv[]){
    assert(argc==2);
    // åˆ†é…nthreadä¸ªçº¿ç¨‹åˆ†åˆ«å®Œæˆnæ¬¡sum++
    int nthread = atoi(argv[1]);
    n = N/nthread;
    for(int i = 0; i < nthread; i++){
        create(Tsum);
    }
    join();
    assert(sum == n * nthread);
}
```

æ€§èƒ½æå‡æ˜¯éå¸¸æ˜æ˜¾çš„

![image-20240802143941797](./assets/image-20240802143941797.png)

è¿™é‡Œå°±æ˜¯è°ƒç”¨çš„çº¿ç¨‹åº“ä¸­çš„é”

å¦‚æœä½¿ç”¨straceçœ‹è¿™ä¸ªç¨‹åºæ‰€æœ‰å­è¿›ç¨‹çš„è¯

```bash
strace -f ./a.out 64
```

![image-20240802145044509](./assets/image-20240802145044509.png)

å¯ä»¥å‘ç°è°ƒç”¨çš„æ˜¯futex







## 3. åŒæ­¥æ§åˆ¶

åŒ…æ‹¬å…¸å‹çš„åŒæ­¥é—®é¢˜ï¼šç”Ÿäº§è€…æ¶ˆè´¹è€…ï¼›å“²å­¦å®¶åƒé¥­

åŒæ­¥çš„å®ç°æ–¹æ³•ï¼šä¿¡å·é‡ï¼Œæ¡ä»¶å˜é‡



### 3.1 åŒæ­¥

ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šéšæ—¶é—´å˜åŒ–çš„é‡åœ¨å˜åŒ–çš„è¿‡ç¨‹ä¸­ä¿æŒä¸€å®šçš„ç›¸å¯¹å…³ç³»

>  å¼‚æ­¥(Asynchronous) = ä¸åŒæ­¥

çº¿ç¨‹åŒæ­¥æ„å‘³ç€$\color{red}{åœ¨æŸä¸ªæ—¶é—´ç‚¹åŒæ—¶è¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€}$



### 3.2 Naive Producer-Consumer Model

```c
void Tproduce(){while(1) printf("(");}
void Tconsume(){while(1) printf(")");}
```

è¿™é‡Œçš„æ‹¬å·åŒ¹é…è¦æ±‚

* å³æ‹¬å·ä¸€å®šèƒ½æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å·
* æ€»çš„æœªåŒ¹é…å·¦æ‹¬å·æ•°ä¸è¶…è¿‡n

æ‰€ä»¥å·¦æ‹¬å·å¯ä»¥çœ‹ä½œä¸€ä¸ªproducerï¼Œè€Œå³æ‹¬å·å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªconsumer



è¿™ä¸ªé—®é¢˜æ¨¡æ‹Ÿäº†ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ï¼Œå…¶ä¸­ä½ éœ€è¦æœ‰å·¦æ‹¬å·çš„ç”Ÿäº§æ‰èƒ½æœ‰å³æ‹¬å·çš„æ¶ˆè´¹

è€ƒè™‘è¿™ä¹ˆä¸€ä¸ªæ¨¡å‹å¦‚ä½•åº”å¯¹å¹¶å‘çŠ¶å†µ

ä¸€ä¸ªæƒ³æ³•æ˜¯ä½¿ç”¨äº’æ–¥é”

* æ¯å½“Produceræ·»åŠ ä»»åŠ¡æ—¶
  * ä»»åŠ¡æ± ä¸Šé”
  * åˆ¤æ–­é˜Ÿåˆ—æ·±åº¦æ˜¯å¦å¤§äºnï¼Œè‹¥å°äºnåˆ™ç»™ä¸€ä¸ªåˆ°è¾¾Producerçº¿ç¨‹è§£é”ï¼Œç»™è¯¥çº¿ç¨‹å†™å…¥æƒé™
* å½“Consumerè·å–ä»»åŠ¡æ—¶
  * ä»»åŠ¡æ± ä¸Šé”
  * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºåˆ™ç»™ä¸€ä¸ªåˆ°è¾¾çš„consumerçº¿ç¨‹è§£é”ï¼Œç»™è¯¥çº¿ç¨‹è¯»å–æƒé™

ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŒæ¡ä»¶æˆç«‹

```c++
#include "thread.h"
#include "thread-sync.h"

int n, count = 0;
mutex_t lk = MUTEX_INIT();

void Tproduce(){
    while(1){
    retry:
        mutex_lock(&lk);
        
        if(count == n){
            mutex_unlock(&lk);
            goto retry;
        }
        count++;
        printf("(");
        mutex_unlock(&lk);
    }
}



void Tconsume(){
    while(1){
    retry:
        mutex_lock(&lk);
        if(count == 0){
            mutex_unlock(&lk);
            goto retry;
        }
        
        count--;
        printf(")");
        mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc == 2);
    n = atoi(argv[1]);
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tproduce);
    }
}
```

```bash
gcc -pc.c -lpthread && ./a.out 1
```

è¿™é‡Œä¼ å…¥å‚æ•°1è¡¨ç¤ºä»»åŠ¡æ± æœ€å¤šåªèƒ½æ¥å—ä¸€ä¸ªä»»åŠ¡ï¼Œè‡³å°‘ä»è¿™é‡Œçœ‹èµ·æ¥è¿˜æ˜¯æ²¡é—®é¢˜çš„ï¼Œæ²¡æœ‰ç±»ä¼¼`(())`æˆ–è€…æ›´å¤šçš„æƒ…å†µ

![image-20240805145236531](./assets/image-20240805145236531.png)

å½“ç„¶ï¼Œæ›´é«˜çš„å‚æ•°äººçœ¼å°±è¯†åˆ«ä¸å‡ºæ¥äº†ï¼Œæ‰€ä»¥å¯ä»¥ç”¨è„šæœ¬è¯­è¨€å†™ä¸€ä¸ªç®€å•çš„checker

```py
import sys
# limit read from input, represents the max job num in poll
limit = int(sys.argv[1])
# n è®¾ç½®ä¸º 100000ï¼Œè¿™æ˜¯æ¯æ¬¡ä»æ ‡å‡†è¾“å…¥è¯»å–çš„å­—ç¬¦æ•°é‡ã€‚
count, n = 0, 100000

while True:
    # ä»æ ‡å‡†è¾“å…¥è¯»å– n ä¸ªå­—ç¬¦ï¼Œå¹¶é€ä¸ªå¤„ç†
    for ch in sys.stdin.read(n):
        if ch == '(': count += 1
        if ch == ')': count -= 1
        # æ–­è¨€ count çš„å€¼åœ¨ 0 å’Œ limit ä¹‹é—´ã€‚å¦‚æœ count è¶…å‡ºæ­¤èŒƒå›´ï¼Œç¨‹åºä¼šæŠ›å‡º AssertionError å¹¶ç»ˆæ­¢ã€‚
        assert 0 <= count <= limit
    print(f'{n} Ok.')

```

```bash
./a.out 1 | python3 pc-check.py 1
```

é¦–å…ˆå¯ä»¥å‘ç°ï¼Œè¿™ä¸ªç¨‹åºæ˜¯å½“a.outè¾“å…¥ä¸º2ï¼Œpyè®¾å®šä¸º1æ—¶æ˜¯ä¼šæŠ¥é”™çš„ï¼Œè¿™è¯´æ˜å¤§æ¦‚ç‡ç¨‹åºæ˜¯æ²¡bugçš„

![image-20240805151350844](./assets/image-20240805151350844.png)

![image-20240805151305319](./assets/image-20240805151305319.png)















### 3.3 æ”¹è¿›1ï¼šConditional valuable(æ¡ä»¶å˜é‡cv)

#### 3.3.1 futex/mutexå®ç°çš„åŠ£åŠ¿

åœ¨ä¸Šé¢çš„å®ç°ä¸­ï¼Œå¯ä»¥å‘ç°

* å°±ç®—ä»»åŠ¡é˜Ÿåˆ—æ»¡äº†ï¼Œå‡å¦‚æ²¡æœ‰ç©ºé—²çš„consumerï¼Œæ­¤æ—¶producerä»ç„¶ä¼šä¸åœçš„å»è·å–é”è¯•å›¾å¾€é‡Œé¢åŠ ä»»åŠ¡

  å…·ä½“æ¥è¯´ï¼Œ

  producer thread 1è·å–é”ï¼Œå…¶ä½™producer threadè¯•å›¾è·å–é”è¢«æ²‰ç¡**ï¼ˆfutex)**

  producer thread 1 é‡Šæ”¾é”ï¼Œå”¤é†’å…¶ä½™producer thread**(futex)**

  è¿™æ˜¯å¾ˆæ— æ„ä¹‰å¾ˆè€—æ—¶é—´çš„ï¼ŒåŒæ—¶å¯èƒ½è¯´100ä¸ªproducerè¯•å›¾å¾€æ»¡çš„poolé‡Œæ¨å…¥ä»»åŠ¡ï¼Œä½¿å¾—åˆšé†’æ¥çš„consumer threadè¢«å¡å¾ˆä¹…ï¼Œå› ä¸ºä»–ä»¬ä½¿ç”¨çš„åŒä¸€ä¸ªé”

* åŒç†ï¼Œå°±ç®—ä»»åŠ¡é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œconsumerä¹Ÿä¼šä¸åœçš„å»ç”³è¯·ï¼Œproducerå¯èƒ½è¢«ä¸¥é‡é˜»å¡



é‡æ–°åˆ†æä¸€ä¸‹ä¹‹å‰é—®é¢˜çš„å†™æ³•(futex)

* çº¿ç¨‹è·å–é”ï¼Œä»…æœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè·å–åˆ°é”ï¼Œå…¶ä½™è¢«futexæ²‰ç¡
* è·å–åˆ°é”çš„çº¿ç¨‹åˆ¤æ–­æŸä¸€ä¸ªæ¡ä»¶æ˜¯å¦æˆç«‹
  * ä¸æˆç«‹çš„è¯é‡Šæ”¾é”ï¼Œè¯¥çº¿ç¨‹retryï¼Œfutexå”¤é†’å…¶ä»–çº¿ç¨‹
  * æˆç«‹çš„è¯ç›´æ¥è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œ
* æ¯æ¬¡é”å› ä¸ºå„ç§åŸå› è¢«é‡Šæ”¾åï¼Œ**æ‰€æœ‰çº¿ç¨‹éƒ½ä¼šå†è¯•å›¾å»è·å–é”**



æˆ‘ä»¬æœŸå¾…çš„æ˜¯ä¼˜åŒ–å»è¿™ä¸ª**è®¸å¤šçº¿ç¨‹åŒæ—¶è·å–é”çš„è¿‡ç¨‹**ï¼Œæ›´å‡†ç¡®çš„è¯´ï¼Œæ˜¯ä¸å¿…è¦çš„é”çš„è·å–è¿‡ç¨‹

ä¾‹å¦‚ï¼Œæˆ‘ç°åœ¨ä»»åŠ¡æ± å·²ç»æ»¡äº†ï¼Œè¿˜æ˜¯æœ‰é“ºå¤©ç›–åœ°çš„producer threadè¯•å›¾æ·»åŠ ä»»åŠ¡ï¼Œè¿™å°±æ˜¯æµªè´¹CPUèµ„æºçš„è¡Œä¸ºï¼Œå› ä¸ºæ³¨å®šæ˜¯å¤±è´¥çš„

ä¼˜åŒ–çš„æ€è·¯å°±æ˜¯ï¼Œæ—¢ç„¶ä½ æˆä¸ºäº†å¹¸è¿å„¿ï¼Œä½ è·å–åˆ°é”äº†ï¼Œé‚£ä¹ˆå¦‚æœä½ æ²¡æœ‰èƒ½å¤Ÿæ»¡è¶³æ¡ä»¶ï¼ˆä¾‹å¦‚ä»»åŠ¡æ± æ»¡äº†ï¼‰ï¼Œé‚£ä¹ˆä½ å°±åº”è¯¥æ²‰ç¡ï¼Œç›´åˆ°ä»»åŠ¡æ± æœ‰ç©ºä½ä½ æ‰èƒ½å¤Ÿå‚ä¸é”çš„ç«äº‰



#### 3.3.2 æ¡ä»¶å˜é‡

æ¡ä»¶å˜é‡APIåŒ…æ‹¬

* `wait(cv,mutex)`
  * wait until wake
  * è°ƒç”¨æ—¶å¿…é¡»ä¿è¯å·²ç»è·å¾—mutex
  * é‡Šæ”¾mutexï¼Œè¿›å…¥ç¡çœ çŠ¶æ€
  * ç›¸å½“äº`mutex_unlock_and_sleep`
* `signal(cv)`
  * Notification
  * å¦‚æœæœ‰ä¸€ä¸ªçº¿ç¨‹æ­£åœ¨ç­‰å¾…cvï¼Œå”¤é†’å…¶ä¸­ä¸€ä¸ª
  * ç›¸å½“äºwake_up()
* `broadcast(cv)`
  * å”¤é†’å…¨éƒ¨æ­£åœ¨ç­‰å¾…cvçš„çº¿ç¨‹







#### 3.3.3 ä¸€ä¸ªé”™è¯¯çš„ä¾‹å­

åœ¨[6. å¹¶å‘æ§åˆ¶](https://www.bilibili.com/video/BV17T4y1S7RS/?p=6&spm_id_from=pageDriver&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9)ä¸­æå‡ºäº†ä¸€ä¸ªé”™è¯¯çš„ç­–ç•¥ï¼Œå®ƒæœŸå¾…è®©æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„çº¿ç¨‹æ²‰ç¡ï¼Œä¸€æ¬¡å”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œä»¥å‡å°‘çº¿ç¨‹é—´çš„mutexç«äº‰ï¼Œå› æ­¤è·å¾—äº†é”™è¯¯çš„ç»“æœï¼Œå¯ä»¥çœ‹ä¸€ä¸‹



```c++
#include "thread.h"
#include <semaphore.h>

int n, count = 0;

mutex_t lk = PTHREAD_MUTEX_INITIALIZER;
cond_T cv = PTHREAD_COND_INITIALIZER;

void Tproduce(){
    while(1){
        pthread_mutex_lock(&lk);
        if(count == n){
            pthread_cond_wait(&cv, &lk);
        }
        printf("(");count++;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }

}


void Tconsume(){
    while(1){
        pthread_mutex_lock(&lk);
        if(count == 0){
            pthread_cond_wait(&cv, &lk);
        }
        printf(")");count--;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc==2);
    
    n = atoi(argv[1]);
    // è®¾ç½®æ ‡å‡†è¾“å‡ºä¸ºæ— ç¼“å†²
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tconsume);
    }
}
```

> åœ¨ä»£ç ä¸­ä½¿ç”¨ `setbuf(stdout, NULL);` å°†æ ‡å‡†è¾“å‡ºè®¾ç½®ä¸ºæ— ç¼“å†²æ¨¡å¼ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ç¡®ä¿æ¯æ¬¡è°ƒç”¨ `printf` æ—¶ï¼Œè¾“å‡ºç«‹å³è¢«å†™å…¥åˆ°ç›®æ ‡ï¼ˆå¦‚ç»ˆç«¯ï¼‰ï¼Œè€Œä¸æ˜¯å…ˆå­˜å‚¨åœ¨ç¼“å†²åŒºä¸­ã€‚è¿™åœ¨è°ƒè¯•å’Œå®æ—¶è¾“å‡ºæ—¶éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå¯ä»¥ç¡®ä¿æ‰€æœ‰è¾“å‡ºæŒ‰é¡ºåºç«‹å³æ˜¾ç¤ºï¼Œè€Œä¸ä¼šå› ä¸ºç¼“å†²è€Œå»¶è¿Ÿã€‚

è¿™é‡Œçš„`pthread_cond_wait`åšäº†ä¸‰ä¸ªæ“ä½œ

* é‡Šæ”¾é”
* ç¡çœ ç­‰å¾…wake
* wakeåè¯•å›¾è·å–é”
* è·å–é”æˆåŠŸåˆ™ç»§ç»­åé¢çš„ï¼Œå¦åˆ™ä»ç„¶å¤„äºcvçš„ç­‰å¾…é˜Ÿåˆ—



è¿™é‡Œå¯ä»¥å‘ç°ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„é€»è¾‘æ¼æ´äº†ï¼Œ==å®ƒå¹¶æ²¡æœ‰å†æ¬¡åˆ¤æ–­count==

![image-20240805165100566](./assets/image-20240805165100566.png)

æ˜¾ç„¶ï¼Œå®ƒç¬¬ä¸€ä¸ªåä¸‡ç”¨ä¾‹éƒ½æ²¡æ’‘è¿‡å»



##### åˆ†æ1ï¼šé‡å¤åˆ¤æ–­æ¡ä»¶

ä»¥producerä¸ºä¾‹ï¼Œå®ƒåœ¨æ²‰ç¡æ—¶ä»£è¡¨ä»»åŠ¡æ± ä¸ºæ»¡ï¼Œä½†æ˜¯å¯èƒ½é†’æ¥åä»»åŠ¡æ± ä»ç„¶ä¸ºæ»¡ï¼Œä½†æ˜¯æ­¤æ—¶è¿™ä¸ªçº¿ç¨‹æ‰€éœ€è¦åšçš„å°±æ˜¯è·å¾—å”¾æ‰‹å¯å¾—çš„æ§åˆ¶æƒï¼ˆå› ä¸ºåªæœ‰å®ƒä¸€ä¸ªè‹é†’äº†ï¼‰ï¼Œå®ƒå¹¶ä¸ç”¨é‡æ–°åˆ¤æ–­ä»»åŠ¡æ± ï¼Œå› æ­¤å°±ä¼šå‡ºç°é”™è¯¯

åŒç†ï¼Œå¯¹äºconsumerä¹Ÿæ˜¯è¿™æ ·

**å› æ­¤ï¼Œä¸€ä¸ªè¾ƒä¸ºé€šç”¨çš„ä½¿ç”¨condition variableçš„æ–¹å¼å°±å‡ºæ¥äº†ï¼Œå³ä¸ºä½¿ç”¨whileé‡å¤åˆ¤æ–­æ¡ä»¶**

æ­¤æ—¶cvè¿ä½œçš„è¿‡ç¨‹æ˜¯è¿™æ ·çš„

* åˆ¤æ–­æ¡ä»¶ï¼Œè‹¥ç¬¦åˆåˆ™è¿›å…¥

* é‡Šæ”¾é”
* ç¡çœ ç­‰å¾…wake
* wakeåè¯•å›¾è·å–é”
* è·å–é”æˆåŠŸï¼Œé‡æ–°åˆ¤æ–­æ¡ä»¶

```c++
#include "thread.h"
#include <semaphore.h>

int n, count = 0;

mutex_t lk = PTHREAD_MUTEX_INITIALIZER;
cond_T cv = PTHREAD_COND_INITIALIZER;

void Tproduce(){
    while(1){
        pthread_mutex_lock(&lk);
        //æ”¹æˆwhileï¼Œåœ¨è¿™æ ·åœ¨cond waitè·å–é”ä¹‹åä»ç„¶èƒ½å¤Ÿåˆ¤æ–­
        while(count == n){
            pthread_cond_wait(&cv, &lk);
        }
        assert(count != n);//ç”¨äºå‹åŠ›æµ‹è¯•
        printf("(");count++;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }

}


void Tconsume(){
    while(1){
        pthread_mutex_lock(&lk);
        while(count == 0){
            pthread_cond_wait(&cv, &lk);
        }
        printf(")");count--;
        pthread_cond_signal(&cv);
        pthread_mutex_unlock(&lk);
    }
}


int main(int argc, char* argv[]){
    assert(argc==2);
    
    n = atoi(argv[1]);
    // è®¾ç½®æ ‡å‡†è¾“å‡ºä¸ºæ— ç¼“å†²
    setbuf(stdout, NULL);
    for(int i = 0; i < 8; i++){
        create(Tproduce);
        create(Tconsume);
    }
}
```

ç»è¿‡æµ‹è¯•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šæ¦‚ç‡å‡ºç°ä¸€ä¸ªbug

![image-20240805201957072](./assets/image-20240805201957072.png)

å®ƒä¼šåœ¨æŸä¸€ä¸ªæ—¶é—´ç‚¹æ­»é”äº†

è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯signalï¼Œè¿™æ„å‘³ç€æ¯æ¬¡ä¸€ä¸ªçº¿ç¨‹å®Œæˆæ“ä½œï¼Œä»…èƒ½å”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œå¾ˆå®¹æ˜“å‡ºç°å¡ä½ï¼Œå‡ºç°æ­»é”

å…·ä½“æ¥è¯´ï¼Œ











è§£å†³æ–¹æ³•å°±æ˜¯æ¯æ¬¡éƒ½æ˜¯å…¨éƒ¨å”¤é†’ï¼Œè€Œéä»…å”¤é†’ä¸€ä¸ª

å³æ›¿æ¢`pthread_cond_signal`ä¸º`pthread_cond_broadcast`

![image-20240806141158397](./assets/image-20240806141158397.png)

==è¿™ä¹Ÿæ˜¯ä¸€ç§å¾ˆå¸¸è§çš„ä½¿ç”¨æ¡ä»¶å˜é‡å®ç°å¹¶è¡Œè®¡ç®—çš„æ–¹å¼ï¼Œå³==

```c++
struct job{
    void (*run)(void *arg);
    void *arg;
}


while(1){
    struct job* job;
    mutex_lock(&mutex);
    while(!(job=get_job())){
        wait(&cv,&mutex);
    }
    
    mutex_unlock(&mutex);
    job0>run(job->arg);
}
```









å¦ä¸€ç§åšæ³•å°±æ˜¯ä¸èƒ½åŒç±»å”¤é†’ï¼Œå³ä¸ºConsumerä¸èƒ½å”¤é†’consumerï¼ŒProducerä¸èƒ½å”¤é†’producerï¼Œå› ä¸ºä»–ä»¬çš„èµ„æºæ˜¯ä¸€ä¸ªç›¸äº’dependï¼Œè€ŒåŒç±»æ˜¯ç«äº‰çš„ã€‚



















### 3.4 ä¸€ä¸ªç®€å•çš„å¹¶è¡Œé¢˜ç›®ï¼šç”»ğŸŸ

è€ƒè™‘ä¸€ä¸ªå¹¶è¡Œç¨‹åºï¼Œå®ƒè¦æ±‚ä½ ç”»å‡º`<><_`æˆ–è€…`><>_`çš„ç»„åˆ

![image-20240806155658881](./assets/image-20240806155658881.png)

å¦‚å›¾æ‰€ç¤ºï¼Œæ¯ä¸ªçº¿ç¨‹è®¤é¢†ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶é€šè¿‡barrieræŒ‰é¡ºåºè¾“å‡ºä»–ä»¬

åŸºæœ¬çš„æ€æƒ³å¾ˆç®€å•ï¼Œå°±æ˜¯çŠ¶æ€æœºï¼Œæˆ‘ä»¬ä½¿ç”¨çŠ¶æ€æœºæ¥ç¡®å®šä¸‹ä¸€ä¸ªæ‰“å°å“ªä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åä½¿ç”¨condition variableæ¥ç¡®ä¿æŒæœ‰è¯¥å­—ç¬¦çš„çº¿ç¨‹è¾“å‡ºã€‚

å¯ä»¥å‘ç°ï¼Œä»£ç å®ç°ä¸­ä¸€å…±æ‹¥æœ‰ä¸‰æ¬¡é˜»å¡æœºä¼šï¼Œä¸¤æ¬¡æ˜¯futexï¼Œä¸€æ¬¡æ˜¯cv

cvä¿è¯äº†åªæœ‰

* è·å¾—è¾“å‡ºæƒé™çš„çº¿ç¨‹(quota==1)
* åœ¨çŠ¶æ€æœºä¸­æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªæœ‰æ•ˆçŠ¶æ€(next != 0)

æ—¶æ‰èƒ½è¾“å‡º

çŠ¶æ€æœºå¦‚ä¸‹

![image-20240806160443814](./assets/image-20240806160443814.png)





å…·ä½“æ¥è¯´ï¼Œç¨‹åºçš„æ€æƒ³å°±æ˜¯é€šè¿‡condition variableåŒæ­¥çº¿ç¨‹è¾“å‡º

åŒæ—¶æ³¨æ„ï¼Œä¸ºäº†ä¿è¯è¾“å‡ºæ—¶(putchar)ä¸ä¼šæœ‰å¹²æ‰°å¯¼è‡´è¾“å‡ºæ··ä¹±ï¼Œå› æ­¤æ·»åŠ äº†quotaæ¥æ ‡å¿—ä¸€ä¸ªçº¿ç¨‹æ˜¯å¦è¾“å‡ºå®Œæˆ

å³ï¼Œä½¿ç”¨fish_beforeä½œä¸ºproducerï¼Œå¦‚æœè¯¥çº¿ç¨‹æ»¡è¶³æ¡ä»¶åˆ™å…è®¸å…¶å‘å¸ƒä»»åŠ¡

ä½¿ç”¨fish_afterä½œä¸ºconsumerï¼Œç”¨æ¥ç¡®ä¿è¯¥çº¿ç¨‹è¾“å‡ºæ—¶ä¸ä¼šå—åˆ°å¹²æ‰°

ä»»åŠ¡é˜Ÿåˆ—ä»…å…è®¸ä¸€ä¸ªä»»åŠ¡



ä»£ç å¦‚ä¸‹

å¯¹äºæ¯ä¸ªçº¿ç¨‹ï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦èƒ½è·å–é”ï¼Œè·å–é”çš„çº¿ç¨‹åˆ¤æ–­è¯¥çº¿ç¨‹æŒæœ‰çš„charæ˜¯å¦æ»¡è¶³å½“å‰æ‰“å°åˆ°çš„ä½ç½®æ‰€éœ€è¦çš„æ¡ä»¶ï¼Œè‹¥æ˜¯æ»¡è¶³åˆ™æŒæœ‰è¾“å‡ºæƒï¼ˆquota--ï¼‰ï¼Œç„¶åé‡Šæ”¾é”ï¼ˆæ­¤æ—¶é‡Šæ”¾é”ï¼Œå› ä¸ºå æœ‰äº†è¾“å‡ºæƒï¼Œå› æ­¤å…¶ä»–çº¿ç¨‹ä¹Ÿæ²¡æœ‰åŠæ³•é€šè¿‡whileï¼‰

è¯¥çº¿ç¨‹è¾“å‡ºchar

è¯¥çº¿ç¨‹é‡æ–°å°è¯•è·å–é”ï¼Œå¹¶å°†è¾“å‡ºæƒå½’è¿˜ï¼ˆquota++ï¼‰ï¼Œç„¶åå”¤é†’åœ¨whileä¸­æ²‰ç¡çš„çº¿ç¨‹

```c++
#include "thread.h"

#define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

enum { A = 1, B, C, D, E, F, };

struct rule {
  int from, ch, to;
};

struct rule rules[] = {
  { A, '<', B },
  { B, '>', C },
  { C, '<', D },
  { A, '>', E },
  { E, '<', F },
  { F, '>', D },
  { D, '_', A },
};
int current = A, quota = 1;

pthread_mutex_t lk   = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  cond = PTHREAD_COND_INITIALIZER;

int next(char ch) {
  for (int i = 0; i < LENGTH(rules); i++) {
    struct rule *rule = &rules[i];
    if (rule->from == current && rule->ch == ch) {
      return rule->to;
    }
  }
  return 0;
}

void fish_before(char ch) {
  pthread_mutex_lock(&lk);
  while (!(next(ch) && quota)) {
    // can proceed only if (next(ch) && quota)
    pthread_cond_wait(&cond, &lk);
  }
  quota--;
  pthread_mutex_unlock(&lk);
}

void fish_after(char ch) {
  pthread_mutex_lock(&lk);
  quota++;
  current = next(ch);
  assert(current);
  pthread_cond_broadcast(&cond);
  pthread_mutex_unlock(&lk);
}

const char roles[] = ".<<<<<>>>>___";

void fish_thread(int id) {
  char role = roles[id];
  while (1) {
    fish_before(role);
    putchar(role); // can be long; no lock protection
    fish_after(role);
  }
}

int main() {
  setbuf(stdout, NULL);
  for (int i = 0; i < strlen(roles)-1; i++)
    create(fish_thread);
}
```



### 3.5 ä¿¡å·é‡

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›é¿å…åŒç±»çº¿ç¨‹å”¤é†’è€Œä½¿ç”¨åŒ condition variableï¼ˆæ¡ä»¶å˜é‡ï¼‰ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•ä¾èµ–äºé”çš„å­˜åœ¨ã€‚æœ‰ä¸€ç§æœºåˆ¶å¯ä»¥åœ¨ä¸ä½¿ç”¨é”çš„æƒ…å†µä¸‹ç®€å•åœ°ç»´æŠ¤ condition variableï¼Œè¿™å°±æ˜¯ä¿¡å·é‡ã€‚ä¿¡å·é‡é€šå¸¸ç”¨äºèµ„æºå‹çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ä¸­ï¼Œå¯ä»¥ä¸ä½¿ç”¨é”æ¥å®ç°åŒæ­¥ã€‚

ä¿¡å·é‡æ˜¯ä¸€ç§ç”¨äºåŒæ­¥å¹¶å‘æ“ä½œçš„æœºåˆ¶ï¼Œå®ƒçš„åº•å±‚å®ç°é€šå¸¸æ¶‰åŠä»¥ä¸‹å‡ ä¸ªå…³é”®éƒ¨åˆ†ï¼š

1. **è®¡æ•°å™¨**ï¼šä¿¡å·é‡ç»´æŠ¤ä¸€ä¸ªæ•´å‹è®¡æ•°å™¨ï¼Œç”¨äºè¡¨ç¤ºèµ„æºçš„å¯ç”¨æ•°é‡ã€‚å¯¹äºäºŒå…ƒä¿¡å·é‡ï¼ˆbinary semaphoreï¼‰ï¼Œè¿™ä¸ªè®¡æ•°å™¨è¦ä¹ˆæ˜¯0è¦ä¹ˆæ˜¯1ï¼›å¯¹äºè®¡æ•°ä¿¡å·é‡ï¼ˆcounting semaphoreï¼‰ï¼Œè¿™ä¸ªè®¡æ•°å™¨å¯ä»¥æ˜¯ä»»æ„éè´Ÿæ•´æ•°ã€‚
2. **ç­‰å¾…é˜Ÿåˆ—**ï¼šå½“ä¿¡å·é‡çš„è®¡æ•°å™¨å€¼ä¸º0æ—¶ï¼Œè¯•å›¾å‡å°ä¿¡å·é‡çš„çº¿ç¨‹ä¼šè¢«é˜»å¡å¹¶æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚ç­‰å¾…é˜Ÿåˆ—é€šå¸¸æ˜¯ä¸€ä¸ªFIFOé˜Ÿåˆ—ï¼Œä»¥ç¡®ä¿å…¬å¹³æ€§ã€‚
3. **åŸå­æ“ä½œ**ï¼šä¸ºäº†ç¡®ä¿ä¿¡å·é‡æ“ä½œçš„åŸå­æ€§ï¼Œé€šå¸¸ä¼šä½¿ç”¨ç¡¬ä»¶æä¾›çš„åŸå­æ“ä½œæŒ‡ä»¤ï¼Œå¦‚Test-and-Setã€Fetch-and-Addã€Compare-and-Swapç­‰ã€‚è¿™äº›æŒ‡ä»¤ç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯¹ä¿¡å·é‡è®¡æ•°å™¨çš„æ“ä½œæ˜¯ä¸å¯åˆ†å‰²çš„ã€‚







ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä½¿ç”¨ä¿¡å·é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹çš„ä»£ç ç¤ºä¾‹ï¼š

```c++
#include "thread.h"
#include <semaphore.h>
// ä½¿ç”¨fillå’Œemptyæ¥ä¸ºproducerå’Œconsumerç»´æŠ¤ä¸¤ä¸ªçŠ¶æ€ï¼Œå…·ä½“æ¥è¯´
// ä½¿ç”¨emptyæ¥è¡¨ç¤ºè¿˜èƒ½å‘å¸ƒçš„ä»»åŠ¡æ•°ï¼Œæ¯æ¬¡å‘å¸ƒä¸€ä¸ªä»»åŠ¡åˆ™ä¸ºfillåŠ ä¸€ï¼Œemptyå‡ä¸€
// ä½¿ç”¨fillæ¥è¡¨ç¤ºè¿˜èƒ½é¢†å–çš„ä»»åŠ¡ä¹¦ï¼Œæ¯æ¬¡é¢†å–ä»»åŠ¡fillå‡ä¸€ï¼ŒemptyåŠ ä¸€
sem_t fill, empty;

void producer() {
  while (1) {
    // é˜»å¡ç›´åˆ°emptyå¤§äº0
    // å¦‚æœemptyå¤§äº0ï¼Œå‡1ç»§ç»­
    sem_wait(&empty);
    printf("(");
	// å¢åŠ fillçš„è®¡æ•°
    sem_post(&fill);
  }
}

void consumer() {
  while (1) {
    //è°ƒç”¨ sem_wait(&fill) æ¥ç­‰å¾…å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒã€‚
    //å¦‚æœ fill ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œåˆ™å‡ 1 å¹¶ç»§ç»­ï¼›
    //å¦åˆ™ï¼Œæ¶ˆè´¹è€…ä¼šé˜»å¡ç›´åˆ° fill ä¿¡å·é‡çš„å€¼å¤§äº 0ã€‚
    sem_wait(&fill);
    printf(")");
    //è°ƒç”¨ sem_post(&empty) æ¥å¢åŠ ç©ºçš„ç¼“å†²åŒºå•å…ƒçš„è®¡æ•°ï¼Œå³å°† empty ä¿¡å·é‡çš„å€¼åŠ  1ã€‚
    sem_post(&empty);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  //ä½¿ç”¨ sem_init(&fill, 0, 0) åˆå§‹åŒ– fill ä¿¡å·é‡ä¸º 0ï¼Œè¡¨ç¤ºåˆå§‹æ—¶æ²¡æœ‰å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒ
  sem_init(&fill, 0, 0);
  //ä½¿ç”¨ sem_init(&empty, 0, atoi(argv[1])) åˆå§‹åŒ– empty ä¿¡å·é‡ä¸ºå‘½ä»¤è¡Œå‚æ•°æŒ‡å®šçš„å€¼ï¼Œè¡¨ç¤ºåˆå§‹æ—¶æœ‰å¤šå°‘ç©ºçš„ç¼“å†²åŒºå•å…ƒã€‚
  sem_init(&empty, 0, atoi(argv[1]));
  for (int i = 0; i < 8; i++) {
    create(producer);
    create(consumer);
  }
}

```

- `sem_wait(&empty)`ï¼šé˜»å¡ç›´åˆ° `empty` ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œç„¶åå°† `empty` å‡ 1ã€‚è¿™è¡¨ç¤ºç”Ÿäº§è€…ç­‰å¾…ç©ºçš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_post(&fill)`ï¼šå¢åŠ  `fill` ä¿¡å·é‡çš„å€¼ 1ã€‚è¿™è¡¨ç¤ºç”Ÿäº§è€…ç”Ÿäº§äº†ä¸€ä¸ªæ–°çš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_wait(&fill)`ï¼šé˜»å¡ç›´åˆ° `fill` ä¿¡å·é‡çš„å€¼å¤§äº 0ï¼Œç„¶åå°† `fill` å‡ 1ã€‚è¿™è¡¨ç¤ºæ¶ˆè´¹è€…ç­‰å¾…å·²å¡«å……çš„ç¼“å†²åŒºå•å…ƒã€‚
- `sem_post(&empty)`ï¼šå¢åŠ  `empty` ä¿¡å·é‡çš„å€¼ 1ã€‚è¿™è¡¨ç¤ºæ¶ˆè´¹è€…æ¶ˆè´¹äº†ä¸€ä¸ªç¼“å†²åŒºå•å…ƒï¼Œä½¿å…¶å˜ä¸ºç©ºã€‚

é€šè¿‡ä½¿ç”¨ä¿¡å·é‡ï¼Œå¯ä»¥æœ‰æ•ˆåœ°ç®¡ç†ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´çš„åŒæ­¥ï¼Œè€Œæ— éœ€ä½¿ç”¨é”ã€‚è¿™ç§æ–¹æ³•ç®€åŒ–äº†ä»£ç ï¼Œå¹¶ä¸”åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥æé«˜æ€§èƒ½ã€‚

* `int sem_init(sem_t *sem, int pshared, unsigned int value)`: 
  * semæŒ‡å‘ä¿¡å·é‡å¯¹è±¡çš„æŒ‡é’ˆï¼Œ
  * psharedæŒ‡ç¤ºä¿¡å·é‡æ˜¯ç”¨äºè¿›ç¨‹é—´å…±äº«è¿˜æ˜¯çº¿ç¨‹é—´å…±äº«
    * pshared=0ä»£è¡¨ä¿¡å·é‡çº¿ç¨‹é—´å…±äº«ï¼Œä»…èƒ½å¤Ÿåœ¨å•ä¸ªè¿›ç¨‹çš„çº¿ç¨‹é—´ä½¿ç”¨
    * pshared=1ä»£è¡¨ä¿¡å·é‡è¿›ç¨‹é—´å…±äº«
  * `value`è¡¨ç¤ºèµ„æºçš„åˆå§‹å¯ç”¨æ•°é‡
  * æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1å¹¶è®¾ç½®`errno`æŒ‡ç¤ºé”™è¯¯





### ä¿¡å·é‡ä¸æ¡ä»¶å˜é‡



ä¿¡å·é‡æ›´é€‚åˆåœ¨==è®¡æ•°èµ„æº==æƒ…å†µä¸‹å–ä»£æ¡ä»¶å˜é‡ã€‚

* ä¿¡å·é‡æ›´é€‚åˆç”¨äºè®¡æ•°èµ„æºçš„å¯ç”¨æ€§ï¼ˆå¦‚æœ‰å¤šå°‘ç©ºç¼“å†²åŒºå•å…ƒï¼‰ã€‚

  ä¿¡å·é‡é€šå¸¸å®ç°é€šå¸¸è¾ƒä¸ºç®€å•ï¼Œå®ƒé€šè¿‡å¯¹ä¸€ä¸ªè™šæ‹Ÿèµ„æºæ± çš„ç»´æŠ¤æ¥å®ç°ç±»ä¼¼é”çš„æ•ˆæœã€‚å®ƒé€šå¸¸ä¸æ¶‰åŠå…±äº«å˜é‡ï¼Œè€Œåªæ˜¯ç»´æŠ¤ä¸€ä¸ªè™šæ‹Ÿæƒé™çš„åˆ†é…ã€‚

```c++
sem_t empty, full, mutex;

void producer() {
    while (1) {
        sem_wait(&empty);
        // ç”Ÿäº§äº§å“
        sem_post(&full);
    }
}

void consumer() {
    while (1) {
        sem_wait(&full);
        // æ¶ˆè´¹äº§å“
        sem_post(&empty);
    }
}

```



* æ¡ä»¶å˜é‡æ›´é€‚åˆç”¨äºç­‰å¾…æŸä¸ªç‰¹å®šçš„çŠ¶æ€æˆ–æ¡ä»¶ã€‚

  æ¡ä»¶å˜é‡é€šå¸¸ä¼šç»´æŠ¤ä¸€ä¸ªå…±äº«å˜é‡ï¼Œå› æ­¤å¿…é¡»æ­é…é”æ¥å®ç°ã€‚å®ƒä¸æ­¢èƒ½å¤Ÿå®Œæˆè™šæ‹Ÿæƒé™çš„åˆ†é…ï¼ˆè®¡æ•°çš„èµ„æºï¼‰ï¼Œä¹Ÿèƒ½å¤Ÿå®Œæˆå¤æ‚çŠ¶æ€çš„ç»´æŠ¤ã€‚

```c++
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond_producer = PTHREAD_COND_INITIALIZER;
pthread_cond_t cond_consumer = PTHREAD_COND_INITIALIZER;
int count = 0;
int buffer_size = 10;

void producer() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (count == buffer_size) {
            pthread_cond_wait(&cond_producer, &mutex);
        }
        // ç”Ÿäº§äº§å“
        count++;
        pthread_cond_signal(&cond_consumer);
        pthread_mutex_unlock(&mutex);
    }
}

void consumer() {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (count == 0) {
            pthread_cond_wait(&cond_consumer, &mutex);
        }
        // æ¶ˆè´¹äº§å“
        count--;
        pthread_cond_signal(&cond_producer);
        pthread_mutex_unlock(&mutex);
    }
}

```













### 3.6 å“²å­¦å®¶åƒé¥­é—®é¢˜:ä¿¡å·é‡çš„å±€é™



#### é—®é¢˜æè¿°

è¿™æ˜¯å¦ä¸€ä¸ªç»å…¸çš„å¹¶å‘é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜è¦æ±‚ä¸¤ä¸ªé”çš„æŒæœ‰æƒ

![image-20240807134707394](./assets/image-20240807134707394.png)



#### ä¿¡å·é‡è§£æ³•

ä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯ä½¿ç”¨å®¹é‡ä¸º1çš„ä¿¡å·é‡æ¥ä¸ºæ¯ä¸ªå‰å­ä¸Šé”

```c++
#include "thread.h"
#include <semaphore.h>

#define N 3

sem_t locks[N];

// id in {1,2,...}
void Tphilosopher(int id){
    int lhs = (id - 1) % N;
    int rhs = (id) % N;
    
    while(1){
        sem_wait(&locks[lhs]);
        printf("T%d Got %d\n", id, lhs + 1);
        sem_wait(&locks[rhs]);
        printf("T%d Got %d\n", id, rhs + 1);
        
        sem_post(&locks[lhs]);
        sem_post(&locks[rhs]);
    }
}

int main(int argc, char *argv[]){
    for(int i = 0; i < N; i++){
        sem_init(&locks[i],0,1)
    }
    
    for(int i = 0; i < N; i++){
        create(Tphilosopher);
    }
}



```

å¯ä»¥å‘ç°ï¼Œå¾ˆå¿«å¡æ­»ï¼Œè¿™æ˜¯å› ä¸ºå¾ˆå®¹æ˜“å‡ºç°ä¸€ä¸ªæƒ…å†µï¼Œæ¯ä¸ªäººéƒ½æ‹¿äº†ä¸€ä¸ªå‰å­ï¼Œè¿™æ ·å°±æ­»é”äº†

![image-20240807143705674](./assets/image-20240807143705674.png)



ä¿¡å·é‡åªèƒ½å¤„ç†å•ä¸€èµ„æºçš„åˆ†é…ï¼Œè¿™é‡Œå¤šèµ„æºåˆ†é…å°±è¿‡äºå¤æ‚äº†ã€‚è¿˜å¥½ï¼Œæœ‰ä¸‡èƒ½çš„æ–¹æ³•ï¼Œå°±æ˜¯cvã€‚





#### condition variableè§£æ³•

ä¸€ä¸ªç®€å•çš„æƒ³æ³•å°±æ˜¯ç”¨ä¸€ä¸ªé”==å…è®¸ä¸€ä¸ªäººç”¨é¤==ï¼ˆå³ä¸ºè®¾ç½®availableä¸ºfalseï¼Œå³åˆ†é…ä»»åŠ¡ï¼‰ï¼Œç„¶åè®©è¿™ä¸ªäººç”¨é¤ï¼ˆä¹Ÿå°±æ˜¯å¤„ç†ä»»åŠ¡ï¼‰ï¼Œç­‰å¾…å®ƒå®Œæˆä»»åŠ¡åï¼Œå®ƒä¼šå†æ¬¡å°è¯•è·å–é”ï¼Œå°†å‰å­è¿˜å›å»ï¼ˆé‡ç½®ä»»åŠ¡æ± ï¼‰ï¼Œæ³¨æ„æ­¤æ—¶å› ä¸ºå‰å­å·²ç»å¯ç”¨ï¼Œæ‰€ä»¥å¯ä»¥å”¤é†’é‚£äº›æ²‰ç¡çº¿ç¨‹äº†ã€‚

```c++
#include "thread.h"
#include <semaphore.h>
#include <stdio.h>
#include<string.h>
#define N 3

pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lk = PTHREAD_MUTEX_INITIALIZER;

int available[N];

void Tphilosopher(int id) {
  int lhs = (id - 1) % N;
  int rhs = id % N;
  while (1) {
    pthread_mutex_lock(&lk);
    while(!(available[lhs] && available[rhs])){
        pthread_cond_wait(&cv, &lk);
    }
    available[rhs] = 0;
    available[lhs] = 0;

    pthread_mutex_unlock(&lk);


    printf("T%d Got %d\n", id, lhs + 1);
    printf("T%d Got %d\n", id, rhs + 1);


    pthread_mutex_lock(&lk);
    available[rhs] = 1;
    available[lhs] = 1;
    pthread_cond_broadcast(&cv);
    pthread_mutex_unlock(&lk);
  }
}

int main(int argc, char *argv[]) {

  memset(available, 1, sizeof(available));
  for (int i = 0; i < N; i++) {
    create(Tphilosopher);
  }
}
```





==æœ‰é€šç”¨çš„å°±åˆ«æ•´ç²¾å·§çš„æ–¹æ³•äº†ï¼Œå¤ªéš¾äº†==

è¿™ä¸ªæ–¹æ³•ä½¿ç”¨çš„æ˜¯æ¯ä¸ªPhilosopherè‡ªå‘çš„å»ç”³è¯·å‰å­çš„ä½¿ç”¨æƒï¼Œå®é™…ä¸Šæˆ‘ä»¬ä¹‹å‰è¯´è¿‡äº†ï¼Œ99%çš„å¹¶å‘é—®é¢˜éƒ½å¯ä»¥ä½¿ç”¨ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹æ¥è§£å†³ã€‚









#### ç”Ÿäº§è€…æ¶ˆè´¹è€…çš„ä¸€ç§ï¼šMaster-Slaveè§£æ³•

è¿™é‡Œæˆ‘ä»¬è®¾ç½®**ä¸€ä¸ª**ç”Ÿäº§è€…ï¼ˆMasterï¼‰æ¥åˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿåˆ†å‘å‰å­ï¼Œå’Œ**Nä¸ªPhilosopher**ï¼ˆSlaveï¼‰æ¥å—Masterçš„è°ƒåº¦

è¿™æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿä¸­éå¸¸å¸¸è§çš„è§£å†³æ€è·¯ï¼Œå› ä¸ºè¿™é‡Œæœ‰å¾ˆå¤§çš„æ“ä½œç©ºé—´ï¼ŒMasterèƒ½å¤Ÿæ–¹ä¾¿çš„è®¾ç½®ä¼˜å…ˆçº§å’Œåå¥½ï¼ˆä¾‹å¦‚æœ‰äººä¸Šä¸€æ¬¡åƒé¥­ç”¨äº†å¾ˆä¹…ï¼Œä¸‹ä¸€æ¬¡å¯èƒ½æˆ‘å°±åå‘äºæ”¶åˆ°å®ƒçš„è¯·æ±‚ä¹‹åæ™šä¸€äº›ç»™ä»–å‰å­çš„æƒé™ï¼‰

å¤§ä½“æ€è·¯å¦‚ä¸‹

```c++
void Tphilosopher(int id){
    send_request(id, EAT);
    P(allowed[id]);
    philosopher_eat();
    send_request(id,DONE);
}

void Twaiter(){
    while(1){
        (id,status) = reveive_request();
        if(status == EAT){}
        if(status == DONE){}
    }
}
```

è¿™é‡Œå­˜åœ¨å‡ ä¸ªåŠ¨ä½œ

* Philosopherè¯·æ±‚æ‹¿å‰å­ï¼Œè¿™ä¸ªåŠ¨ä½œå¿…é¡»åŠ é”ï¼Œå› ä¸ºè¿™ä¸ªåŠ¨ä½œä¸ä»…ä¿®æ”¹äº†philosopheræœ¬èº«çš„è¯·æ±‚çŠ¶æ€ï¼ŒåŒæ—¶ä¹Ÿä¿®æ”¹äº†ä¸€ä¸ªå…±äº«å˜é‡ï¼ˆrequest_idï¼Œç”¨äºé€šçŸ¥waiterï¼‰
* Philosopherç­‰å¾…waiterï¼ˆæœåŠ¡ç”Ÿ/Masterï¼‰å…è®¸ï¼Œè¿™æ˜¯ä¸€ä¸ªäºŒå…ƒå˜é‡ï¼Œå¯ä»¥ä¿¡å·é‡æ¥ç»´æŠ¤ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨condition variableç»´æŠ¤
* Philosopherè¯·æ±‚è¿˜å‰å­ï¼Œè¿™ä¸ªåŠ¨ä½œåŒç†
* waiterè·å–è¯·æ±‚ï¼Œ

























































































## å¹¶å‘ç¨‹åºè°ƒè¯•

ä½¿ç”¨.pyéå†çŠ¶æ€æ ‘

> https://www.bilibili.com/video/BV15T4y1Q76V/?spm_id_from=333.788&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9
>
> 55:18

Model Checkerçš„é€šå¸¸**å‡è®¾æ˜¯æ¯ä¸€è¡Œçš„æ“ä½œæ˜¯åŸå­çš„**ï¼ˆæˆ–è€…ä¹Ÿå¯ä»¥æ‰‹åŠ¨åŒ…å«è‹¥å¹²ä¸ªè¿ç»­æ“ä½œä¸ºåŸå­çš„ï¼‰ï¼Œç„¶åé€šè¿‡generatorçš„æ–¹å¼è·å–çŠ¶æ€é˜Ÿåˆ—ã€‚