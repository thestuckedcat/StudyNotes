# 13. 面向对象编程-类与对象

* 什么是面向对象编程
* 什么是类与对象
* 声明类与创建对象
* `.`与指针操作符
* 公有和私有访问编辑器
* Methods, Constructors（构造函数） and Destructors（析构函数）
  * 类方法(class method)
  * default and overloaded constructors
  * copy and move constructors
  * shallow vs. deep copying
  * `this` pointer
* static 类成员
* struct vs class
* 类的友元

## 13.1 面向对象与面向过程

**面向过程编程 (Procedural Programming)**:

**优点**:

1. **简单性**：对于简单的、小型的程序，面向过程的方法可能更直观。
2. **执行效率**：由于没有额外的抽象层，面向过程的代码在某些情况下可能运行得更快。
3. **直接性**：代码通常按照它们在源文件中的顺序执行，这使得流程容易理解。

**缺点**:

1. **可扩展性**：随着项目的增长，面向过程的代码可能变得难以管理和扩展。
2. **代码重用**：可能会有大量的代码重复，因为面向过程的方法不鼓励代码重用。
3. **维护性**：随着时间的推移，可能会变得更加困难，特别是当涉及到大型项目时。

**面向对象编程 (Object-Oriented Programming, OOP)**:

**优点**:

1. **模块化**：代码更加组织化，每个对象都有其特定的行为和属性。
2. **代码重用**：通过继承和多态，可以轻松地重用和扩展现有的代码。
3. **可扩展性**：添加新的功能或修改现有功能变得相对容易。
4. **抽象性**：能够模拟现实世界的情境和对象，使得设计和理解更为直观。
5. **维护性**：由于其模块化的特性，OOP 代码更易于维护。

**缺点**:

1. **复杂性**：对于简单的程序，OOP 可能会引入不必要的复杂性。
2. **性能开销**：由于额外的抽象层，OOP 代码可能在某些情况下比面向过程的代码慢。
3. **学习曲线**：对于初学者来说，理解 OOP 的概念可能需要一些时间。

**为什么我们需要面向对象编程**:

1. **现实世界映射**：OOP 允许我们在代码中模拟现实世界的对象和情境，这使得设计和理解更为直观。
2. **大型项目管理**：对于大型和复杂的软件项目，OOP 提供了更好的组织和管理工具。
3. **代码重用和扩展**：OOP 的继承和多态特性使得代码重用和扩展变得更加容易。
4. **维护性**：随着软件的生命周期延长，OOP 代码的模块化和组织化特性使得维护变得更加简单。
5. **团队合作**：OOP 的模块化特性使得团队成员可以并行工作在不同的类和对象上，而不会干扰到其他人的工作。

总的来说，面向对象编程提供了一种更加结构化和模块化的方法来组织和设计软件，特别是对于大型和复杂的项目。

## 13.2 类与对象

### 13.2.1 Classes

* 类是对象创建的蓝本
* 类好像是一个用户定义的数据类型
* 类中包含attributes(data)以及methods(functions)
* 类可以隐藏仅类内部使用的data和function
* 类的目标是提供一个定义良好的公共接口，类的用户可以轻松使用该接口解决问题

### 13.2.2 Objects

* 对象由类创建
* 对象代表了类的一个实例(a specific instance of a class)
* 一个类可以创建很多实例
* 每个实例有其自己独有的标识
* 每个实例都可以使用定义好的class method



## 13.3 声明一个类

```c++
class player{
    // attributes
    std::string name;
    int health;
    int xp;
    
    //methods
    void talk(std::string text_to_say);
    bool is_dead();
}
```



## 13.4 生成一个实例

```c++
//普通实例
player frank;
player hero;

//动态分配实例
player *enemy{nullptr};
enemy = new player();//create on the heap
delete enemy;

//实例数组
player players[]{frank, hero};//frank 和 hero 必须在这个声明之前已经被定义。
std::vector<player> players1{frank};
players1.push_back(hero);
```



## 13.5 访问类成员

* We can access
  * class attributes
  * class methods
* 一些类成员not be accessible



```c++
//variable create on stack
player frank;
player.xp;// access to attributes
player.talk();// accesss to methods

//variable create on heap
(*enemy).xp;
(*enemy).talk();

enemy -> xp;
enemy -> talk();
```

==以上的例子仅作示范，通常来说，类中这些信息都是私有的，我们无权访问，我们会在下一节讲解==



## 13.6 Access Modifiers:类成员访问修饰符

* public
  * accessible everywhere
* private
  * accessible only by members or friends of the class
* protected
  * 用于继承

从AccessModifier之后，到遇见另一个不同的之前，所有的声明都服从该Modifier。

```c++
class Class_name
{
    public:
    //declaration(s)
};
```



## 13.7 创建类方法(implementing member methods)

在C++中，类成员函数（通常称为方法）可以在类定义内部（内联）声明和定义，也可以在类定义外部定义。这两种方式有其各自的特点和用途：

1. **在类内部声明和定义（Inline）**:

   - 当你在类定义内部提供成员函数的实现时，==该函数默认为内联函数==。

   - 内联函数的代码在编译时会嵌入到每个调用点，这可能会提高执行速度，但可能增加生成的代码的大小。

   - ==适用于简短的、频繁调用的函数，如访问器和修改器==。

   - 代码示例：

     ```c++
     class MyClass {
     public:
         void myMethod() {
             // ... function implementation
         }
     };
     ```

2. **在类外部定义**:

   - 在类定义外部提供成员函数的实现可以使类定义更加简洁和清晰。

   - 这种方式不会自动将函数视为内联函数，但你可以通过在函数定义前加上`inline`关键字来显式地将其标记为内联。

   - ==适用于函数实现较长或需要与其他类或函数交互的函数==。

   - 代码示例：

     ```c++
     class MyClass {
     public:
         void myMethod();
     };
     
     void MyClass::myMethod() {
         // ... function implementation
     }
     ```

**注意**：==无论选择哪种方式，成员函数的声明都必须在类定义内部进行==。

**总结**：

- 在类内部定义的函数默认为内联，可能会提高执行速度，但可能增加代码大小。适用于简短的函数。
- 在类外部定义的函数可以使类定义更加简洁，适用于较长的函数实现。
- 选择哪种方式取决于具体的设计考虑和函数的用途。

### 13.7.1 Inside the class declaration

```c++
class Account{
private:
    double balance;
public:
    void set_balance(double bal){
        // 这个public的方法可以访问private的数值，间接的帮助全局范围改变了private数值
        balance = bal;
    }
    double get_balance(){
        return balance;
    }
}
```

### 13.7.2 Outside the class declaration

```c++
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
    double get_balance();
}

void Account::set_balancec(double bal){
    balance = bal;
}

double Account::get_balance(){
    return balance;
}
```



### 13.7.3 Include guard

* 复杂的类通常声明在头文件中，并有一个专门的cpp文件实现

* 头文件可能会被多次包含

  * **直接多次包含**：这是最简单的情况，可能是由于疏忽或其他原因，开发者在同一个源文件中多次`#include`了同一个头文件。

    ```c++
    #include "some_header.h"
    #include "some_header.h"
    ```

  * **间接多次包含**：当一个头文件A包含头文件B，而源文件或另一个头文件C也包含头文件B时，头文件B会被间接地多次包含。

    ```c++
    // A.h
    #include "B.h"
    
    // C.h or C.cpp
    #include "A.h"
    #include "B.h"
    ```

    在这种情况下，当我们包含A.h和C.h（或C.cpp）时，B.h会被包含两次。

  * **多个源文件**：当多个源文件都包含同一个头文件时，这个头文件会在每个源文件的编译单元中被包含。这不会导致重复定义的错误，但如果头文件很大，可能会影响编译时间。

  * **条件编译**：有时，开发者可能会使用预处理器的条件编译功能来决定是否包含一个头文件。如果条件在多个地方都满足，头文件可能会被多次包含。

    ```c++
    #ifdef SOME_CONDITION
    #include "some_header.h"
    #endif
    
    // ... some code ...
    
    #ifdef ANOTHER_CONDITION
    #include "some_header.h"
    #endif
    ```

  * **模板和内联函数**：当头文件包含模板或内联函数的定义时，为了正确地编译它们，这些头文件需要在每个使用它们的源文件中被包含。

  为了避免由于多次包含头文件而导致的问题，通常使用`#include` guards或`#pragma once`（如果编译器支持）来确保头文件的内容在每个编译单元中只被包含一次。



`#include` guards（也称为头文件保护或预处理器保护）是C和C++编程中用于防止头文件被多次包含的预处理器宏。当一个头文件被多次包含时，它可能会导致重复的定义，从而引发编译错误。为了避免这种情况，我们使用`#include` guards。

#### 13.7.3.1 使用ifdefine

##### 如何工作？

`#include` guards基于预处理器的条件编译功能。它们通常使用`#ifndef`、`#define`和`#endif`指令。

##### 使用方法：

1. 在头文件的开始，使用`#ifndef`检查一个特定的宏（通常是一个唯一的名称）是否已经定义。
2. 如果该宏尚未定义，则使用`#define`定义它。
3. 在文件的末尾，使用`#endif`结束条件编译。

##### 示例：

假设我们有一个名为`my_header.h`的头文件：

```c++
#ifndef MY_HEADER_H
#define MY_HEADER_H

// Your header file content goes here

#endif // MY_HEADER_H
```

在这个例子中，`MY_HEADER_H`是一个宏，它在文件首次被`#include`时被定义。如果在同一个编译单元中再次尝试包含这个头文件，`#ifndef`检查将失败，因为`MY_HEADER_H`已经被定义，所以文件的内容不会再次被包含。

##### 优点：

1. **防止重复包含**：这是`#include` guards的主要目的。它们确保头文件中的内容在给定的编译单元中只被包含一次。
2. **减少编译时间**：通过防止不必要的重复包含，可以稍微减少编译时间。

##### 注意事项：

1. **唯一性**：确保每个头文件的宏名称是唯一的，以避免与其他头文件冲突。
2. **不要在源文件中使用**：`#include` guards主要用于头文件。在源文件中使用它们通常没有意义，因为源文件不应该被其他文件包含。
3. **`#pragma once`**：某些编译器提供了`#pragma once`指令，它是`#include` guards的一个现代替代方案。当编译器看到这个指令时，它会确保文件只被包含一次。但是，它不是标准的C++，并且不是所有编译器都支持它。

总之，`#include` guards是C++编程中的一个基本技术，用于确保头文件不被多次包含，从而避免重复定义和其他相关的编译问题。

#### 13.7.3.2 使用Pragma once

会有编译器不支持

```c++
//Account.h
    
# pragma once
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
	double get_balance();
}

```

### 13.7.4 使用headfile创建复杂类

==永远include .h 文件，而非include .cpp文件==

> Account.h

```c++
    
# pragma once
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
	double get_balance();
}

```

> Account.cpp

```c++
#include"Accound.h"

void Account::set_balance(double bal){
    balance = bal;
}

double Account::get_balance(){
    return balance;
}
```

> main.cpp

```c++
#include<iostream>
#include"Account.h"

int main(){
    Account frank_account;
    frank_account.set_balance(1000.00);
    double bal = frank_account.get_balance();
    
    std::cout << bal << std::endl;//1000
    return 0;
}
```

#### headfile中的禁忌

在头文件中使用`using namespace`是不推荐的，原因如下：

1. **污染命名空间**：当你在头文件中使用`using namespace`，你实际上是将该命名空间中的所有符号引入到任何包含该头文件的文件中。这可能会导致命名冲突和意外的名字解析。
2. **不可预测的行为**：由于头文件可能会被多个源文件包含，使用`using namespace`可能会导致不同的源文件有不同的命名解析行为，这取决于它们包含头文件的顺序和方式。
3. **降低代码可读性**：当读者查看一个源文件并看到一个未知的标识符时，他们可能会猜测这个标识符来自哪个命名空间。如果头文件中使用了`using namespace`，这会使得追踪标识符的来源变得更加困难。
4. **维护困难**：随着时间的推移，命名空间中可能会添加新的符号。这可能会导致之前工作正常的代码突然出现命名冲突或其他错误。
5. **降低代码的可移植性**：如果你决定将你的头文件分享给其他人或用于其他项目，使用了`using namespace`的头文件可能会导致其他代码出现问题。

为了避免这些问题，推荐的做法是在头文件中避免使用`using namespace`，并在实现文件中明确指定所需的命名空间，例如`std::vector`而不是简单地`vector`（在使用`using namespace std;`后）。这样可以确保代码的清晰性、可维护性和可移植性。

## 13.8 构造函数与析构函数(Constructors and Destructors)

### 13.8.1 构造函数Constructors

* 构造函数是一个特别的member method
* 构造函数在对象被==创建==时会被自动援引(invoked)
* 构造函数常常用于初始化
* 构造函数名与类名一致
* 构造函数没有返回类型
* 构造函数可以重载

```c++
class Player
{
private:
    std::string name;
    int health;
    int xp;
public:
    //overloaded constructors
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
    
}
```

#### Default Constructor

* Default Constructor不期望任何输入(即no-args constructor)
* 如果没有特别写一个constructor，C++会自动生成一个什么都不做的Default Constructor
* Default Constructor会在你创建一个新对象并且没有传参时被自动调用

```c++
Player frank;
Player *enemy = new Player;
```

==当然，一旦我们自己设置了一个带args的Constructor，以上这种声明就会出错，因为编译器不会为你生成一个default constructor，constructor只存在你申请的那个。==

事实上，我们最好自己定义无参数构造函数

```c++
class Player
{
private:
    std::string name;
    double balance;
public:
    Player(){
        name = "None";
        balance = 0.0;
    }
    bool withdraw(double amount);
    bool deposit(double amount);
}
```



### 13.8.2 析构函数Destructors

* 析构函数是一个特殊的member method
* 析构函数名与类名一致，不过前面有一个`~`

* 析构函数将在一个对象被==销毁==时自动援引
  * 当local object超出作用域时
  * 当指针对象被delete时
* 析构函数没有返回类型，==没有参数==
* 每个类只能有一个析构函数，==并且不能被重载==
* 常用于释放内存和其他资源

```c++
class Player
{
private:
    std::string name;
    int health;
    int xp;
public:
    //overloaded constructors
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
    //Destructor
    ~Player();
    
}
```

#### 13.8.2.1 常见析构函数内部作用

析构函数是一个特殊的成员函数，当一个对象的生命周期结束时，它会被自动调用。析构函数的主要目的是执行任何必要的清理工作，以确保对象被正确地销毁。以下是通常在析构函数中执行的一些操作：

1. **释放动态分配的内存**：如果类的对象分配了堆上的内存（通常使用`new`），析构函数应确保这些内存被释放（使用`delete`或`delete[]`）。

   ```c++
   class MyClass {
   private:
       int* data;
   public:
       MyClass(int size) {
           data = new int[size];
       }
       ~MyClass() {
           delete[] data;
       }
   };
   ```

2. **关闭文件或网络连接**：如果对象持有文件句柄或网络连接，析构函数应确保它们被正确关闭。

3. **解除资源的锁定**：如果对象持有某些资源的锁（例如，多线程编程中的互斥锁），析构函数应确保锁被释放。

4. **销毁其他资源**：例如，如果对象使用了某些操作系统特定的资源（如句柄、线程或进程），析构函数应确保这些资源被正确销毁。

5. **通知其他对象**：有时，对象的销毁可能需要通知其他对象。例如，如果对象是某个观察者模式中的观察者，它可能需要在被销毁时从主题中注销。

6. **调用基类的析构函数**：这实际上是自动完成的，但值得注意的是，派生类的析构函数在执行完其内容后会自动调用其基类的析构函数。

需要注意的是：

- 析构函数不接受任何参数，也没有返回值。
- 你不能直接调用析构函数（尽管有一些特殊情况可以）。它是由编译器自动调用的，通常在对象超出作用域或被`delete`时。
- 如果你没有为类提供析构函数，编译器会为你生成一个默认的析构函数。但如果类管理资源（如动态内存），则应提供自定义的析构函数以确保正确清理。

总之，析构函数的主要任务是确保对象的正确、安全和完整的销毁，以及释放它使用的所有资源。

### 13.8.3 创建对象与销毁对象

```c++
{
    Player slayer;
    Player frank {"Frank", 100, 4};
    Player hero {"Hero"};
    Player villain {"Villain"};
}// 4 destructors called

Player *enemy  = new Player("Enemy", 1000, 0);
delete enemy;// destructor called
```

==当对象超出作用域时，析构函数的调用顺序和它们的创建顺序相反==

### 13.8.4 Constructor Initialization Lists(构造函数初始化列表)

* ==**支持初始化`const`成员**：`const`成员变量一旦被初始化就不能被修改。因此，你必须在构造函数初始化列表中初始化它们。对于类的常量成员和引用成员==，你必须使用初始化列表，==因为它们不能在构造函数体内赋值。==
* **避免额外的构造函数调用**：如果不使用初始化列表，对象的成员会先被默认构造，然后在构造函数体中被赋新的值。这可能导致不必要的构造函数调用，尤其是对于复杂的对象或容器。==使用初始化列表可以直接初始化成员，而不是先默认构造然后再赋值，这可以提高效率。==
  * 原本：allocating things$\rightarrow$Deallocating thing$\rightarrow$ assignment
  * 现在：allocating things$\rightarrow$ 
* **对于基类初始化**：如果你的类从一个基类继承，你可以使用初始化列表来调用基类的构造函数。
* **更好的编译时检查**：使用初始化列表可以确保所有成员都被正确初始化。这在某些情况下可以提供更好的编译时检查，尤其是当类有多个构造函数且成员需要在每个构造函数中都被初始化时。
* **支持不可默认构造的成员**：==有些类成员可能没有默认构造函数==（例如，它们只有带参数的构造函数）。在这种情况下，你必须使用初始化列表来初始化这些成员。

**No args Construct**：

```c++
//Previous way
Player::Player(){
    name = "None";
    health = 0;
    xp = 0;
}

//Better way
Player::Player()
    :name{"None"},health{0},xp{0}{
        
    }
```

* Initialize List 在初始化构造函数名之后，主体函数之前
* 初始化成员的顺序不一定是我们在初始化列表中提供的顺序，数据成员将按照在类声明中声明的顺序进行初始化。

**With Args Construct**:

```c++
//Previous way
Player::Player(std::string name_val){
    name = name_val;
    health = 0;
    xp = 0;
}

// Better way:
Player::Player(std::string name_val)
    :name{name_val},health{0},xp{0}{
        
    }
```

### 13.8.5 Delegating Constructors:委托构造函数

委托构造函数 (Delegating Constructors) 是在 C++11 中引入的，它允许一个构造函数调用同一类中的另一个构造函数。这个特性有助于减少构造函数之间的代码重复，并确保类的所有构造函数都可以集中到执行必要初始化的主构造函数中。

==委托构造函数的逻辑通常就是选择所有构造函数的传入参数的并集，先使用初始化列表实现它，作为主构造函数，然后对每一个重载的构造函数，按顺序填入即可，所传入的参数填入，其他填入默认值==

```c++
class Player {
private:
    std::string name;
    int health;
    int xp;
public:
    // 主构造函数
    Player(std::string name_val, int health_val, int xp_val) 
        : name{name_val}, health{health_val},xp{xp_val}
    {
        // 初始化逻辑
    }

    // 委托构造函数：默认构造函数
    Player()
        : Player{"None",0,0}{
            
        }

    //
    Player(std::string name_val)
        : Player{name_val,0,0}{
            
        }
};
```

* 委托构造函数使得我们在重载构造函数时更加简便

* 委托构造函数仅在初始化列表中有效，不能从委托构造函数的主体内部调用其他构造函数。

  * 例如，以下是正确的使用方法：

    ```c++
    class MyClass {
    public:
        MyClass(int a) : value{a} { }  // 主构造函数
    
        MyClass() : MyClass{0} { }    // 委托构造函数
    private:
        int value;
    };
    ```

    而以下的使用方法是错误的：

    ```c++
    class MyClass {
    public:
        MyClass(int a) : value{a} { }  // 主构造函数
    
        MyClass() {
            MyClass{0};  // 这是错误的！你不能在委托构造函数的主体中这样调用其他构造函数
        }
    private:
        int value;
    };
    
    ```

 





### 13.8.6 Default Constructor parameter

* 使用默认构造参数能够避免使用函数重载，但这不代表了使用默认构造参数就不能使用函数重载，只要保证编译器在调用构造函数时没有歧义即可，见注释

* ==C++的默认构造参数只支持按顺序的传参，不能说仅传入顺序第三个参数。这部分限制了default constructor的使用，但是这仍然是一个好方法==

  

```c++
Class Player{
private:
    std::string name;
    int health;
    int xp;
public:
    Player(std::string name_val = "None",int health_val = 0, int xp_val = 0);
}

Player::Player(std::string name_val, int health_val, int xp_val)
	:name{name_val}, health{health_val}, xp{xp_val}
{
    
}

int main(){
	Player empty;
	Player frank{"Frank"};
	Player villain{"Villain", 100, 50};
}




```

> 确保函数重载之间没有歧义的关键是确保在任何给定的调用情境下，编译器都能清晰地确定应该调用哪个函数版本。当使用默认参数时，这可能会变得复杂，因为默认参数可能会导致某些调用形式与多个函数版本匹配。
>
> 让我们通过一个例子来说明这一点：
>
> ```c++
> class MyClass {
> public:
>     MyClass(int a, int b = 10) {
>         // Constructor code
>     }
> 
>     MyClass(double a) {
>         // Another constructor code
>     }
> };
> ```
>
> 在上述代码中，我们有两个构造函数。第一个接受两个整数参数，其中第二个参数有一个默认值。第二个构造函数接受一个双精度浮点数参数。
>
> 以下是一些示例调用：
>
> 1. `MyClass obj1(5);` - 这是明确的。尽管第一个构造函数可以通过其默认参数来匹配这个调用，但第二个构造函数是一个更好的匹配，因为它只需要一个参数。
> 2. `MyClass obj2(5, 6);` - 这也是明确的。只有第一个构造函数匹配这个调用。
> 3. `MyClass obj3(5.0);` - 这同样是明确的。只有第二个构造函数匹配这个调用，因为它接受一个双精度浮点数参数。
>
> 在这个例子中，尽管我们使用了默认参数，但我们确保了每种可能的调用形式都只与一个构造函数版本匹配，从而避免了歧义。
>
> 然而，如果我们添加了以下构造函数：
>
> ```c++
> MyClass(int a = 0);
> ```
>
> 那么调用 `MyClass obj(5);` 就会变得模糊不清，因为它可以匹配两个构造函数：`MyClass(int a, int b = 10)` 和 `MyClass(int a = 0)`。这种情况下，编译器会报错，因为它不能确定应该调用哪个构造函数。
>
> 总之，确保重载函数之间没有歧义的关键是仔细考虑每种可能的调用形式，并确保每种形式都只与一个函数版本匹配。





### 13.8.7 Copy Constructor

#### 13.8.7.1 什么是Copy Constructor

* C++在对象被复制时会由已有对象创建一个新的对象作为对象的副本，为了应对==对象被复制==的情况，引入了Copy Constructor

* 具体来说，在以下几个场景使用居多

  * 将对象传参(Pass Object by value)

    * ```c++
      Player hero {"Hero", 100, 20};
      
      void display_player(Player p){
          // p is a copy of hero in this example
          // use p
          // Destructor for p will be called
      }
      
      display_player(hero);
      ```

  * 函数返回一个对象时的赋值

    * ```c++
      Player enemy;
      
      Player create_super_enemy(){
          Player an_enemy{"Super Enemy", 1000, 1000};
          return an_enemy; // A COPY of an_enemyis returned
      }// destructor of an_enemy is called
      
      enemy = create_super_enemy();
      ```

  * 我们想基于同一个类的一个已有对象创建一个副本（以用于其他操作）

* 我们可以提供自己的复制构造函数，并==精确定义对象复制所需要的语义==（如果我们没有提供，C++编译器会提供一个编译器默认版本）











#### 13.8.7.2 什么时候使用自定义Copy Constructor以及一些注意事项

* ==如果使用raw pointer，那么只有指针会被copy，而不是其所指向的数据，这也就是所谓的shallow copy，另外还有deep copy，在下一节中介绍==，不过以此可以推理出，==如果使用raw pointer，那么使用用户定义的复制构造函数是最好的==

* **为拷贝构造函数提供一个const引用参数**：

  当你定义一个拷贝构造函数时，通常的做法是使用一个const引用作为参数，而不是直接使用对象。这样做有几个原因：

  - **效率**：使用引用可以避免对象的复制操作，这在处理大对象时尤其重要。
  - **避免无限递归**：如果拷贝构造函数需要一个对象作为参数（而不是引用），那么为了复制这个对象，你需要再次调用拷贝构造函数，这会导致无限递归。
  - **允许const对象的复制**：如果你试图从一个const对象创建一个新对象，只有当拷贝构造函数的参数是const引用时，这才是允许的。

  ```c++
  class MyClass {
  public:
      MyClass(const MyClass &source); // Copy constructor with const reference parameter
  };
  ```

* **使用STL类，因为它们已经提供了拷贝构造函数**：

  C++标准模板库（STL）中的类（如`std::vector`、`std::string`等）已经为你定义了拷贝构造函数。这意味着当你使用这些类时，你可以安全地复制它们的对象，而不必担心深拷贝和浅拷贝的问题。这大大简化了代码，并减少了出错的可能性。

* **尽可能避免使用原始指针数据成员**：

  当类中有原始指针作为数据成员时，拷贝构造函数的编写会变得复杂。你需要确保进行深拷贝，以避免两个对象共享相同的内存。如果不这样做，当其中一个对象被销毁并释放其内存时，另一个对象可能会引用已经释放的内存，导致未定义的行为。

  使用智能指针（如`std::shared_ptr`和`std::unique_ptr`）或其他资源管理技术可以帮助解决这个问题，因为它们提供了自动的内存管理。

总的来说，这些建议旨在帮助程序员避免与对象复制相关的常见陷阱和错误，并编写更安全、更高效的C++代码。













#### 13.8.7.3 Basic Copy constructors

```c++
Type::Type(const Type &source){
    //执行任何需要的操作来初始化新对象
}
```

* 使用reference：否则这个传参也是一个copy，它需要调用这个copy constructor，这样就是无尽的迭代
* 使用const：在copy constructor中，我们不希望误操作修改原class

==使用Initialize List==

```c++
Player::Player(const Player &source)
	: name{source.name}, health{source.health},xp{source.xp}
{
    
}
//或是使用Delegating ,C++11往后可用
Player::Player(std::string name_val, int health_val, int xp_val)
    :name{name_val},health{health_val},xp{xp_val}{
        // body
    }

Player::Player(const &source)
    :Player{source.name, source.health, source.xp}{
        //body
    }
```











#### 13.8.7.4 What is raw pointer

一个"raw pointer"是C++中的基本指针类型，它直接指向内存中的一个地址。与智能指针（如`std::shared_ptr`和`std::unique_ptr`）相比，raw pointer不提供自动的内存管理功能。

以下是raw pointer的一些特点：

1. **声明方式**：使用星号(*)来声明一个raw pointer。例如：`int* p;`
2. **内存管理**：使用raw pointer时，程序员需要手动管理内存。如果你使用`new`分配了内存，那么你需要确保在适当的时候使用`delete`来释放这块内存。否则，可能会导致内存泄漏。
3. **不安全**：由于raw pointer直接指向内存地址，所以它们可能会引发各种问题，如悬挂指针、空指针解引用和野指针。这也是为什么现代C++编程中推荐使用智能指针来自动管理内存。
4. **灵活性**：尽管raw pointer可能会带来风险，但它们在某些情况下（如性能关键的代码或与C语言的接口交互）提供了更大的灵活性。
5. **没有所有权语义**：与`std::unique_ptr`（表示唯一所有权）和`std::shared_ptr`（表示共享所有权）不同，raw pointer没有明确的所有权语义。这意味着多个raw pointer可以指向同一块内存，而没有明确的规则来决定哪个指针负责释放该内存。

例如：

```c++
int* p = new int(5);  // p is a raw pointer pointing to an integer in the heap
*p = 10;              // Dereferencing and modifying the value
delete p;             // Manually deleting the memory
```

在现代C++编程中，尽量避免使用raw pointer，除非有特定的理由。在许多情况下，使用智能指针可以帮助避免与raw pointer相关的常见错误。







