# 13. 面向对象编程-类与对象

* 什么是面向对象编程
* 什么是类与对象
* 声明类与创建对象
* `.`与指针操作符
* 公有和私有访问编辑器
* Methods, Constructors（构造函数） and Destructors（析构函数）
  * 类方法(class method)
  * default and overloaded constructors
  * copy and move constructors
  * shallow vs. deep copying
  * `this` pointer
* static 类成员
* struct vs class
* 类的友元

## 13.1 面向对象与面向过程

**面向过程编程 (Procedural Programming)**:

**优点**:

1. **简单性**：对于简单的、小型的程序，面向过程的方法可能更直观。
2. **执行效率**：由于没有额外的抽象层，面向过程的代码在某些情况下可能运行得更快。
3. **直接性**：代码通常按照它们在源文件中的顺序执行，这使得流程容易理解。

**缺点**:

1. **可扩展性**：随着项目的增长，面向过程的代码可能变得难以管理和扩展。
2. **代码重用**：可能会有大量的代码重复，因为面向过程的方法不鼓励代码重用。
3. **维护性**：随着时间的推移，可能会变得更加困难，特别是当涉及到大型项目时。

**面向对象编程 (Object-Oriented Programming, OOP)**:

**优点**:

1. **模块化**：代码更加组织化，每个对象都有其特定的行为和属性。
2. **代码重用**：通过继承和多态，可以轻松地重用和扩展现有的代码。
3. **可扩展性**：添加新的功能或修改现有功能变得相对容易。
4. **抽象性**：能够模拟现实世界的情境和对象，使得设计和理解更为直观。
5. **维护性**：由于其模块化的特性，OOP 代码更易于维护。

**缺点**:

1. **复杂性**：对于简单的程序，OOP 可能会引入不必要的复杂性。
2. **性能开销**：由于额外的抽象层，OOP 代码可能在某些情况下比面向过程的代码慢。
3. **学习曲线**：对于初学者来说，理解 OOP 的概念可能需要一些时间。

**为什么我们需要面向对象编程**:

1. **现实世界映射**：OOP 允许我们在代码中模拟现实世界的对象和情境，这使得设计和理解更为直观。
2. **大型项目管理**：对于大型和复杂的软件项目，OOP 提供了更好的组织和管理工具。
3. **代码重用和扩展**：OOP 的继承和多态特性使得代码重用和扩展变得更加容易。
4. **维护性**：随着软件的生命周期延长，OOP 代码的模块化和组织化特性使得维护变得更加简单。
5. **团队合作**：OOP 的模块化特性使得团队成员可以并行工作在不同的类和对象上，而不会干扰到其他人的工作。

总的来说，面向对象编程提供了一种更加结构化和模块化的方法来组织和设计软件，特别是对于大型和复杂的项目。

## 13.2 类与对象

### 13.2.1 Classes

* 类是对象创建的蓝本
* 类好像是一个用户定义的数据类型
* 类中包含attributes(data)以及methods(functions)
* 类可以隐藏仅类内部使用的data和function
* 类的目标是提供一个定义良好的公共接口，类的用户可以轻松使用该接口解决问题

### 13.2.2 Objects

* 对象由类创建
* 对象代表了类的一个实例(a specific instance of a class)
* 一个类可以创建很多实例
* 每个实例有其自己独有的标识
* 每个实例都可以使用定义好的class method



## 13.3 声明一个类

```c++
class player{
    // attributes
    std::string name;
    int health;
    int xp;
    
    //methods
    void talk(std::string text_to_say);
    bool is_dead();
}
```



## 13.4 生成一个实例

```c++
//普通实例
player frank;
player hero;

//动态分配实例
player *enemy{nullptr};
enemy = new player();//create on the heap
delete enemy;

//实例数组
player players[]{frank, hero};//frank 和 hero 必须在这个声明之前已经被定义。
std::vector<player> players1{frank};
players1.push_back(hero);
```



## 13.5 访问类成员

* We can access
  * class attributes
  * class methods
* 一些类成员not be accessible



```c++
//variable create on stack
player frank;
player.xp;// access to attributes
player.talk();// accesss to methods

//variable create on heap
(*enemy).xp;
(*enemy).talk();

enemy -> xp;
enemy -> talk();
```

==以上的例子仅作示范，通常来说，类中这些信息都是私有的，我们无权访问，我们会在下一节讲解==



## 13.6 Access Modifiers:类成员访问修饰符

* public
  * accessible everywhere
* private
  * accessible only by members or friends of the class
* protected
  * 用于继承

从AccessModifier之后，到遇见另一个不同的之前，所有的声明都服从该Modifier。

```c++
class Class_name
{
    public:
    //declaration(s)
};
```



## 13.7 创建类方法(implementing member methods)

在C++中，类成员函数（通常称为方法）可以在类定义内部（内联）声明和定义，也可以在类定义外部定义。这两种方式有其各自的特点和用途：

1. **在类内部声明和定义（Inline）**:

   - 当你在类定义内部提供成员函数的实现时，==该函数默认为内联函数==。

   - 内联函数的代码在编译时会嵌入到每个调用点，这可能会提高执行速度，但可能增加生成的代码的大小。

   - ==适用于简短的、频繁调用的函数，如访问器和修改器==。

   - 代码示例：

     ```c++
     class MyClass {
     public:
         void myMethod() {
             // ... function implementation
         }
     };
     ```

2. **在类外部定义**:

   - 在类定义外部提供成员函数的实现可以使类定义更加简洁和清晰。

   - 这种方式不会自动将函数视为内联函数，但你可以通过在函数定义前加上`inline`关键字来显式地将其标记为内联。

   - ==适用于函数实现较长或需要与其他类或函数交互的函数==。

   - 代码示例：

     ```c++
     class MyClass {
     public:
         void myMethod();
     };
     
     void MyClass::myMethod() {
         // ... function implementation
     }
     ```

**注意**：==无论选择哪种方式，成员函数的声明都必须在类定义内部进行==。

**总结**：

- 在类内部定义的函数默认为内联，可能会提高执行速度，但可能增加代码大小。适用于简短的函数。
- 在类外部定义的函数可以使类定义更加简洁，适用于较长的函数实现。
- 选择哪种方式取决于具体的设计考虑和函数的用途。

### 13.7.1 Inside the class declaration

```c++
class Account{
private:
    double balance;
public:
    void set_balance(double bal){
        // 这个public的方法可以访问private的数值，间接的帮助全局范围改变了private数值
        balance = bal;
    }
    double get_balance(){
        return balance;
    }
}
```

### 13.7.2 Outside the class declaration

```c++
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
    double get_balance();
}

void Account::set_balancec(double bal){
    balance = bal;
}

double Account::get_balance(){
    return balance;
}
```



### 13.7.3 Include guard

* 复杂的类通常声明在头文件中，并有一个专门的cpp文件实现

* 头文件可能会被多次包含

  * **直接多次包含**：这是最简单的情况，可能是由于疏忽或其他原因，开发者在同一个源文件中多次`#include`了同一个头文件。

    ```c++
    #include "some_header.h"
    #include "some_header.h"
    ```

  * **间接多次包含**：当一个头文件A包含头文件B，而源文件或另一个头文件C也包含头文件B时，头文件B会被间接地多次包含。

    ```c++
    // A.h
    #include "B.h"
    
    // C.h or C.cpp
    #include "A.h"
    #include "B.h"
    ```

    在这种情况下，当我们包含A.h和C.h（或C.cpp）时，B.h会被包含两次。

  * **多个源文件**：当多个源文件都包含同一个头文件时，这个头文件会在每个源文件的编译单元中被包含。这不会导致重复定义的错误，但如果头文件很大，可能会影响编译时间。

  * **条件编译**：有时，开发者可能会使用预处理器的条件编译功能来决定是否包含一个头文件。如果条件在多个地方都满足，头文件可能会被多次包含。

    ```c++
    #ifdef SOME_CONDITION
    #include "some_header.h"
    #endif
    
    // ... some code ...
    
    #ifdef ANOTHER_CONDITION
    #include "some_header.h"
    #endif
    ```

  * **模板和内联函数**：当头文件包含模板或内联函数的定义时，为了正确地编译它们，这些头文件需要在每个使用它们的源文件中被包含。

  为了避免由于多次包含头文件而导致的问题，通常使用`#include` guards或`#pragma once`（如果编译器支持）来确保头文件的内容在每个编译单元中只被包含一次。



`#include` guards（也称为头文件保护或预处理器保护）是C和C++编程中用于防止头文件被多次包含的预处理器宏。当一个头文件被多次包含时，它可能会导致重复的定义，从而引发编译错误。为了避免这种情况，我们使用`#include` guards。

#### 13.7.3.1 使用ifdefine

##### 如何工作？

`#include` guards基于预处理器的条件编译功能。它们通常使用`#ifndef`、`#define`和`#endif`指令。

##### 使用方法：

1. 在头文件的开始，使用`#ifndef`检查一个特定的宏（通常是一个唯一的名称）是否已经定义。
2. 如果该宏尚未定义，则使用`#define`定义它。
3. 在文件的末尾，使用`#endif`结束条件编译。

##### 示例：

假设我们有一个名为`my_header.h`的头文件：

```c++
#ifndef MY_HEADER_H
#define MY_HEADER_H

// Your header file content goes here

#endif // MY_HEADER_H
```

在这个例子中，`MY_HEADER_H`是一个宏，它在文件首次被`#include`时被定义。如果在同一个编译单元中再次尝试包含这个头文件，`#ifndef`检查将失败，因为`MY_HEADER_H`已经被定义，所以文件的内容不会再次被包含。

##### 优点：

1. **防止重复包含**：这是`#include` guards的主要目的。它们确保头文件中的内容在给定的编译单元中只被包含一次。
2. **减少编译时间**：通过防止不必要的重复包含，可以稍微减少编译时间。

##### 注意事项：

1. **唯一性**：确保每个头文件的宏名称是唯一的，以避免与其他头文件冲突。
2. **不要在源文件中使用**：`#include` guards主要用于头文件。在源文件中使用它们通常没有意义，因为源文件不应该被其他文件包含。
3. **`#pragma once`**：某些编译器提供了`#pragma once`指令，它是`#include` guards的一个现代替代方案。当编译器看到这个指令时，它会确保文件只被包含一次。但是，它不是标准的C++，并且不是所有编译器都支持它。

总之，`#include` guards是C++编程中的一个基本技术，用于确保头文件不被多次包含，从而避免重复定义和其他相关的编译问题。

#### 13.7.3.2 使用Pragma once

会有编译器不支持

```c++
//Account.h
    
# pragma once
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
	double get_balance();
}

```

### 13.7.4 使用headfile创建复杂类

==永远include .h 文件，而非include .cpp文件==

> Account.h

```c++
    
# pragma once
class Account{
private:
    double balance;
public:
    void set_balance(double bal);
	double get_balance();
}

```

> Account.cpp

```c++
#include"Accound.h"

void Account::set_balance(double bal){
    balance = bal;
}

double Account::get_balance(){
    return balance;
}
```

> main.cpp

```c++
#include<iostream>
#include"Account.h"

int main(){
    Account frank_account;
    frank_account.set_balance(1000.00);
    double bal = frank_account.get_balance();
    
    std::cout << bal << std::endl;//1000
    return 0;
}
```

#### headfile中的禁忌

在头文件中使用`using namespace`是不推荐的，原因如下：

1. **污染命名空间**：当你在头文件中使用`using namespace`，你实际上是将该命名空间中的所有符号引入到任何包含该头文件的文件中。这可能会导致命名冲突和意外的名字解析。
2. **不可预测的行为**：由于头文件可能会被多个源文件包含，使用`using namespace`可能会导致不同的源文件有不同的命名解析行为，这取决于它们包含头文件的顺序和方式。
3. **降低代码可读性**：当读者查看一个源文件并看到一个未知的标识符时，他们可能会猜测这个标识符来自哪个命名空间。如果头文件中使用了`using namespace`，这会使得追踪标识符的来源变得更加困难。
4. **维护困难**：随着时间的推移，命名空间中可能会添加新的符号。这可能会导致之前工作正常的代码突然出现命名冲突或其他错误。
5. **降低代码的可移植性**：如果你决定将你的头文件分享给其他人或用于其他项目，使用了`using namespace`的头文件可能会导致其他代码出现问题。

为了避免这些问题，推荐的做法是在头文件中避免使用`using namespace`，并在实现文件中明确指定所需的命名空间，例如`std::vector`而不是简单地`vector`（在使用`using namespace std;`后）。这样可以确保代码的清晰性、可维护性和可移植性。

## 13.8 构造函数与析构函数(Constructors and Destructors)

### 13.8.1 构造函数Constructors

* 构造函数是一个特别的member method
* 构造函数在对象被==创建==时会被自动援引(invoked)
* 构造函数常常用于初始化
* 构造函数名与类名一致
* 构造函数没有返回类型
* 构造函数可以重载

```c++
class Player
{
private:
    std::string name;
    int health;
    int xp;
public:
    //overloaded constructors
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
    
}
```

#### Default Constructor

* Default Constructor不期望任何输入(即no-args constructor)
* 如果没有特别写一个constructor，C++会自动生成一个什么都不做的Default Constructor
* Default Constructor会在你创建一个新对象并且没有传参时被自动调用

```c++
Player frank;
Player *enemy = new Player;
```

==当然，一旦我们自己设置了一个带args的Constructor，以上这种声明就会出错，因为编译器不会为你生成一个default constructor，constructor只存在你申请的那个。==

事实上，我们最好自己定义无参数构造函数

```c++
class Player
{
private:
    std::string name;
    double balance;
public:
    Player(){
        name = "None";
        balance = 0.0;
    }
    bool withdraw(double amount);
    bool deposit(double amount);
}
```



### 13.8.2 析构函数Destructors

* 析构函数是一个特殊的member method
* 析构函数名与类名一致，不过前面有一个`~`

* 析构函数将在一个对象被==销毁==时自动援引
  * 当local object超出作用域时
  * 当指针对象被delete时
* 析构函数没有返回类型，==没有参数==
* 每个类只能有一个析构函数，==并且不能被重载==
* 常用于释放内存和其他资源

```c++
class Player
{
private:
    std::string name;
    int health;
    int xp;
public:
    //overloaded constructors
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
    //Destructor
    ~Player();
    
}
```

#### 13.8.2.1 常见析构函数内部作用

析构函数是一个特殊的成员函数，当一个对象的生命周期结束时，它会被自动调用。析构函数的主要目的是执行任何必要的清理工作，以确保对象被正确地销毁。以下是通常在析构函数中执行的一些操作：

1. **释放动态分配的内存**：如果类的对象分配了堆上的内存（通常使用`new`），析构函数应确保这些内存被释放（使用`delete`或`delete[]`）。

   ```c++
   class MyClass {
   private:
       int* data;
   public:
       MyClass(int size) {
           data = new int[size];
       }
       ~MyClass() {
           delete[] data;
       }
   };
   ```

2. **关闭文件或网络连接**：如果对象持有文件句柄或网络连接，析构函数应确保它们被正确关闭。

3. **解除资源的锁定**：如果对象持有某些资源的锁（例如，多线程编程中的互斥锁），析构函数应确保锁被释放。

4. **销毁其他资源**：例如，如果对象使用了某些操作系统特定的资源（如句柄、线程或进程），析构函数应确保这些资源被正确销毁。

5. **通知其他对象**：有时，对象的销毁可能需要通知其他对象。例如，如果对象是某个观察者模式中的观察者，它可能需要在被销毁时从主题中注销。

6. **调用基类的析构函数**：这实际上是自动完成的，但值得注意的是，派生类的析构函数在执行完其内容后会自动调用其基类的析构函数。

需要注意的是：

- 析构函数不接受任何参数，也没有返回值。
- 你不能直接调用析构函数（尽管有一些特殊情况可以）。它是由编译器自动调用的，通常在对象超出作用域或被`delete`时。
- 如果你没有为类提供析构函数，编译器会为你生成一个默认的析构函数。但如果类管理资源（如动态内存），则应提供自定义的析构函数以确保正确清理。

总之，析构函数的主要任务是确保对象的正确、安全和完整的销毁，以及释放它使用的所有资源。

### 13.8.3 创建对象与销毁对象

```c++
{
    Player slayer;
    Player frank {"Frank", 100, 4};
    Player hero {"Hero"};
    Player villain {"Villain"};
}// 4 destructors called

Player *enemy  = new Player("Enemy", 1000, 0);
delete enemy;// destructor called
```

==当对象超出作用域时，析构函数的调用顺序和它们的创建顺序相反==

### 13.8.4 Constructor Initialization Lists(构造函数初始化列表)

* ==**支持初始化`const`成员**：`const`成员变量一旦被初始化就不能被修改。因此，你必须在构造函数初始化列表中初始化它们。对于类的常量成员和引用成员==，你必须使用初始化列表，==因为它们不能在构造函数体内赋值。==
* **避免额外的构造函数调用**：如果不使用初始化列表，对象的成员会先被默认构造，然后在构造函数体中被赋新的值。这可能导致不必要的构造函数调用，尤其是对于复杂的对象或容器。==使用初始化列表可以直接初始化成员，而不是先默认构造然后再赋值，这可以提高效率。==
  * 原本：allocating things$\rightarrow$Deallocating thing$\rightarrow$ assignment
  * 现在：allocating things$\rightarrow$ 
* **对于基类初始化**：如果你的类从一个基类继承，你可以使用初始化列表来调用基类的构造函数。
* **更好的编译时检查**：使用初始化列表可以确保所有成员都被正确初始化。这在某些情况下可以提供更好的编译时检查，尤其是当类有多个构造函数且成员需要在每个构造函数中都被初始化时。
* **支持不可默认构造的成员**：==有些类成员可能没有默认构造函数==（例如，它们只有带参数的构造函数）。在这种情况下，你必须使用初始化列表来初始化这些成员。

**No args Construct**：

```c++
//Previous way
Player::Player(){
    name = "None";
    health = 0;
    xp = 0;
}

//Better way
Player::Player()
    :name{"None"},health{0},xp{0}{
        
    }
```

* Initialize List 在初始化构造函数名之后，主体函数之前
* 初始化成员的顺序不一定是我们在初始化列表中提供的顺序，数据成员将按照在类声明中声明的顺序进行初始化。

**With Args Construct**:

```c++
//Previous way
Player::Player(std::string name_val){
    name = name_val;
    health = 0;
    xp = 0;
}

// Better way:
Player::Player(std::string name_val)
    :name{name_val},health{0},xp{0}{
        
    }
```

### 13.8.5 Delegating Constructors:委托构造函数

委托构造函数 (Delegating Constructors) 是在 C++11 中引入的，它允许一个构造函数调用同一类中的另一个构造函数。这个特性有助于减少构造函数之间的代码重复，并确保类的所有构造函数都可以集中到执行必要初始化的主构造函数中。

==委托构造函数的逻辑通常就是选择所有构造函数的传入参数的并集，先使用初始化列表实现它，作为主构造函数，然后对每一个重载的构造函数，按顺序填入即可，所传入的参数填入，其他填入默认值==

```c++
class Player {
private:
    std::string name;
    int health;
    int xp;
public:
    // 主构造函数
    Player(std::string name_val, int health_val, int xp_val) 
        : name{name_val}, health{health_val},xp{xp_val}
    {
        // 初始化逻辑
    }

    // 委托构造函数：默认构造函数
    Player()
        : Player{"None",0,0}{
            
        }

    //
    Player(std::string name_val)
        : Player{name_val,0,0}{
            
        }
};
```

* 委托构造函数使得我们在重载构造函数时更加简便

* 委托构造函数仅在初始化列表中有效，不能从委托构造函数的主体内部调用其他构造函数。

  * 例如，以下是正确的使用方法：

    ```c++
    class MyClass {
    public:
        MyClass(int a) : value{a} { }  // 主构造函数
    
        MyClass() : MyClass{0} { }    // 委托构造函数
    private:
        int value;
    };
    ```

    而以下的使用方法是错误的：

    ```c++
    class MyClass {
    public:
        MyClass(int a) : value{a} { }  // 主构造函数
    
        MyClass() {
            MyClass{0};  // 这是错误的！你不能在委托构造函数的主体中这样调用其他构造函数
        }
    private:
        int value;
    };
    
    ```

 





### 13.8.6 Default Constructor parameter

* 使用默认构造参数能够避免使用函数重载，但这不代表了使用默认构造参数就不能使用函数重载，只要保证编译器在调用构造函数时没有歧义即可，见注释

* ==C++的默认构造参数只支持按顺序的传参，不能说仅传入顺序第三个参数。这部分限制了default constructor的使用，但是这仍然是一个好方法==

  

```c++
Class Player{
private:
    std::string name;
    int health;
    int xp;
public:
    Player(std::string name_val = "None",int health_val = 0, int xp_val = 0);
}

Player::Player(std::string name_val, int health_val, int xp_val)
	:name{name_val}, health{health_val}, xp{xp_val}
{
    
}

int main(){
	Player empty;
	Player frank{"Frank"};
	Player villain{"Villain", 100, 50};
}




```

> 确保函数重载之间没有歧义的关键是确保在任何给定的调用情境下，编译器都能清晰地确定应该调用哪个函数版本。当使用默认参数时，这可能会变得复杂，因为默认参数可能会导致某些调用形式与多个函数版本匹配。
>
> 让我们通过一个例子来说明这一点：
>
> ```c++
> class MyClass {
> public:
>     MyClass(int a, int b = 10) {
>         // Constructor code
>     }
> 
>     MyClass(double a) {
>         // Another constructor code
>     }
> };
> ```
>
> 在上述代码中，我们有两个构造函数。第一个接受两个整数参数，其中第二个参数有一个默认值。第二个构造函数接受一个双精度浮点数参数。
>
> 以下是一些示例调用：
>
> 1. `MyClass obj1(5);` - 这是明确的。尽管第一个构造函数可以通过其默认参数来匹配这个调用，但第二个构造函数是一个更好的匹配，因为它只需要一个参数。
> 2. `MyClass obj2(5, 6);` - 这也是明确的。只有第一个构造函数匹配这个调用。
> 3. `MyClass obj3(5.0);` - 这同样是明确的。只有第二个构造函数匹配这个调用，因为它接受一个双精度浮点数参数。
>
> 在这个例子中，尽管我们使用了默认参数，但我们确保了每种可能的调用形式都只与一个构造函数版本匹配，从而避免了歧义。
>
> 然而，如果我们添加了以下构造函数：
>
> ```c++
> MyClass(int a = 0);
> ```
>
> 那么调用 `MyClass obj(5);` 就会变得模糊不清，因为它可以匹配两个构造函数：`MyClass(int a, int b = 10)` 和 `MyClass(int a = 0)`。这种情况下，编译器会报错，因为它不能确定应该调用哪个构造函数。
>
> 总之，确保重载函数之间没有歧义的关键是仔细考虑每种可能的调用形式，并确保每种形式都只与一个函数版本匹配。





### 13.8.7 Copy Constructor

#### 13.8.7.1 什么是Copy Constructor

* C++在对象被复制时会由已有对象创建一个新的对象作为对象的副本，为了应对==对象被复制==的情况，引入了Copy Constructor

* 具体来说，在以下几个场景使用居多

  * 将对象传参(Pass Object by value)

    * ```c++
      Player hero {"Hero", 100, 20};
      
      void display_player(Player p){
          // p is a copy of hero in this example
          // use p
          // Destructor for p will be called
      }
      
      display_player(hero);
      ```

  * 函数返回一个对象时的赋值

    * ```c++
      Player enemy;
      
      Player create_super_enemy(){
          Player an_enemy{"Super Enemy", 1000, 1000};
          return an_enemy; // A COPY of an_enemyis returned
      }// destructor of an_enemy is called
      
      enemy = create_super_enemy();
      ```

  * 我们想基于同一个类的一个已有对象创建一个副本（以用于其他操作）

* 我们可以提供自己的复制构造函数，并==精确定义对象复制所需要的语义==（如果我们没有提供，C++编译器会提供一个编译器默认版本）











#### 13.8.7.2 什么时候使用自定义Copy Constructor以及一些注意事项

* ==如果使用raw pointer，那么只有指针会被copy，而不是其所指向的数据，这也就是所谓的shallow copy，另外还有deep copy，在下一节中介绍==，不过以此可以推理出，==如果使用raw pointer，那么使用用户定义的复制构造函数是最好的==

* **为拷贝构造函数提供一个const引用参数**：

  当你定义一个拷贝构造函数时，通常的做法是使用一个const引用作为参数，而不是直接使用对象。这样做有几个原因：

  - **效率**：使用引用可以避免对象的复制操作，这在处理大对象时尤其重要。
  - **避免无限递归**：如果拷贝构造函数需要一个对象作为参数（而不是引用），那么为了复制这个对象，你需要再次调用拷贝构造函数，这会导致无限递归。
  - **允许const对象的复制**：如果你试图从一个const对象创建一个新对象，只有当拷贝构造函数的参数是const引用时，这才是允许的。

  ```c++
  class MyClass {
  public:
      MyClass(const MyClass &source); // Copy constructor with const reference parameter
  };
  ```

* **使用STL类，因为它们已经提供了拷贝构造函数**：

  C++标准模板库（STL）中的类（如`std::vector`、`std::string`等）已经为你定义了拷贝构造函数。这意味着当你使用这些类时，你可以安全地复制它们的对象，而不必担心深拷贝和浅拷贝的问题。这大大简化了代码，并减少了出错的可能性。

* **尽可能避免使用原始指针数据成员**：

  当类中有原始指针作为数据成员时，拷贝构造函数的编写会变得复杂。你需要确保进行深拷贝，以避免两个对象共享相同的内存。如果不这样做，当其中一个对象被销毁并释放其内存时，另一个对象可能会引用已经释放的内存，导致未定义的行为。

  使用智能指针（如`std::shared_ptr`和`std::unique_ptr`）或其他资源管理技术可以帮助解决这个问题，因为它们提供了自动的内存管理。

总的来说，这些建议旨在帮助程序员避免与对象复制相关的常见陷阱和错误，并编写更安全、更高效的C++代码。













#### 13.8.7.3 Basic Copy constructors

```c++
Type::Type(const Type &source){
    //执行任何需要的操作来初始化新对象
}
```

* 使用reference：否则这个传参也是一个copy，它需要调用这个copy constructor，这样就是无尽的迭代
* 使用const：在copy constructor中，我们不希望误操作修改原class

==使用Initialize List==

```c++
Player::Player(const Player &source)
	: name{source.name}, health{source.health},xp{source.xp}
{
    
}
//或是使用Delegating ,C++11往后可用
Player::Player(std::string name_val, int health_val, int xp_val)
    :name{name_val},health{health_val},xp{xp_val}{
        // body
    }

Player::Player(const Player &source)
    :Player{source.name, source.health, source.xp}{
        //body
    }
```











#### 13.8.7.4 What is raw pointer

一个"raw pointer"是C++中的基本指针类型，它直接指向内存中的一个地址。与智能指针（如`std::shared_ptr`和`std::unique_ptr`）相比，raw pointer不提供自动的内存管理功能。

以下是raw pointer的一些特点：

1. **声明方式**：使用星号(*)来声明一个raw pointer。例如：`int* p;`
2. **内存管理**：使用raw pointer时，程序员需要手动管理内存。如果你使用`new`分配了内存，那么你需要确保在适当的时候使用`delete`来释放这块内存。否则，可能会导致内存泄漏。
3. **不安全**：由于raw pointer直接指向内存地址，所以它们可能会引发各种问题，如悬挂指针、空指针解引用和野指针。这也是为什么现代C++编程中推荐使用智能指针来自动管理内存。
4. **灵活性**：尽管raw pointer可能会带来风险，但它们在某些情况下（如性能关键的代码或与C语言的接口交互）提供了更大的灵活性。
5. **没有所有权语义**：与`std::unique_ptr`（表示唯一所有权）和`std::shared_ptr`（表示共享所有权）不同，raw pointer没有明确的所有权语义。这意味着多个raw pointer可以指向同一块内存，而没有明确的规则来决定哪个指针负责释放该内存。

例如：

```c++
int* p = new int(5);  // p is a raw pointer pointing to an integer in the heap
*p = 10;              // Dereferencing and modifying the value
delete p;             // Manually deleting the memory
```

在现代C++编程中，尽量避免使用raw pointer，除非有特定的理由。在许多情况下，使用智能指针可以帮助避免与raw pointer相关的常见错误。



### 13.8.8 Shallow Copy vs Deep Copy

当类中有raw pointer时，也就是申请的内存空间由指针指向时，就会引出Shallow Copy 和Deep Copy的概念。

#### 13.8.8.1 Shallow Copy

* Shallow Copy是编译器生成的复制构造函数提供的默认行为，它对所有的成员进行复制
* Shallow copy中raw pointer被copy了，而非raw pointer指向的数据被copy了，==也就是新旧对象有两个指针指向同一个地址，当一个对象销毁时，该地址也被销毁，另一个对象就会产生悬空指针,当另一个对象被销毁时，你在销毁一个不存在的堆地址，就会报错==

```c++
class Shallow{
private:
    int *data;
public:
    //Constructor
    Shallow(int d){
        data = new int;
        *data = d;
    }
    Shallow(const Shallow &source):data(source.data){}//Memberwise copy
    ~Shallow(){
        delete data;
    }
}
```

#### 13.8.8.2 Deep Copy

* 创建一个raw pointer所指向的数据的备份

* 每个复制，其内的pointer都会指向一个独有的storage in the heap

* 在class中含有raw pointer时，你总是应该使用Deep Copy

```c++
class Deep{
private:
    int *data;
public:
    //Constructor
    Deep(int d){
        data = new int;
        *data = d;
    }
    //change
    Deep(const Deep &source){
		data = new int;
        *data = *source.data;
    }
    
    ~Deep(){
        delete data;
    }
}
```

==或是可以使用委托构造函数方法，委托`Deep(int d)`构造。==

```c++
Deep(const Deep &source)
    :Deep{*source.data}{
        
    }
```



### 13.8.9 Move Constructor

* 首先回顾一下左值右值，如果你可以通过reference到达一个name，或者通过pointer到达一个对象，那这个对象是==可寻址的==，即为==左值==。其余都是右值。
* ==在移动语义的上下文中，右值指的是编译器创建的临时对象和从方法返回的对象==

```c++
int total {0};
total = 100 + 200;
```

如上所示，total是左值，100，200，==以及100和200相加所得到的300==都是存储在临时memory中的，他们都是右值。

这个300右值随后就被存储到了左值total中。

#### 13.8.9.1 为什么需要移动构造函数？

C++11引入了移动构造函数（Move Constructor）和移动语义（Move Semantics）主要是为了优化性能和资源管理。在C++11之前，对象的复制通常是通过拷贝构造函数来完成的，这通常涉及到深拷贝，即分配新的内存并复制数据。==这样的操作在某些情况下可能是非常昂贵的==，特别是当对象持有大量内存或其他资源时。

> 事实上现在的compiler会帮我们自动完成很多优化避免复制的操作，这也就是有的时候调试会发现没有调用copy constructor

1. **性能优化**：通过移动而不是复制对象，可以避免不必要的内存分配和释放，从而提高性能。
2. **资源管理**：有些资源不能或不应该被复制，例如文件句柄、互斥锁、套接字等。移动语义允许这些资源在对象之间安全地转移。
3. **语义清晰**：在某些情况下，移动一个对象比复制更符合程序员的意图。例如，当一个对象被“移出”一个容器并“移入”另一个容器时。
4. **支持现代编程模式**：移动语义简化了一些涉及临时对象和资源转移的编程模式，使得代码更简洁、更易于理解。



#### 13.8.9.2 R-value reference

* ```c++
  int x{100};		// x is l_value
  int &l_ref = x; // l_value reference
  l_ref = 10; 	// change x to 10
  
  int &&r_ref = 200;	//r-value ref
  r_ref = 300;		//将300存储到ref所指的R值中(change temporary variable)
  
  int &&x_ref = x;	//compiler error
  
  void func(int &num);
  
  
  func(x); // 这里是可以的，因为传入的x是l_value，允许做reference
  func(200);//Error，200是一个R value
  //error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
  
  
  
  void func(int &&num);
  
  func(200);// 正确的，因为是右值引用
  func(x);// 错误的，x是左值
  
  
  //我们可以overload使得既可以传左值又可以传右值，这两个是能被编译器识别出不同的
  
  void func(int &num);
  void func(int &&num);
  
  
  func(x);
  func(200);
  ```

* **R值引用常常被用于移动语义（Moving Semantics）以及完美转发（Perfect Forwarding）**
  
  1. **移动语义（Moving Semantics）**: 当你有一个临时对象（或者你明确地知道一个对象不再被使用）时，你可以通过使用R值引用（`&&`）将该对象的资源“移动”到另一个对象中，而不是进行深拷贝。这通常更加高效。
  2. **完美转发（Perfect Forwarding）**: 在模板编程中，R值引用与`std::forward`一起使用，可以实现函数参数的完美转发，即保持参数的原始类型（是L值还是R值）。
  
* **移动语义全靠R值引用（Move Semantics is All About R-value Reference）**

  移动语义的核心就是R值引用。通过使用R值引用，你可以创建移动构造函数和移动赋值运算符，这些函数和运算符可以窃取临时对象或即将销毁的对象的资源。

*  **用于移动构造函数和移动赋值运算符以高效地移动对象而非复制它（Used by Move Constructor and Move Assignment Operator to Efficiently Move an Object Rather Than Copy It）**

  当你定义一个移动构造函数或移动赋值运算符时，通常会使用R值引用作为参数类型。这样，你就可以从源对象中窃取资源，而不是进行资源密集型的深拷贝操作。

* **移动之后**，原对象通常会被置于一个有效但未定义的状态。==这意味着原对象仍然存在，但其内部资源（如动态分配的内存、文件句柄等）可能已经被转移到新对象中。==

  在移动操作完成后，==原对象通常会被设置为一个“空”或“默认”状态==。例如，如果对象内部有一个动态分配的指针，那么在移动操作后，这个指针通常会被设置为`nullptr`。

  ```c++
  class MyClass {
  private:
      int* data;
  public:
      MyClass(MyClass&& source) : data(source.data) {
          source.data = nullptr;  // 将原对象的指针设置为nullptr
      }
  };
  ```

  这样做的目的是为了安全。==由于原对象仍然存在，如果不将其置于一个安全状态，那么当其析构函数被调用时，可能会尝试释放已经被移动到新对象中的资源，从而导致未定义的行为或错误。==

  因此，虽然原对象在移动操作后仍然存在，但通常不应再使用它进行任何操作，除非已明确地将其重置为一个有效状态。在某些情况下，例如当原对象是临时对象时，它会在移动操作后很快被销毁。



#### 13.8.9.3 Example:Move class

移动构造函数接受一个右值引用（通常是一个临时对象）作为参数，并“窃取”这个对象的资源，而不是复制它们。这通常涉及以下几个步骤：

1. 将源对象的资源（例如，指针成员变量）移动到目标对象。
2. 将源对象置于一个有效但未定义的状态，通常是将其资源指针设置为`nullptr`。



##### 13.8.9.3.1 普通的copy constructor

普通的Copy constructor：

```c++
class Move{
private:
    int *data; 	//raw pointer
public:
    void set_data_value(int d){*data = d;}
    int get_data_value(){return *data;}
    Move(int d){
        data = new int;
        *data = d;
        cout << "Constructor for" << d << endl;
    }	//Constructor
    Move(const Move &source);	//Copy constructor
    ~Move();		// Destructor
}

//Allocate storage and copy
Move::Move(const Move &source)
	:Move{*source.data}{//在copy constructor是对指向数据复制
    cout << "Copy constructor -deep copy for." << *data << endl;
}

```

```c++
Vector<Move> vec;
vec.push_back(Move{10});
vec.push_back(Move{20});
```

```c++
调用顺序是： 

Constructor for 10 ：创建临时对象

//调用copy constructor
Constructor for 10 ：使用委托构造函数为vec创建对象
Copy constructor deep copy for 10：临时对象复制到vec对象

Destructor freeing data for 10 ：临时对象超出作用域销毁

Constructor for 20 ：创建临时对象

Constructor for 20 ：使用委托构造函数为vec创建对象
Copy constructor deep copy for 20 ：临时对象复制到vec对象

//vector push时因为vector中已有对象，需要重新分配一个空间
//原始对象10被复制与销毁
constructor for 10 ：新位置的对象创建

copy constructor deep copy for 10 ：复制

destructor freeing data for 10 ：销毁原对象

destructor freeing data for 20 ：临时对象超出作用域销毁
```



为了理解这个调用顺序，我们需要理解`std::vector`的工作方式和`push_back`方法的行为。==当你向`std::vector`添加元素时，它可能需要重新分配内存以容纳更多的元素。这可能导致已有的元素被移动或复制到新的内存位置。==

现在，让我们逐步分析给定代码的执行流程：

1. `vec.push_back(Move{10});`
   - `Move{10}`：这是一个临时对象的构造，所以首先调用`Move`的构造函数。输出：`Constructor for 10`。
   - `push_back`：这会==将临时对象复制到`vec`中==。因此，调用`Move`的拷贝构造函数。输出：`Constructor for 10`（这是为`vec`中的新元素创建的对象）和`Copy constructor deep copy for 10`。
   - 临时对象`Move{10}`超出其生存期并被销毁。输出：`Destructor freeing data for 10`。
2. `vec.push_back(Move{20});`
   - `Move{20}`：这是一个临时对象的构造，所以首先调用`Move`的构造函数。输出：`Constructor for 20`
   - `push_back`：这会将临时对象复制到`vec`中。但在这之前，由于`vector`可能需要更多的空间来容纳新的元素，它可能会重新分配内存并移动已有的元素。这就是为什么你看到了关于10的构造和拷贝构造的额外调用。输出：`Constructor for 10`、`Copy constructor deep copy for 10`、`Destructor freeing data for 10`（这是因为原始的10的对象被销毁）。
   - 接下来，20的对象被复制到`vec`中。输出：`Constructor for 20`和`Copy constructor deep copy for 20`。
   - 临时对象`Move{20}`超出其生存期并被销毁。输出：`Destructor freeing data for 20`。

注意：这个特定的输出顺序可能会根据`std::vector`的实现和编译器优化有所不同。但上述解释提供了一个可能的执行流程。

为了避免这种频繁的复制，C++11引入了移动语义，允许我们使用移动构造函数和移动赋值运算符来有效地转移资源，而不是复制它们。这在处理大型对象或资源密集型对象时特别有用。



==关于临时对象在哪==：

> - **栈（Stack）**：当你在函数内部声明一个变量（不使用`new`或`malloc`等）时，该变量通常存储在栈上。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和局部变量。栈上的变量在函数返回时会被自动销毁。
>
>   ```c++
>   int main() {
>       int a = 42;  // 'a' is stored on the stack
>       // ...
>   }
>   ```
>
> - **堆（Heap）**：当你使用`new`（或在C中使用`malloc`）时，内存会在堆上分配。堆是用于存储程序运行期间动态分配的变量的区域。与栈不同，堆上的内存需要手动管理（通过`delete`或`free`）。
>
>   ```c++
>   int main() {
>       int* p = new int(42);  // 'p' is stored on the stack, but what it points to is on the heap
>       // ...
>       delete p;  // Free the heap memory
>   }
>   ```
>
> - **类成员和对象**：如果一个对象是在栈上创建的，其成员变量也通常存储在栈上。如果对象是在堆上创建的，其成员变量也存储在堆上。
>
>   ```c++
>   class MyClass {
>       int x;  // Where 'x' is stored depends on where the object of MyClass is stored
>   };
>           
>   int main() {
>       MyClass obj1;          // 'obj1' and its members are stored on the stack
>       MyClass* obj2 = new MyClass();  // 'obj2' is on the stack, but what it points to (and its members) are on the heap
>       // ...
>       delete obj2;  // Free the heap memory
>   }
>   ```









##### 13.8.9.3.2 Move constructor

移动语义相当于把原有堆上数据的对象的控制权转移到了现在的类，而原始对象指向该数据的指针变味了空指针。We are not doing copy at all.

```c++
Type :: Type(Type &&source);
```

相对于左值引用的copy constructor：

```c++
Type::Type(const &source);
```

移动语义

* 因为需要改变原对象，减去了const
* 因为需要移动右值，所以使用了&&
* 相当于从原对象偷窃了数据，并将原对象清理。
* 本例子

```c++
Move::Move(Move &&source)
    :data{source.data}{// 在move constructor是对指针赋值
        source.data = nullptr;//important
    }
```





此时，之前的代码运作流程变为了如下：

```c++
Constructor for 10; // 创建临时对象
//调用move constructor
//因为使用初始化列表，没有调用委托构造函数（没有必要申请新内存），因此没有constructor for 10
Move Constructor -moving resource: 10; //移动到vec
Destructor freeing data for nullptr; // 临时对象销毁

Constructor for 20;// 创建临时对象

Move constructor -moving resource: 20;//移动到vec
Move constructor -moving resource: 10;//原vec 的对象10移动到新位置
Destructor freeing data for nullptr;// 原vec 对象10销毁
Destructor freeing data for nullptr;// 20临时对象销毁

//如果vec调用其析构函数，会释放其管理的元素
Destructor freeing data for 10; //？
Destructor freeing data for 20; //临时对象销毁。
    
```













##### 13.8.9.3.3 澄清一下右值引用与左值引用

###### 右值引用的简化内涵

==左值引用和原始变量名都代表同一块内存，而右值引用为临时对象提供了一个名字，使我们可以在其生命周期内与其互动。==

- **左值引用**：它是一个已存在对象的别名。当你对这个引用进行操作时，实际上是在操作它所引用的对象。例如：

  ```c++
  int x = 10;
  int& ref = x;
  ref = 20;  // 这会改变x的值为20
  ```

- **右值引用**：它允许你给一个临时对象（右值）一个名字，从而可以对其进行操作，而不仅仅是使用它的值。这是C++11引入移动语义的关键部分。例如：

  ```c++
  int&& rvalue_ref = 10 + 20;  // 10 + 20是一个临时值，一个右值
  ```

右值引用的主要目的是允许我们“移动”资源，而不是复制它们，从而提高效率。当我们知道一个对象不再需要其资源时（例如，当它是一个临时对象或者我们明确地使用`std::move`），我们可以使用右值引用来“窃取”这些资源，而不是进行昂贵的深复制。









###### source是一个对象，为什么可以使用右值引用

你提到了一个很好的点。确实，通常我们认为右值引用是绑定到临时对象（即右值）的。但是，右值引用不仅仅是为了绑定到临时对象。

在C++中，==一个对象（或者任何类型）都可以被视为左值或右值==，这取决于它的上下文和如何使用它。使用`std::move`函数，你可以将左值转换为右值引用，从而允许你使用移动语义。

例如：

```c++
MyClass obj1;
MyClass obj2 = std::move(obj1);  // 使用移动构造函数
```

在上面的代码中，`obj1`是一个左值，因为它有一个名称并且可以被寻址。但是，当我们使用`std::move(obj1)`时，我们实际上是请求将`obj1`视为一个右值，这样我们就可以使用`MyClass`的移动构造函数（如果定义了的话）。

==既然提到了`std::move()`，很重要的一点就是何时使用了。==

* 例如，假设你有以下类和函数：

```c++
class MyClass {
    // ... class definition ...
};

void someFunction(MyClass &&source) {
    // ... function body ...
}
```

​	如果你有一个`MyClass`对象`obj`，并且你想调用`someFunction`，你需要这	样做：

```c++
MyClass obj;
someFunction(std::move(obj));  // 使用std::move将obj转换为右值
```

​	使用`std::move`后，`obj`可能处于一个"移动后"的状态，这意味着它的资源	可能已经被转移走了。在这之后，你应该避免使用`obj`，除非你重新为它赋	值或确保它仍然是有效的。

* 然而，如果你直接使用一个==临时对象或其他明确的右值来调用函数，那么你不需要使用`std::move`：==

```c++
someFunction(MyClass());  // 直接使用临时对象
```

==总之，当你想将一个左值传递给一个接受右值引用的函数时，你需要使用`std::move`。但是，如果你已经有一个右值（如临时对象），则不需要使用`std::move`。==

所以，当我们在函数参数中看到`MyClass&& source`时，`source`确实是一个可以寻址的对象，但它是一个右值引用，表示它引用的对象的资源可以被“窃取”或移动。

总之，虽然右值引用最初是为了绑定到临时对象，但使用`std::move`，我们可以将左值转换为右值引用，从而利用移动语义。

##### 需要注意的几点

* ==**右值的对象其内的元素仍是可寻址的左值**==

* **如果你的`Move`类包含`int *data`和`int x`两个属性，并且你想为它实现移动构造函数，你可以这样做：**

  ```c++
  class Move {
  private:
      int *data;  // raw pointer
      int x;      // simple integer
  
  public:
      // ... other member functions ...
  
      // Move constructor
      Move(Move &&source)
          : data{source.data}, x{source.x} { // Move both the pointer and the integer
          source.data = nullptr; // Null out the source object's pointer
          // No need to null out 'x' because it's a simple integer and doesn't own any resources
      }
  
      // ... other member functions ...
  };
  ```

  在上面的代码中，移动构造函数将`source`对象的`data`指针和`x`整数都移动到新对象。对于`data`指针，我们还需要确保`source`对象不再拥有该资源，所以我们将其设置为`nullptr`。==对于简单的整数`x`，我们不需要做任何额外的处理，因为它不拥有任何外部资源。==

  * ==对于简单的数据类型（如`int`），移动操作和复制操作在效果上是相同的。这是因为这些类型没有外部资源（如动态分配的内存）需要管理。因此，对于`int`类型的`x`，移动它和复制它是等价的。==

    ==但是，当我们谈论移动语义时，我们通常关注的是那些拥有外部资源的对象，如动态分配的内存、文件句柄等。对于这些对象，移动通常比复制更高效，因为我们只是转移资源的所有权，而不是创建资源的新副本。==

* **左值引用也可以构造移动语义**

  * ```c++
    Move(Move &source)
        : data{source.data}, x{source.x} {
        source.data = nullptr;
    }
    ```

    这确实是一个移动构造函数，但它的参数是一个左值引用，而不是一个右值引用。通常，移动构造函数的参数应该是一个右值引用，如`Move(Move &&source)`。

    对于`x`，我们只是复制了它的值，这与复制构造函数中所做的相同。对于`data`指针，我们转移了它的所有权，并确保源对象不再拥有该资源，这是通过将`source.data`设置为`nullptr`来实现的。

  * ==我们不推荐这样做==，

  * 从技术上讲，你可以使用左值引用来编写一个类似于移动构造函数的函数，然后手动地转移资源。但这样做会违反C++的常规语义和习惯用法，可能会导致混淆和错误。

    在C++中，移动语义是通过右值引用来实现的。当你看到一个函数接受一个右值引用参数时，你可以合理地期望这个函数会“窃取”该参数引用的对象的资源，而不是简单地复制它。这是一种约定，它使得代码更加清晰和可读。

    ==如果你使用左值引用来实现移动语义，那么调用这个函数的代码可能会非常令人困惑。调用者可能会期望这个函数只是复制对象，而不是窃取它的资源。这可能会导致难以调试的错误和未定义的行为。==

    例如，考虑以下代码：

    ```c++
    Move obj1(some_data);
    Move obj2 = obj1;  // 使用左值引用的"移动构造函数"
    ```

    在这里，`obj2`的构造看起来就像是一个普通的复制构造。但如果`Move`的构造函数实际上是窃取`obj1`的资源，那么`obj1`可能会处于一个无效的状态，这可能并不是调用者所期望的。

    总之，虽然从技术上讲，你可以使用左值引用来模拟移动语义，但这样做会违反C++的常规语义和习惯用法，可能会导致混淆和错误。为了清晰和一致性，最好使用右值引用来实现移动语义。

* ==类似vector这种，在push时，如果使用deep copy，例如push了8个，实际上会产生十几次deep copy，因此在这种情况下更应该使用move constructor==

  * `std::vector` 是 C++ 标准库中的一个动态数组容器，它可以自动管理其大小以适应元素的添加和删除。当你使用 `push_back` 方法向 `std::vector` 添加元素时，`std::vector` 可能会进行一些内部操作以确保有足够的空间来存储新元素。以下是 `push_back` 在不同情况下的行为：

    1. **当 `vector` 中没有元素时**:
       - 如果 `vector` 的容量为 0（即 `capacity()` 返回 0），则会为 `vector` 分配一块内存来存储新元素。
       - 将新元素添加到 `vector` 的末尾。
       - 更新 `vector` 的大小（即 `size()`）。
    2. **当 `vector` 中已有元素时**:
       - 首先检查 `vector` 的当前大小是否已达到其容量。如果 `size()` 等于 `capacity()`，则 `vector` 已满，需要重新分配内存。
       - 如果需要重新分配内存，`vector` 通常会分配比当前容量大的新内存块（通常是当前容量的两倍，但这取决于实现）。然后，它会将现有的元素从旧内存块移动或复制到新内存块，并释放旧内存块。
       - 将新元素添加到 `vector` 的末尾。
       - 更新 `vector` 的大小。

    需要注意的是，由于 `vector` 可能需要重新分配内存，所以当你向 `vector` 添加元素时，任何指向 `vector` 元素的指针、引用或迭代器都可能失效。因此，每次调用 `push_back` 之后，最好不要依赖之前获取的这些指针、引用或迭代器。

    此外，为了提高效率，如果你知道将要添加多少元素，可以使用 `reserve` 方法预先为 `vector` 分配足够的内存，这样在添加元素时就不需要频繁地重新分配内存。

* 右值对象为什么能够左值引用？例如`vector.push_back(Move{10})`，但是其copy constructor是`Move::Move(const Move &source)`

  * 你的问题是关于如何在使用 `vector::push_back` 时，传入一个临时对象（右值），但是拷贝构造函数却使用了左值引用参数。

    首先，当你调用 `vector::push_back` 并传入一个临时对象时，这个临时对象是一个右值。理论上，如果 `vector` 能够利用这个右值的性质（即它是一个临时的、即将被销毁的对象），它可以更高效地将这个对象移动到容器中，而不是复制它。这就是为什么 C++11 引入了移动语义和右值引用。

    但是，==如果你的类只提供了一个接受左值引用的拷贝构造函数（如 `Move::Move(const Move &source)`），并且没有提供移动构造函数，那么 `vector::push_back` 会使用拷贝构造函数来复制这个临时对象，即使它是一个右值。==

    ==这是因为在 C++11 之前，没有移动语义的概念，所以所有的对象都是通过拷贝构造函数来复制的，不管它们是左值还是右值。而在 C++11 中，如果提供了移动构造函数，它会被优先使用于右值上；如果没有提供，那么拷贝构造函数会被使用，即使是在右值上。==

    所以，即使 `Move::Move(const Move &source)` 使用了左值引用，它仍然可以用于拷贝右值，但这是通过复制而不是移动来完成的。如果你想利用移动语义的优势，你应该为你的类提供一个移动构造函数。





#### 13.8.9.4 右值引用与指针接管的区别

使用指针的方法确实可以实现资源的转移，但是右值引用和移动语义在C++中的引入并不仅仅是为了资源转移。它们还解决了其他一些问题，并提供了更为安全和直观的语法。以下是使用右值引用和移动语义的一些优势：

1. **类型安全**：==使用原生指针进行资源管理可能会导致类型错误，尤其是在复杂的代码中==。右值引用是类型安全的。
2. **自动管理**：当使用`std::move`和移动构造函数/赋值操作符时，==资源的转移是自动的==。你不需要显式地设置原对象为`nullptr`。
3. **语义清晰**：移动语义明确表示了资源所有权的转移，而不是简单的赋值或复制。这使得代码的意图更加明确。
4. **与现有代码兼容**：移动语义允许你在不改变现有代码的情况下优化性能。例如，如果一个函数期望一个常量左值引用，你可以通过提供一个移动构造函数来优化临时对象的使用，而不需要修改该函数的签名或调用代码。
5. **优化临时对象的使用**：在很多情况下，编译器可以自动地使用移动语义优化临时对象的使用，而不需要程序员的干预。
6. **完美转发**：右值引用和`std::forward`允许函数模板准确地转发其参数，保持其原始的值类别（左值或右值）。这在模板编程中是非常有用的。

总的来说，尽管使用指针可以实现某些与移动语义相似的效果，但移动语义提供了更高级、更安全和更直观的方法来处理资源所有权的转移和其他相关问题。







### 13.8.10 `this` pointer

* `this`是一个保留字(reserved keyword)
* `this`指针包含了当前对象的地址(a pointer to the object)
* `this`指针只能在类的范围内使用
* 所有的成员访问都是通过`this` 指针实现的
* 这个指针可以被程序员使用
  * 用于显式访问成员数据和成员函数
  * 用于判断两个对象是否相同
  * 可以被解地址用于访问当前对象

**普通的赋值**

```c++
void Account::set_balance(double bal){
    balance = bal;	//我们不需要写this->balance，这是编译器为我们幕后做的
}
```

**冲突的赋值**

```c++
void Account :: set_balance(double balance){
    balance = balance; // which balance？
}

void Account :: set_balance(double balance){
    this->balance = balance; //
}
```

**Determine ojbect identity**

* 一些时候我们需要方便的判定两个对象是不是同一个对象

```c++
int Account::compare_balance(const Account &other){
    if(this == &other){
        cout << "Same objects" << endl;
    }
}
frank_account.compare_balance(frank_account);
```

**自赋值检查**：在赋值操作符的重载中，最常见的用途是检查自赋值。例如，考虑以下代码：

```c++
MyClass& operator=(const MyClass &rhs) {
    if (this == &rhs) {
        return *this;  // 返回当前对象
    }
    // ... 其他赋值代码
}
```

如果没有这种检查，自赋值可能会导致不必要的操作，或者在某些情况下，可能会导致错误，例如当涉及到动态内存分配和释放时。



## 13.9 常量对象

==一旦常量对象被创建，我们就不能改变它的任何属性(attribute)了==

==考虑到一些method并不会修改常量对象，但是仍然会不被允许使用，我们使用常量函数来告诉编译器特定的方法不会修改对象。==

```c++
class Player{
    private:
    	...
    public:
    	std::string get_name() const;
    	...
}
```



对于非常量对象，其成员函数是否被标明为 `const` 并不影响你能否调用它。非常量对象可以调用常量成员函数和非常量成员函数。

但是，对于常量对象，它只能调用被标明为 `const` 的成员函数。这是因为 `const` 成员函数保证了它不会修改对象的状态，这与常量对象的语义是一致的。

==如果常量对象调用了非const成员函数，编译器会认为你将const对象的指针传给了一个潜在的可能改变该对象的函数，因此会产生编译器错误==





**简而言之：**

- ==常量对象：只能调用 `const` 成员函数。==

- ==非常量对象：可以调用 `const` 和非 `const` 成员函数。==

- 就算对可能改变attribute的method设定为const成员函数，调用时编译器会报错，因为`const`成员函数保证了它不会（也不应该）修改对象的状态。

- 但是，有一种情况可以绕过这个限制，那就是使用`mutable`关键字。`mutable`关键字允许你在`const`成员函数中修改某个属性，即使这个函数是`const`的。

  - ```c++
    multable int value;
    ```

让我们通过一个简单的类来详细说明常量成员函数的作用和重要性。

```c++
class SimpleNumber {
private:
    int value;

public:
    SimpleNumber(int v) : value(v) {}

    // 常量成员函数
    int getValue() const {
        return value;
    }

    // 非常量成员函数
    void increment() {
        value++;
    }
};
```

现在，我们来创建一个常量对象和一个非常量对象，并尝试调用上述成员函数：

```c++
int main() {
    const SimpleNumber constObj(10);  // 常量对象
    SimpleNumber nonConstObj(20);     // 非常量对象

    // 对于常量对象
    std::cout << constObj.getValue() << std::endl;  // 这是合法的，因为 getValue 是一个常量成员函数
    // constObj.increment();  // 这是非法的，因为 increment 不是一个常量成员函数

    // 对于非常量对象
    std::cout << nonConstObj.getValue() << std::endl;  // 这是合法的
    nonConstObj.increment();  // 这也是合法的

    return 0;
}
```

在上述代码中：

1. 对于常量对象 `constObj`，我们只能调用那些被标记为 `const` 的成员函数。这是因为常量对象一旦被初始化后，它的状态就不应该被改变。因此，尝试调用 `increment` 方法会导致编译错误。
2. 对于非常量对象 `nonConstObj`，我们可以自由地调用任何成员函数，无论它们是否被标记为 `const`。

这种机制确保了当我们声明一个对象为 `const` 时，它的状态确实是不变的，因为我们不能调用任何可能改变其状态的成员函数。这为我们提供了一种强大的工具，可以明确地指定哪些对象应该是不可变的，并确保编译器会帮助我们维护这种不变性。



需要注意的是会有隐式的const object

```c++
Player villain{};

void getname(const Player &source){
    cout << source.get_name() << endl;
}

getname(villain);//报错，因为Player里面没有设置const相关，什么都调用不了，尽管声明的是非const
```

## 13.10 Static class member

考虑一个情况，我们需要知道我们创建了多少个`Player`类，我们可以使用一个全局变量来维护，但是现在有更好的方法，我们可以使用专属于某一个类的静态变量，这个静态变量即使没有对象也有意义，因为它是专属于类的。



```c++
class Player{
    private:
    	static int num_players;
    	//static int num_players{0};
    	//Error:C++禁止在类中初始化non const static member
    public:
    	static int get_num_players();
}

int Player::get_num_players(){
    return num_players;
}//因为声明时已经规定了static了，这里就不需要了
```

* 我们不能在声明时初始化它

  * ```c++
    # include"Player.h"
    
    int Player::num_players = 0;
    ```

  * 这个操作通常只发生一次，并且通常是在类实现的.cppfile中定义的

* 我们还需要声明一个返回整数的静态类函数

* ==这个函数是static的，因此它只能访问static数据成员==

* 在构造函数中增加，在析构函数中减少

  * ```c++
    Player::Player(std::string name_val, int health_val, int xp_val)
        :name{name_val},health{health_val},xp{xp_val}{
            ++num_players;
        }
    ```

  * 如果有很多重载的构造函数要额外注意

  * ```c++
    Player::~Player(){
        --num_players;
    }
    ```

* `static`:

  * 在C++中，`static`关键字在类的声明和定义中有不同的含义和用途。

    1. **在类的声明中**：当你在类内部声明一个成员函数为`static`时，你正在告诉编译器这个函数是一个静态成员函数。这意味着这个函数不依赖于类的任何特定实例，也不需要`this`指针。它可以通过类名直接调用，而不需要对象实例。
    2. **在类的定义（实现）中**：在类外部定义成员函数时，你已经在类的声明中指定了函数的所有属性（包括`static`、`const`等）。==因此，当你在类外部定义这个函数时，不需要再次指定这些属性==。==在这个上下文中，`static`关键字的含义与在类内部不同，所以你不应该在类外部的函数定义中使用它。==

    简而言之，`static`关键字在类的声明中用于指定成员函数或成员变量为静态的。但在类的定义（实现）中，你不需要再次指定它，因为编译器已经知道这个函数是静态的。

    例如：

    ```c++
    class MyClass {
    public:
        static void staticFunction();  // 声明静态成员函数
    };
    
    // 在类外部定义静态成员函数
    void MyClass::staticFunction() {  // 注意这里没有static关键字
        // 函数体
    }
    ```

    在上面的例子中，`staticFunction`在类的声明中被声明为`static`，但在其定义（实现）中，我们没有再次使用`static`关键字。

* static method只能调用类里面的static数据，而其他method是也能调用static数据

  * **静态成员函数**（static member functions）只能访问类的静态数据成员和其他静态成员函数。它们不能访问类的非静态数据成员或非静态成员函数，==因为静态成员函数不依赖于类的任何特定实例，也没有`this`指针==。
  * **非静态成员函数**可以访问类的静态数据成员、静态成员函数、非静态数据成员和非静态成员函数。这是因为==非静态成员函数是与类的特定实例关联的，它们有一个`this`指针指向调用它的对象==。静态数据成员在类级别存在，这意味着它们不是与类的任何特定实例关联的，而是与类本身关联的。因此，无论是静态成员函数还是非静态成员函数，都可以访问静态数据成员。

  示例：

  ```c++
  class MyClass {
  private:
      static int static_data;  // 静态数据成员
      int non_static_data;     // 非静态数据成员
  
  public:
      static void staticFunction() {
          // 可以访问静态数据成员
          static_data = 10;
  
          // 不能访问非静态数据成员
          // non_static_data = 20;  // 这会导致编译错误
      }
  
      void nonStaticFunction() {
          // 可以访问静态数据成员
          static_data = 30;
  
          // 可以访问非静态数据成员
          non_static_data = 40;
      }
  };
  
  int MyClass::static_data = 0;  // 初始化静态数据成员
  ```

  在上面的例子中，`staticFunction`只能访问`static_data`，而`nonStaticFunction`可以访问`static_data`和`non_static_data`。





## 13.11 Struct vs. Classes

struct来自c语言，在c中我们创建struct作为数据的容器

c++中为了兼容struct，你能对class做的所有操作都能对struct做，==唯一的区别是struct的成员是默认为public的，class的成员是默认为private的==

```c++
class Person{
    std::string name;
    std::string get_name();
}

Person p;
p.name = "Frank";//compiler error-private
cout << p.get_name();//compiler error-private
```

```c++
struct Person{
    std::string name;
    std::string get_name();
}

Person p;
p.name = "Frank";//OK
std::cout << p.get_name();//OK
```

**总结** 

`struct`

- 通常用于被动对象，其成员默认为公开访问。
- 通常不在`struct`中声明方法。

 `class`

- 通常用于主动对象，其成员默认为私有访问。
- 根据需要实现getter和setter方法。
- 根据需要实现成员方法。

这些是一些常见的指导原则，但在实际编程中，开发者可以根据自己的需要选择使用`struct`或`class`，并为其定义适当的方法和属性。







## 13.12 友元

* 友元
  * 友元是可以一个function或是class，他们能够访问private class member
  * 并且友元并不是这个class的member
  * 如果友元是函数
    * 函数可以是常规函数
    * 函数也可以是另一个类的成员函数
  * 如果友元是类
    * 整个类都可以访问友元类的private member

* 规则:
  * 友元是给与的而非索取的
    * 友元应当class中使用friend关键字显式声明
  * 友元并非双向的
  * 友元并非可传递的
    * a是b的友元，b是c的友元，那么a不是c的友元
  * 友元是非继承的

==声明一个函数为友元==

```c++
class Player{
	friend void display_player(Player &p);
    std::string name;
    int health;
    int xp;
public:
    ...
}
//该函数可以调用Player
void display_player(Player &p){
    std::cout << p.name << endl;
    std::cout << p.health << endl;
    std::cout << p.xp << endl;
    
}
```

==声明一个另一个类的member为友元==

```c++
class Other_class{
    ...
public:
    void display_player(Player &p){
        std::cout << p.name << endl;
   		std::cout << p.health << endl;
    	std::cout << p.xp << endl;
    }
}
class Player{
    friend void Other_class::display_player(Player &p);
    std::string name;
    int health;
    int xp;
public:
    ...
}


```

==声明单独的类为友元==

```c++
class Player{
    friend class Other_class;
    std::string name;
    int health;
    int xp;
public:
    ...
}
```

# section 13 challenge

`Movie.h`

```c++
#IFNDF MOVIE
#DEFINE MOVIE
class Movie{
private:
    friend class Movies;
    std::string name;
    std::string rating;//G,PG,PG-13,R
    int watched_count;
    
    void Movie::Movie(std::string name_val, std::string rating_val,int wathced_val)
        :name{name_val},rating{rating_val},watched_count{watched_val}{
            num++;
        }
    void Movie::~Movie(){
        num--;
    }
	void Movie::Add_watched_count(){
        watched_count++;
    }
}
#ENDIF

```

`Movie.cpp`

`Movies.h`

```c++
#IFNDF MOVIES
#DEFINE MOVIES
class Movies{
private:
    vector<Movie> MovieList;
    
public:
    void Movies::display(){
        for(auto source:MovieList){
            cout << MovieList.name << endl;
        }
    }
    void Movies::Add_Movie(std::string name, string rating, int watched_count){
        bool is_exist{false};
        for(auto source:MovieList){
            if(source.name == name)
                is_exist = true;
        }
        if(is_exist){
            cout <<"Error, Movie already exist" << endl;
        }else{
        	MovieList.push_back(Movies{name,rating,watched_count});
        }
    }
    void Movies::Increase_count(std::string name){
        bool is_inlist{false};
        for(auto source:MovieList){
            if(source.name == name){
                name.Add_watched_count();
                is_inlist = true;
                break;
            }
        }
        if(is_inlist == false){
            cout << "Error:target movie is not exist" << endl;
        }
    }
    
}
#ENDIF
```

`Movies.cpp`



`main.cpp`









