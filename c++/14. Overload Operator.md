# 14. Overload Operator

==可以重载并不代表需要重载，只有能让你代码more useable, more readable and more writeable的重载才是好重载==

在C++中，运算符重载允许程序员为用户定义的数据类型指定运算符的操作。这意味着我们可以为自定义的类或结构体定义加法、减法等运算符的行为。

* **重载赋值运算符(=)**

  * **复制语义**: 当我们使用赋值运算符将一个对象的值复制给另一个对象时，我们使用复制语义。这通常涉及到创建对象的深拷贝。

  * **移动语义**: C++11引入了移动语义，允许我们在不实际复制数据的情况下转移资源。这通过使用特殊的引用类型——右值引用来实现。

* **作为成员函数重载运算符**
  * 当我们在类内部重载运算符时，它作为成员函数存在。这意味着它可以直接访问类的私有和受保护的成员。

* **作为全局函数重载运算符**
  * 有时，将运算符重载为全局函数可能更有意义，尤其是当我们希望左操作数不是类的对象时。

*  **重载流插入(<<)和提取(>>)运算符**
  * 流插入和提取运算符通常与C++的I/O流一起使用，如`std::cout`和`std::cin`。通过重载这些运算符，我们可以直接输出和输入用户定义的类型。



## 14.1 What is Overload Operator

* 类是用户自定义的type
* 重载使得我们类型的行为和感觉类似于内置类型(int,double)
* make code more readable and writable
* 编译器提供预设的重载算子仅有`=`,因为编译器必须能够将一个对象赋值给另一个对象，其他可以重载的运算符必须由程序员显式的定义



**例子：原本我们使用函数或是成员函数**:不可读且难以维护

```c++
Number result = multiply(add(a,b),divide(c,d));
```

```c++
Number result = (a.add(b)).multiply(c.divide(d));
```

**使用overloaded operators**

```c++
Number result = (a+b)*(c/d);
```

### 14.1.1 可以被重载的操作符

事实上，只有少数操作符不能被重载

| Operator |                      |
| :------: | -------------------- |
|    ::    | 作用域解析运算符     |
|    :?    | 条件运算符           |
|    .*    | 指向成员的指针运算符 |
|    .     | 点运算符             |
|  sizeof  | sizeof运算符         |



==可以重载的运算符==

| 运算符类别 | 运算符名字             | 运算符符号 |
| ---------- | ---------------------- | ---------- |
| 算术运算符 | Addition               | `+`        |
|            | Subtraction            | `-`        |
|            | Multiplication         | `*`        |
|            | Division               | `/`        |
|            | Modulus                | `%`        |
| 关系运算符 | Equal to               | `==`       |
|            | Not equal to           | `!=`       |
|            | Greater than           | `>`        |
|            | Less than              | `<`        |
|            | Greater than or equal  | `>=`       |
|            | Less than or equal     | `<=`       |
| 逻辑运算符 | Logical AND            | `&&`       |
|            | Logical OR             | `||`       |
|            | Logical NOT            | `!`        |
| 位运算符   | Bitwise AND            | `&`        |
|            | Bitwise OR             | `|`        |
|            | Bitwise XOR            | `^`        |
|            | Bitwise NOT            | `~`        |
|            | Left shift             | `<<`       |
|            | Right shift            | `>>`       |
| 赋值运算符 | Assignment             | `=`        |
|            | Add and assign         | `+=`       |
|            | Subtract and assign    | `-=`       |
|            | Multiply and assign    | `*=`       |
|            | Divide and assign      | `/=`       |
|            | Modulus and assign     | `%=`       |
|            | Bitwise AND and assign | `&=`       |
|            | Bitwise OR and assign  | `|=`       |
|            | Bitwise XOR and assign | `^=`       |
|            | Left shift and assign  | `<<=`      |
|            | Right shift and assign | `>>=`      |
| 其他运算符 | Dereference            | `*`        |
|            | Address-of             | `&`        |
|            | Subscript              | `[]`       |
|            | Function call          | `()`       |
|            | Increment              | `++`       |
|            | Decrement              | `--`       |
|            | Type cast              | `(type)`   |
|            | Comma                  | `,`        |



### 14.1.2 使用重载操作符的一些基础规则

* **优先级和结合性不能被改变**

  * 无论如何重载，运算符的优先级和结合性都是固定的，不能被修改。

  * **例子**：假设我们有一个类`Complex`，我们为它重载了`+`和`*`运算符。即使我们重载了这些运算符，`*`仍然比`+`有更高的优先级。

    ```c++
    Complex a, b, c;
    auto result = a + b * c; // 即使重载了+和*，b*c仍然先于a+b执行
    ```

* **不能改变'arity'**

  * 'arity'是指运算符的操作数数量。例如，我们不能将二元的除法运算符改为一元运算符。

  * **例子**：我们不能将除法运算符`/`重载为只接受一个操作数。

    ```c++
    Complex a;
    // 以下是错误的，因为我们不能将/重载为一元运算符
    // auto result = a /;
    ```

* **不能为基本类型重载运算符**

  * 例如，我们不能为`int`、`double`等基本数据类型重载运算符。

  * **例子**：我们不能为两个整数定义一个新的加法运算。

    ```c++
    // 这是错误的，因为我们不能为int类型重载+
    // int operator+(int a, int b) { return a - b; }
    ```

* **不能创建新的运算符**

  * 我们只能重载已经存在的运算符，不能创造全新的运算符。

  * **例子**：我们不能创建一个新的运算符，如`@@`。

    ```c++
    // 这是错误的，因为@@不是一个有效的C++运算符
    // Complex operator@@(const Complex &a, const Complex &b) { /*.
    ```

* **[],(),->和赋值运算符(=)必须声明为成员方法**

  * 这些运算符由于其特殊性，必须在类内部作为成员方法进行重载。

  * **例子**：我们为一个`Array`类重载`[]`运算符。

    ```c++
    class Array {
    public:
        int& operator[](size_t index) { return data[index]; } // 必须为成员方法
    private:
        int data[10];
    };
    ```

* **其他运算符可以声明为成员方法或全局函数**

  *  除了上述特定的运算符外，其他运算符可以在类内部作为成员方法重载，也可以作为全局函数进行重载。

  * **例子**：我们为`Complex`类重载`+`运算符。

    作为成员方法：

    ```c++
    class Complex {
    public:
        Complex operator+(const Complex &other) { /*...*/ }
    };
    ```

    作为全局函数：

    ```c++
    Complex operator+(const Complex &a, const Complex &b) { /*...*/ }
    ```



### 14.1.3 一些例子

![image-20231014174904223](./assets/image-20231014174904223.png)

## 14.2 重载赋值操作符(copy)



## 14.3 重载赋值操作符(move)



## 14.4 重载操作符为成员函数



## 14.5 重载操作符为全局函数



## 14.6 重载输入流以及输出流



