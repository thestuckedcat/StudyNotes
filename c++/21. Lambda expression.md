# 21. Lambda expression

## 21. 1 Overview

* 什么是Lambda expression
  * Motivation
  * Review of function objects(Functors)
  * Relation between lambdas and function objects
* Structure of a lambda expression
* Types of lambda expression
  * Stateless lambda expression
  * Stateful lambda expression(capturing context)
* Lambdas and the STL



### 21.1.1 Motivation-取代function object

* 在C++11之前，当我们需要使用STL和我们自己的代码定制行为时，主要使用函数对象和函数指针。函数对象主要用于STL，而函数指针更常用作回调。

* 一个小问题就是我们常常需要写很多控制算法的短函数，在STL的例子中，这些小函数被封装在小类中以产生函数对象。但是很多时候，类和函数的定义距离很远，这会导致修改，维护和测试代码出现问题。

* 此外，函数没有被定义内联时，编译器不太擅长优化函数。

  ```c++
  class MUltiplier{
  private:
      int num{};
  public:
      Multiplier(int n) : num{n} const{
          
      }
      
      int  operator()(int n) const{
          return num * n;
      }
  }
  
  std::vector<int> vec{1,2,3,4};
  Multiplier mult{10};
  std::tranform(vec.begin(),vec.end(),vec.begin(),mult);
  
  //vec now contains {10,20,30,40};
  
  //以下写法也一样
  std::transform(vec.begin(),vec.end(),vec.begin(),Multiplier(10));
  ```

* 例如如上例子，我们用一个初始化乘数对象，并将其存储在num属性中。然后当我们用一个乘数对象调用重载函数运算符时，我们将过去的乘数n乘以num。==这种将object当成function使用的方法，也被称为function objects==

* ```c++
  //例子2：一个template类
  template<typename T>
  struct Displayer{
      void operator() (const T &data){
          std::cout << data << " ";
      }
  }
  
  //用法
  Displayer<int> d1;
  Displayer<std::string> d2;
  
  d1(100);//等同于d.operator()(100)，输出100
  
  d2("Frank");//等同于d.operator()("Frank")，输出Frank
  
  
  // 更多用法
  std::vector<int> vec1 {1,2,3,4,5};
  std::vector<std::string> vec2{"Larry", "Moe", "Curly"};
  
  std::for_each(vec1.begin(),vec1.end(),Displayer<int>());
  
  std::for_each(vec1.begin(),vec1.end(),d1);
  
  std::for_each(vec2.begin(),vec2.end(),d2);
  ```

* 以上就是老方法，例如函数对象

* 以下是lambda方法

  ```c++
  std::vector<int> vec1 {1,2,3,4,5};
  std::vector<std::string> vec2{"Larry", "Moe", "Curly"};
  
  std::for_each(vec1.begin(),vec1.end(),[](int x){std::cout << x << " ";});
  
  ```

* 这不代表我们永远不需要函数对象方法了，==使用lambda表达式的最佳时间是在代码量是一个语句或几个语句时使用它。==

* lambda表达式的另一个好处是编译器根据 lambda 表达式的定义生成一个函数对象，==这个对象包含了函数代码和捕获的变量，这个对象也被称为闭包对象==。因为闭包对象包含了捕获的变量，所以即使在 lambda 表达式定义的作用域外部，这些变量仍然可以通过闭包对象访问。闭包是 lambda 表达式的具体实现，允许 lambda 表达式像一个常规函数那样被调用，同时保持对其捕获的变量的访问。



### 21.1.2 Structure of a Lambda Expression

![image-20231108215548371](./assets/image-20231108215548371.png)

* `[]`:Capture List

  * 决定了Lambda expression的开始
  * allow us to capture the context or the closure(闭包) the lambda expression execute in

  * 在stateful lambda中，我们可以定义我们想capture哪些值，以及by value还是by reference

* `()`：Parameter list

* `return type`:如果lambda非常简单，编译器通常可以推导出lambda的返回类型，因此可以省略

* `specifiers`:有两个选择，mutable 与 constexpr，当然也可以不写

* `{}`:写代码执行的地方



最简单的lambda expression

```c++
[](){std::cout << "hi";}
```

这个lambda expression可以使用以下方式调用，它使用了一个重载的call function来实例化这个function，当然我们一般不这么做

```c++
[](){std::cout << "hi";}();
```







### 21.1.3 Assign a lambda expression to a variable

```c++
auto l = [](){std::cout << "hi";};
l();// display "hi"

auto l = [](int x){std::cout << x;};
l(10);

auto l = [](int x, int y) ->int {return x+y};
//因为编译器会自己分析，所以实际上不需要->int
l(2,3);
```

* auto代表的type其实是一个std function with template argument



## 21.2 Stateless lambda expression

### 21.2.1 基础知识

接下来介绍空捕获列表的lambda表达式

空的捕获列表`[]`意味着表达式不从其环境中捕获任何信息，而只知道通过函数参数列表传递给它的信息。这就是stateless lambda expression



![image-20231108222401379](./assets/image-20231108222401379.png)

在上面的例子中，因为我们没有捕获n和nums，因此我们必须传参

进一步的，我们也可以引用传参

![image-20231108222446214](./assets/image-20231108222446214.png)

与指针传参

![image-20231108222639537](./assets/image-20231108222639537.png)



### 21.2.2 实现通用输入

```c++
int num1{10};
float num2{20.5};

auto l = [](auto x){std::cout << x;}
l(num1);
l(num2);
```

这里要做个小区分，auto是已知value的时候都可以用的

在template那一部分中，我们不能直接声明为auto

```c++
class Temp{
    auto num1;
}
```

但是我们可以将template与auto结合

```c++
template <typename T>
class Temp{
    T num1;
    Temp(T num1):num1{num1}{}
};

Temp<auto>(num1);
```

这也就是为什么我们还需要template，因为我们并没有值来让它auto



### 21.2.3 将lambda expression作为函数参数

#### 21.2.3.1 基础语法

以下至少需要C++14

```c++
#include<functional>
auto l = [](auto x){std::cout << x;}
//C++14
void foo(std::function<void(int)> l){
    //void代表return type
    // int代表Parameter type
    l(10);
}
//以function pointer传参,C++14
void foo(void(*l)(int)){
    //void代表return type
    // int代表Parameter type
    l(10);
}

//C++20
void foo(auto l){
    l(10);
}


//调用
foo([](int x){std::cout << x;});
//or 需要多次传时
auto l = [](int x){std::cout << x;};
foo(l);
```



#### 21.2.3.2 何时使用lambda传参-predicate lambda

我们以一个predicate lambda为例

* 下面的例子中predicate是一个C++参数，它接受int，并返回bool
* 所谓的predicate lambda就是lambda的一个典型用法
* **以下例子中将lambda当作参数，你可以使用21.2.3.1中的三种方法传递，这都称为predicate lambda**
* 在这种情况下，predicate lambda用于确定在主函数print中显示整数向量的哪些元素

```c++
void print_if(std::vector<int>nums, std::function<bool(int)> predicate){
    for(int i:nums){
        if(predicate(i))
            std::cout << i;
    }
}

int main(){
    std::vector<int> nums {1,2,3};
    
    print_if(nums, [](auto x){return x % 2 == 0;});
    print_if(nums, [](auto x){return x % 2 != 0;});
    
}
```

* 这样，我们不仅能抽象类型，我们现在有能力通过predicate lambda抽象函数的能力
* predicate lambda在sort或是for_each中常常用到









### 21.2.4 将lambda expression作为返回

```c++
#include<functional>

std::function<void(int)> foo(){
    return [](int x){std::cout << x;};
}
//old style c sytax,忽略就好
void (*foo())(int){
    return [](int x){std::cout << x;};
}

//最常用
auto foo(){
    return [] (int x){std::cout << x;};
}

//call
auto l = foo();
l(10);
```



### 21.2.5 例子

```c++
int main()
{
    //lambda表达式直接实例化，一般没人这么用
    test1();
    //// Using values and references as lambda parameters 
    test2();
    // Using value and reference "objects" as lambda parameters
    test3();
    // lambda作为参数传入
    test4();
    // return a lambda
    test5();
    // using auto in lambda parameter list
    test6();
    // 在sort和for_each中使用lambda
	test7();
    
    std::cout << std::endl;
	return 0;
}
```



```c++
// Section 21
// Stateless lambda expressions
// [] - empty capture lists
#include <iostream>
#include <string>
#include <vector>
#include <functional>   // for std::function
#include <algorithm>

class Person {
    friend std::ostream &operator<<(std::ostream &os, const Person &rhs);
private:
    std::string name;
    int age;
public:
    Person(std::string name, int age) : name{name}, age{age} {};
    Person(const Person &p): name{p.name}, age{p.age} { }
    ~Person() = default;
    std::string get_name() const { return name; }
    void set_name(std::string name) {this->name = name; };
    int get_age() const {return age; }
    void set_age(int age) {this->age = age; }
};

std::ostream &operator<<(std::ostream &os, const Person &rhs) {
    os << "[Person: " <<rhs.name << " : " <<rhs.age << "]";
    return os;
}

void test1() {
    std::cout << "\n---Test1 --------------------------" << std::endl;

    [] () {std::cout << "Hi" << std::endl; }();
    
    [] (int x) { std::cout << x << std::endl;}(100);
    
    [](int x, int y) { std::cout << x+y << std::endl; }(100,200);
}

// Using values and references as lambda parameters 
void test2() {
    std::cout << "\n---Test2 --------------------------" << std::endl;
    
    auto l1 =   [] () {std::cout << "Hi" << std::endl;};
    l1();
    
    int num1 {100};
    int num2 {100};

    auto l2 = [](int x, int y) { std::cout << x+y << std::endl; };
    l2(10,20);
    l2(num1, num2);
    
    auto l3 = [](int &x, int y) {
        std::cout << "x: " << x << " y: " << y << std::endl;
        x = 1000;
        y = 2000;
    };
    
    l3(num1, num2);
    std::cout << "num1: " << num1 << " num2: " << num2 << std::endl;
}

// Using value and reference objects as lambda parameters
void test3() {
    std::cout << "\n---Test3 --------------------------" << std::endl;
    Person stooge {"Larry", 18};
    std::cout << stooge << std::endl;
    
    auto l4 = [] (Person p) {
        std::cout << p << std::endl; 
    };
    l4(stooge);
    
    auto l5 = [] (const Person &p) {
        std::cout << p << std::endl; 
    };
    l5(stooge);
    
    auto l6 = [] (Person &p) {
        p.set_name("Frank");
        p.set_age(25);
        std::cout << p << std::endl; 
    };
    l6(stooge);
    
    std::cout << stooge << std::endl;
    
}

// used for test4
// using std::function as a parameter in C++14 and greater
// or 
// auto as parameter type in C++20
void filter_vector(const std::vector<int> &vec, std::function<bool(int)> func)   {
//void filter_vector (const std::vector<int>  &vec, auto func) {
    std::cout <<"[ ";
    for (int i: vec) {
        if (func(i)) 
            std::cout << i  << " ";
    }
    std::cout << "]" << std::endl;
}

// passing a lambda to a function
void test4() {
    std::cout << "\n---Test4 --------------------------" << std::endl;
    std::vector<int> nums {10,20,30,40,50,60,70,80,90,100};
    
    filter_vector(nums, [](int x) {return x>50;});
    
    filter_vector(nums, [](int x) {return x<=30;});
    
    filter_vector(nums, [](int x) {return x>= 30 && x <=60;});
}

// used for test5
auto make_lambda() {
	return [] () {std::cout << "This lambda was made using the make_lambda function!" << std::endl;};
}

// returning a lambda from a function
void test5() {
	std::cout << "\n---Test5 --------------------------" << std::endl;
	
	auto l5 = make_lambda();
	
	l5();
}

// using auto in the lambda parameter list
void test6() {
    std::cout << "\n---Test6 --------------------------" << std::endl;
    auto l6 = [](auto x, auto y) {
        std::cout << "x: " << x << " y: " << y << std::endl;
    };
    
    l6(10,20);
    l6(100.3, 200);
    l6(12.5, 15.54);
    
    l6 (Person("Larry", 18), Person("Curly", 22));
}

// Simple lambda examples with std::sort and std::for_each
void test7() {
      std::cout << "\n---Test7 --------------------------" << std::endl;

    std::vector<Person> stooges {
        {"Larry", 18},
        {"Moe", 30},
        {"Curly", 25}
    };
    std::sort(begin(stooges), end(stooges), [](const Person &p1, const Person &p2) {
        return p1.get_name() < p2.get_name();
    });
    
    std::for_each(begin(stooges), end(stooges), [](const Person &p) {
        std::cout << p << std::endl;
    });
    
    std::cout << std::endl;
    
     std::sort(begin(stooges), end(stooges), [](const Person &p1, const Person &p2) {
        return p1.get_age()< p2.get_age();
    });
    
    std::for_each(begin(stooges), end(stooges), [](const Person &p) {
        std::cout << p << std::endl;
    });
}



```

