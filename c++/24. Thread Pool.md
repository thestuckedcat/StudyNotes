# 24. 线程池



## 24.1 最简单的线程池

* 固定数量的线程来处理工作
* 当有工作要做时，将其放入待处理工作的队列中
* 每一个worker thread从队列中获取工作，运行指定的任务，然后返回到队列寻找新的工作



![image-20240108100509572](./assets/image-20240108100509572.png)

```c++
namespace my_thread_pool {
	class join_threads {
		std::vector<std::thread>& threads;

	public:
		explicit join_threads(std::vector<std::thread>& _threads) :
			threads(_threads)
		{}

		~join_threads()
		{
			for (long i = 0; i < threads.size(); i++)
			{
				if (threads[i].joinable())
					threads[i].join();
			}
		}

	};

	class thread_pool {
		//用来停止所有线程的执行的标志，如果设置了，所有的线程都必须停止工作，代表我们将不再使用这个线程池
		std::atomic_bool done;

		//待处理工件队列，每个线程在完成当前任务后都会检查下一个线程。存入类型
		thread_safe_queue_space::thread_safe_queue<std::function<void()>> work_queue;
		
		//线程池
		std::vector<std::thread> threads;

		//保证对线程池中每一个线程的join
		join_threads joiner;

		void worker_thread() {
			//对于每个线程

			while (!done) {

				// 尝试从队列中取出任务
				// 若是成功取出任务，那么我们可以执行任务。
				// 若是取出任务失败，则可以yield这个线程，从而让给其他线程CPU空间。
				std::function<void()> task;
				if (work_queue.try_pop(task)) {

					task();
				}
				else {
					
					std::this_thread::yield();
				}
			}
		}
	public:

		thread_pool() :done(false), joiner(threads) {
			//我们拥有的线程数等于硬件支持的最大线程数
			const int thread_count = std::thread::hardware_concurrency();

			try {
				for (int i = 0; i < thread_count; i++) {
					// 第一个参数是一个指向成员函数worker_thread的指针，该成员函数定义了每个线程该做什么
					// 第二个参数指向的是这个线程池对象，这意味着新创建的线程将在这个线程池对象的上下文中运行worker_thread
					// 因为第一个参数调用的是成员函数，才需要第二个参数提供这个类的实例的上下文。
					// 调用的是如下构造函数
					/*
						template< class Function, class... Args >
						explicit thread( Function&& f, Args&&... args );
					*/

					threads.push_back(std::thread(&thread_pool::worker_thread, this));
				}
			}
			catch (...) {
				//包装线程的构造，如果发现异常可以简单的将done设置为true，这将指示其他线程结束运行。
				std::cout << "Error occurs, shut down all threads\n";
				done = true;
				throw;
			}
		}

		~thread_pool() {
			done = true;
		}

		template<typename Function_type>
		void submit(Function_type f) {
			//将任务推送到工作队列

			work_queue.push(std::function<void()>(f));
		}

	};

	void run() {
		//制造一百个任务分配给线程池
		thread_pool pool;
		std::cout << "Testing thread pool" << std::endl;

		for (int i = 0; i < 100; i++) {
			pool.submit([=] {
				printf("%d printed by thread - %d \n", i, std::this_thread::get_id());
				});
		}
		//在这个版本中，并没有等待所有任务完成的机制，因此将task全部压入后会直接调用析构函数，导致正在工作的线程全部停止。
		system("pause");

	}
}
```

* 在这个例子中，线程在等待一个任务完成（也就是说，在任务函数返回之前）时，不能去执行其他的任务。每个线程一次只能执行一个任务，直到这个任务完全完成后，线程才会检查是否有新的任务等待执行。在某些线程池的实现中，线程可以在执行一个长任务的同时，暂停该任务，去执行其他的（可能更短的）任务，然后再回来继续执行原任务。这种机制称为任务窃取（work stealing）。



这个里面的thread_safe_queue实现如下

```c++
namespace thread_safe_queue_space {
	template<typename T>
	class thread_safe_queue {
		std::mutex m;
		std::condition_variable cv;
		std::queue<std::shared_ptr<T>> queue;//为了避免因为资源约束产生的异常情况，使用了shared_ptr
	public:

		thread_safe_queue()
		{}

		thread_safe_queue(thread_safe_queue const& other_queue)
		{
			std::lock_guard<std::mutex> lg(other_queue.m);
			queue = other_queue.queue;
		}

		// 左值引用版本
		void push(const T& value) {
			std::lock_guard<std::mutex> lg(m);
			queue.push(std::make_shared<T>(value));
			cv.notify_one(); 
		}

		// 右值引用版本
		void push(T&& value) {
			std::lock_guard<std::mutex> lg(m);
			queue.push(std::make_shared<T>(value));
			cv.notify_one();
		}

		std::shared_ptr<T> pop() //combine pop and front
		{
			std::lock_guard<std::mutex> lg(m);
			if (queue.empty()) //避免pop和empty的竞争
			{
				return std::shared_ptr<T>();
			}
			else {
				std::shared_ptr<T> ref(queue.front());
				queue.pop();
				return ref;
			}
		}
		

		bool empty() {
			std::lock_guard<std::mutex> lg(m);
			return queue.empty();
		}

		std::shared_ptr<T> wait_pop() //不同于pop,wait_pop旨在实现一个指令队列，不是对当前状态的queue pop，而是总共一定需要pop执行多少指令
		{
			std::unique_lock<std::mutex> lg(m);
			cv.wait(lg, [this] {return !queue.empty(); });
			std::shared_ptr<T> ref = queue.front(); //拷贝初始化，效果与直接初始化ref(queue.front())一样
			queue.pop();
			return ref;
			/*
			第一个线程来执行这个等待函数，它将获取lock，并且检查队列是否为空
			如果不为空，这意味着如果队列铀元素，那么将进行下一个语句，也就是front和pop，同时保持对锁的控制权(holding the lock)
			如果队列为空，那么此条件失败，它将解锁与此唯一锁关联的互斥锁（以方便允许其他线程调用此等待），然后进入睡眠

			因此，可能出现这么一种情况，即多个线程都在等待队列中有一个元素
			当我们push后，这些线程的随机一个就会被唤醒，获得此唯一锁关联的锁，然后检查条件成功，然后继续执行
			当然，我们也可以使用notify_all，这样所有线程都将被唤醒，但是只有一个线程会被允许继续，因为只有一一个线程允许获取与此唯一锁关联的锁
			在该线程超出范围后，该锁将被释放，以便另一个被唤醒的线程可以在获取锁（notify_all是全部唤醒，排队检查),此时另一个线程获取锁的控制权，检查发现不行，接着睡。这里也能体现notify_all的消耗太大
			*/

		}
		size_t size()
		{
			std::lock_guard<std::mutex> lg(m);
			return queue.size();
		}
		//以下是返回该操作是否执行成功的版本，通过引用来获取pop的值
		bool wait_pop(T& ref)
		{
			std::unique_lock<std::mutex> lg(m);
			cv.wait(lg, [this] {
				return !queue.empty();
				});

			ref = *(queue.front().get());
			queue.pop();
			return true;
		}

		bool pop(T& ref)
		{
			std::lock_guard<std::mutex> lg(m);
			if (queue.empty())
			{
				return false;
			}
			else
			{
				ref = queue.front();
				queue.pop();
				return true;
			}
		}

		// 版本1: 返回std::shared_ptr<T>
		std::shared_ptr<T> try_pop() {
			std::lock_guard<std::mutex> lg(m);
			if (queue.empty()) {
				return std::shared_ptr<T>();
			}

			std::shared_ptr<T> ref(queue.front());
			queue.pop();
			return ref;
		}

		//版本2: 通过引用返回值，并返回操作是否成功的bool值
		bool try_pop(T& value) {
			std::lock_guard<std::mutex> lg(m);

			if (queue.empty()) {
				return false;
			}

			value = *(queue.front());
			queue.pop();
			return true;
		}

	};
```







## 24.2 等待任务完成

目标是修改之前的线程池实现，使得调用线程（即提交任务的线程）能够等待这些任务的完成。

采取的方法很简单，即将任务打包为“包任务（package tasks）”，并将这些打包后的任务提交到线程池。

具体来说，将在提交函数中创建“包任务”，然后将这些任务推送到工作队列。每个“包任务”都与一个“future”对象关联，这个对象将被返回给调用线程。

通过这些改动，调用线程可以通过返回的“future”对象来等待任务的完成。这样，调用线程便能知道何时任务完成，以及如何获取任务的结果。



### 24.2.1 一个小问题

> 212行
>
> ### 问题描述：
>
> 1. **工作队列类型**：原始的工作队列被定义为存储 `std::function<void()>` 对象。这意味着队列期望存储的是任何可以被调用且不返回任何值的可调用对象。
> 
> 2. **`std::function` 的要求**：`std::function` 需要其封装的可调用对象是==可拷贝的（copy constructible）==。换句话说，你需要创建一个可调用对象的副本并存储在 `std::function` 中。
>
> 3. **`std::packaged_task` 的性质**：然而，`std::packaged_task` 对象是不可拷贝的，只能被移动（move constructible）。这是因为一个任务的所有权和它的完成状态是唯一的，不能简单地被复制。当你尝试将 `std::packaged_task` 对象放入原始的工作队列时，==因为它们不满足 `std::function` 需要的可拷贝性质，所以会发生错误。尽管packaged_task也是一个可调用对象==
>
> 4. 更进一步的，可以用右值语义的push啊，需要注意的是需要显式的move
>
>    ```c++
>   std::queue<std::shared_ptr<T>> queue;
>    // 右值引用版本
>    void push(T&& value) {
>    	std::lock_guard<std::mutex> lg(m);
>    	queue.push(std::make_shared<T>(std::move(value));
>   	cv.notify_one();
>    }
>   ```
> 
>    第一次写一般问题可能出现在 `std::make_shared<T>(value)` 这一写法。`std::make_shared` 在创建 `shared_ptr` 时会尝试拷贝它的参数，而对于 `std::packaged_task` 来说，这是不允许的。
> 





