# 9. Controlling Program Flow

## Sequence: Ordering statements sequentially

## Selection: Making decisions

* **if** statement
* **if-else** statement
* **Nast(嵌套) if** statement
* **switch** statement(当if很长时用以替代)
  * ![image-20230821125621014](.\assets\image-20230821125621014.png)
* Conditional operator $?$
  * ![image-20230821134849820](.\assets\image-20230821134849820.png)
  * if true return expr1, if false return expr2
  * ![image-20230821135009366](.\assets\image-20230821135009366.png)

## Iteration: Looping or repeating

* **for** loop

  * ```c++
    for (initialization; condition; increment){
        statement(s);
    }
    
    for(int i{1} j{5};i<=5;i++,j++){
        
    }
    ```

* **ranged_based for** loop

  * 循环遍历一个元素集合

  * ```c++
    for(var_type var_name:sequence){
        statement
    }
    int scores[] {100,90,97};
    for (int score:scores){
        cout << score << endl;
    }
    //更广泛的
    for(auto score : scores){
    	cout << score << endl;
    }
    for(auto temp:{60.2, 80.1,90.0, 78.2}){
        
    }
    ```

  * 

* **while** loop

* **do-while** loop

* **continue** and **break**

* **Infinite** loops 

* **Nested loops**(loop within loop)

# switch常用配合：enum

`enum`（枚举）是C++中的一个关键字，用于定义一个枚举类型。枚举是一种用户定义的数据类型，它允许你为一组相关的命名值定义一个合法的值集合。这使得你可以使用这些命名值来表示变量，从而提高代码的可读性和可维护性。

### 基本的`enum`定义：

```c++
enum Color {
    RED,    // 0
    GREEN,  // 1
    BLUE    // 2
};

Color myColor = RED;
```

在上面的例子中，`Color`是一个枚举类型，它有三个可能的值：`RED`、`GREEN`和`BLUE`。默认情况下，第一个枚举值赋值为0，后续的枚举值依次增加1。但你也可以显式地为它们指定值。

### 指定枚举值：

```c++
enum Color {
    RED = 1,
    GREEN = 5,
    BLUE = 10
};
```

在这个例子中，`RED`的值是1，`GREEN`的值是5，`BLUE`的值是10。

### C++11中的`enum class`：

从C++11开始，引入了一种新的枚举类型：`enum class`（也称为强类型枚举）。它提供了更好的类型安全性和作用域。

```c++
enum class Color {
    RED,
    GREEN,
    BLUE
};

Color myColor = Color::RED;  // 使用Color::前缀来访问枚举值
```

与传统的`enum`不同，`enum class`的枚举值不会隐式地转换为整数，也不会与其他枚举或整数混淆，从而提供了更好的类型安全性。

总的来说，`enum`和`enum class`提供了一种表示一组命名值的方法，使得代码更加清晰和有意义。



### 作用

`enum`（枚举）在编程中有多种用途，主要是为了提高代码的可读性、可维护性和类型安全性。以下是使用枚举的一些主要原因和优势：

1. **提高代码可读性**：使用命名的常量代替魔法数字（硬编码的数字）可以使代码更容易理解。例如，使用`Color::RED`比使用数字`1`来表示红色更具有描述性。
2. **类型安全**：特别是使用C++11引入的`enum class`，它不允许隐式转换到其他类型，从而减少了因类型错误而导致的错误。
3. **代码维护**：如果需要更改某个枚举值，只需在枚举定义中更改它，而不必搜索和替换整个代码库中的所有实例。
4. **组织相关常量**：枚举允许你将一组相关的常量组织在一起，而不是散布在代码的各个地方。
5. **与`switch`语句配合**：当使用`switch`语句处理枚举值时，编译器可以警告你是否处理了所有可能的枚举值，从而帮助确保完整性。
6. **更紧凑的代码**：使用枚举可以避免为每个相关的常量单独声明一个`const`或`#define`。
7. **提供范围**：特别是对于`enum class`，它为枚举值提供了一个明确的范围，这有助于避免命名冲突。

在C++中，枚举类型是一种完全独立的类型，尽管其底层表示通常是整数。

但是，枚举的底层值是基于整数的。默认情况下，第一个枚举值（如 `MONDAY`）有一个底层值为0，后续的枚举值依次增加1（除非你显式地为它们指定其他值）。

尽管枚举的底层值是整数，但强类型枚举（`enum class`）增加了类型安全性，因此你不能直接将它们视为整数。例如，你不能直接将 `Day::MONDAY` 赋值给一个 `int` 变量，除非你显式地进行类型转换。

如果你想获取 `MONDAY` 的整数值，你可以这样做：

```c++
int value = static_cast<int>(Day::MONDAY);
```

但请注意，这样做会破坏类型安全性，因为你现在正在操作一个没有明确语义的整数值，而不是一个明确的 `Day` 枚举值。

总之，`MONDAY` 是 `Day` 类型的一个枚举值，但其底层表示是整数。



#### 指定枚举值的作用

指定枚举值的意义主要体现在以下几个方面：

1. **明确的值表示**：在某些情况下，枚举值可能与某些外部系统、文件或协议中的特定数字对应。为了确保一致性和正确的交互，你可能需要为枚举值指定确切的数字。

   例如，如果你正在与一个使用特定数字代码来表示错误的外部系统交互，你可以这样定义枚举：

   ```c++
   enum ErrorCode {
       SUCCESS = 0,
       FILE_NOT_FOUND = 404,
       SERVER_ERROR = 500
   };
   ```

2. **位操作**：在某些应用中，枚举值可能代表特定的位，这样你可以使用位操作来组合或检查多个值。

   ```c++
   enum Flags {
       NONE = 0,
       READ = 1 << 0,  // 0001
       WRITE = 1 << 1, // 0010
       EXECUTE = 1 << 2 // 0100
   };
   ```

   在这种情况下，你可以组合多个标志，例如 `READ | WRITE`，并使用位操作来检查、设置或清除特定的标志。

3. **可读性和文档**：指定枚举值可以提供额外的文档和上下文，使其他开发者更容易理解每个值的意义。

4. **避免未来的错误**：如果枚举的定义在未来可能会发生变化（例如，添加新的值），指定现有值可以确保它们不会因为添加或删除其他值而发生变化，从而避免潜在的错误。

5. **与其他语言或系统的兼容性**：在某些情况下，你可能需要与使用其他编程语言编写的代码或系统交互。指定枚举值可以确保跨语言或跨系统的一致性。

对于许多常见的用途，开发者主要关心的是枚举的符号名称（例如 `Color::RED`）而不是其底层的整数值。使用枚举的主要目的是为了提高代码的可读性和类型安全性，而不是为了其底层的整数表示。

但是，有些情况下，知道或操作这些底层的整数值是有用的：

1. **与外部系统交互**：当你的代码需要与其他系统、协议或文件格式交互时，这些系统可能期望接收特定的整数值。
2. **序列化和反序列化**：当将枚举值保存到文件或数据库，或从中读取时，通常会使用其整数表示。
3. **位操作**：如前所述，当枚举值代表特定的位标志时，操作其整数值是有意义的。
4. **调试和日志记录**：在调试或日志记录时，打印枚举的整数值可能有助于诊断问题。
5. **向后兼容性**：在软件开发中，如果API或数据格式在未来版本中发生变化，保持枚举值的稳定性可能很重要。

尽管在许多日常的编程任务中，你可能不直接关心枚举的整数值，但在上述特定情境中，它们是有意义的。如果你的用例不涉及这些情境，那么确实，你可能不需要关心或操作这些底层的整数值。