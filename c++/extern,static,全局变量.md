# 1. Static



在C++中，`static`关键字有多种用途，它的含义依上下文而定。下面是`static`在不同情况下的主要用途和含义：

### 1. 静态局部变量

在函数内部使用时，`static`声明的变量具有静态存储期。这意味着该变量在程序的执行期间只被初始化一次，并且它的值在函数调用之间保持不变。

```c++
void function() {
    static int counter = 0; // 只在首次调用function时初始化
    counter++;
    std::cout << counter << std::endl;
}
```

### 2. 静态类成员变量

在类定义中使用时，`static`声明的成员变量属于类本身，而不是类的任何特定实例。所有实例共享同一个静态成员变量。静态成员变量需要在类定义外部初始化。

```c++
class MyClass {
public:
    static int staticValue; // 静态成员变量声明
};

int MyClass::staticValue = 0; // 静态成员变量初始化
```

### 3. 静态类成员函数

`static`还可以用来声明类的成员函数。静态成员函数可以在没有类的实例的情况下被调用，且只能访问静态成员变量和其他静态成员函数。

```c++
class MyClass {
public:
    static void staticFunction() { // 静态成员函数
        std::cout << "Static function call" << std::endl;
    }
};
```

### 4. 静态全局变量和函数（文件作用域）

在全局变量或函数前使用`static`时，限制了它们的链接范围到定义它们的文件内部，使得它们在文件外部不可见，即不能被其他文件访问。

```c++
static int globalVariable = 0; // 只在本文件内可见

static void globalFunction() { // 只在本文件内可见
    // Function implementation
}
```

### 5. 未命名的命名空间

在现代C++代码中，使用未命名的命名空间来限制符号的可见性是一种比使用`static`更推荐的方式。未命名的命名空间提供了与静态全局变量和函数相似的效果，但是用于C++的命名空间中。

```c++
namespace {
    int globalVariable = 0; // 仅在本文件内可见
    void globalFunction() { // 仅在本文件内可见
        // Function implementation
    }
}
```







# 2. 全局变量


全局变量在C++（以及其他编程语言）中的确是定义在函数之外的变量，它们在整个程序的任何部分都可以被访问（前提是这些部分可以看到全局变量的声明）。然而，全局变量的“全局可用”并不意味着它们在程序的所有文件中自动可见。全局变量的可见性还受到其链接属性（链接性）的影响，这取决于变量是如何声明的。

### 静态链接全局变量（内部链接）

如果全局变量被声明为`static`，这意味着它只在定义它的文件中可见。这被称为内部链接性。即使其他文件中有同名的全局变量，它们也被视为完全不同的变量。

```c++
// file1.cpp
static int globalVar = 42; // 只在file1.cpp中可见

// file2.cpp
static int globalVar = 99; // 尽管名称相同，但这是一个完全不同的变量，只在file2.cpp中可见
```

### 外部链接全局变量（外部链接）

默认情况下，全局变量具有外部链接性，意味着它们在其他文件中是可见的，只要在那些文件中提供了适当的声明。这通常通过在一个文件中定义全局变量，然后在其他需要访问该变量的文件中使用`extern`关键字来声明它。

```c++
// file1.cpp
int globalVar = 42; // 默认外部链接，可以在其他文件中通过extern关键字访问

// file2.cpp
extern int globalVar; // 声明file1.cpp中的全局变量，现在可以在file2.cpp中使用它
```

### 使用全局变量的注意事项

1. **可见性和链接性**：全局变量的可见性受到其链接性的影响。使用`static`声明的全局变量具有内部链接性，而未使用`static`声明的全局变量具有外部链接性。
2. **命名冲突**：在不同文件中使用相同名称的全局变量时要小心，尤其是当它们具有外部链接性时。这可能导致链接错误或意外的行为。
3. **使用限制**：虽然全局变量在某些情况下很有用，但过度使用全局变量会使得代码难以理解和维护。它们增加了代码的耦合度，可能导致不可预见的依赖和错误。

综上所述，全局变量的“全局可用”并非无条件的，它们的实际可见性和作用范围取决于链接性的具体设置。在设计软件时，应当谨慎使用全局变量，并考虑到它们对软件结构和可维护性的影响。





# 3. extern

如果在其他文件中不使用`extern`关键字声明一个全局变量，那么这个变量在那个文件中是不可见的。`extern`关键字用于在一个文件中声明一个变量，表明该变量的定义在另外的文件中。这样，编译器知道该变量存在，尽管它在当前文件中没有定义。

### 示例

假设有两个文件：`file1.cpp`和`file2.cpp`。

在`file1.cpp`中定义了一个全局变量：

```c++
// file1.cpp
int globalVar = 42;
```

要在`file2.cpp`中访问这个变量，你需要使用`extern`关键字来声明它：

```c++
// file2.cpp
extern int globalVar; // 声明，不是定义

void printGlobalVar() {
    std::cout << globalVar << std::endl; // 使用file1.cpp中定义的全局变量
}
```

如果在`file2.cpp`中没有使用`extern`声明`globalVar`，尝试直接使用它将导致编译错误，因为编译器找不到这个变量的定义。

### 不使用`extern`的情况

如果在`file2.cpp`中直接尝试使用`globalVar`而不先声明它，编译器将报告一个错误，提示未定义的标识符。这是因为每个文件都被编译器视为一个独立的编译单元，在没有适当声明的情况下，编译器无法知道其他编译单元中定义的变量。