来自cppcon

##### 需要在头文件中完整定义

Template are usually **defined** in header file

* Not only declared
* No inline necessary

如果headfile只声明了template，会有一个link error

![image-20240427181559062](./assets/image-20240427181559062.png)





##### auto Parameter for Ordinary functions

自从C++20以来，允许参数类型以auto传入

这其实也是template的一种，只不过它虽然方便，但是并没有表面看起来这么好：如果你在函数内需要这个类型，你需要手动去询问传入参数的类型。



![image-20240427181930764](./assets/image-20240427181930764.png)



> 在 C++20 中引入的新特性，允许在普通函数参数中使用 `auto` 关键字，实际上是将这些函数隐式地转化为函数模板。
>
> ### 隐式函数模板
>
> 当你在函数参数中使用 `auto` 关键字时，如 `void function(auto input)`，这个函数实际上是一个模板函数，其行为类似于下面显式定义的模板：
>
> ```c++
> template<typename T>
> void function(T input) {
>     // 函数体
> }
> ```
>
> 这意味着，使用 `auto` 关键字的函数在被调用时会根据提供的参数类型自动实例化，这和传统的模板函数行为一致。
>
> ### 在头文件中的实现
>
> 由于这类函数实际上是模板，==它们通常需要在头文件中完全定义（实现），==以确保在编译时可以适当地实例化。这一点与传统的模板函数相同。如果你将这类函数的定义放在源文件中，那么编译器在处理其他源文件时可能无法访问到模板定义，导致链接错误。



> 另一个很容易和隐式函数模板混淆的其实是==返回类型推断==。
>
> 在 C++ 中，使用 `auto` 作为普通函数的返回类型并不是创建模板函数，但它是利用 C++11 后引入的尾返回类型（trailing return type）特性或者 C++14 的返回类型推导来使函数能够自动推导其返回类型。
>
> ### C++11 的尾返回类型
>
> 在 C++11 中，可以使用 `auto` 关键字配合 `->` 操作符来指定函数的返回类型，这通常用在返回类型依赖于函数参数的场景中。这样做的好处是在函数签名中就能明确知道返回类型，而不必等到函数体的实现。这种情况下，尾返回类型可以让代码更清晰：
>
> ```c++
> #include <type_traits>
> 
> template <typename T, typename U>
> auto add(T t, U u) -> decltype(t + u) {
>     return t + u;
> }
> ```
>
> ### C++14 的返回类型推导
>
> 从 C++14 开始，可以直接使用 `auto` 作为函数的返回类型，编译器将会自动推导返回类型，这类似于自动变量的类型推导。这使得编写函数变得更简洁，特别是当返回类型很复杂或难以手动指定时：
>
> ```c++
> #include <vector>
> 
> auto getVector() {
>     return std::vector<int>{1, 2, 3};
> }
> ```
>
> 在这里，`getVector` 函数的返回类型会被自动推导为 `std::vector<int>`。
>
> ### 是否需要在头文件中实现？
>
> 对于使用 `auto` 返回类型的函数，==它们不是模板函数==，除非显式地使用了模板参数。当你使用 `auto` 作为返回类型，而函数本身不是模板函数时，你可以在头文件中声明函数，在源文件中实现它，就像普通函数一样：
>
> ```c++
> // header.h
> auto getNumber() -> int;  // 尾返回类型声明
> 
> // source.cpp
> #include "header.h"
> 
> auto getNumber() -> int {
>     return 42;
> }
> ```
>
> 但如果函数是模板函数，或者其返回类型依赖于模板参数，那么通常需要在头文件中提供实现，这是因为编译器需要在模板实例化时看到完整的定义。













##### template中的隐式要求

==**写类模板时**==

考虑到你传入的类型可能是一个自定义类，那么你要好好注意你的函数实现是否和类相悖。

例如，如下的函数要求传入的T有两个性质：

* 能够进行比较
* copyable（无论是传入还是return都需要）

![image-20240427183436502](./assets/image-20240427183436502.png)

例如，假设complex类没有定义less than，因此会出现error

![image-20240427183807368](./assets/image-20240427183807368.png)



另一个例子是`std::atomic`

`std::atomic` 类型被设计用来提供原子操作，主要用于多线程编程中以确保对单个变量的操作是原子性的，即不可中断。由于它们的这种特殊性质和用途，`std::atomic` 对象具有一些限制，包括不能被拷贝构造、赋值、移动和比较。这些限制有助于避免在多线程环境中可能导致数据竞争和同步问题的操作。

```c++
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;

atomic(atomic&&) = delete;
atomic& operator=(atomic&&) = delete;


/*

至于比较，C++20 之前的标准中并没有定义 std::atomic 类型的比较运算符。这是因为在多线程环境中，比较两个原子类型的值本身就可能面临竞态条件——两个值可能在比较的过程中被修改。C++20 引入了对原子类型进行比较的支持，但这需要显式地使用成员函数（如 load()）来获取当前的值，并在获取值的瞬间进行比较，而不是直接比较两个 std::atomic 对象。

*/
```

![image-20240427184136274](./assets/image-20240427184136274.png)







==**使用类模板时**==

![image-20240427183659048](./assets/image-20240427183659048.png)

第一个无法自动推断，因为传入类型不同，你可以手动指定



