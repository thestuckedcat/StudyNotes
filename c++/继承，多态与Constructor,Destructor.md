继承是 Derived a = new Derived()
它申请了一个包含所需成员变量[Base::Member | Derived::Member]的内存空间



多态 Base *a = static_cast<Base*>(new Derived())
它因为基类拥有虚函数（无论是几个），因此method的指向需要额外说明
它申请了一个包含指向method的指针数组，以及所需成员变量的内存空间
[vtable|Base::Member|Derived::Member]





**首先看继承**，当创建Derived对象时，编译器自动的改变了构造函数和析构函数，插入了基类的构造函数和析构函数

```c++
Derived(){
    //基类构造函数
	Base()
	//派生类自己的构造函数实现
	//
}

~Derived(){
	//派生类自己的析构函数实现
    //
    
    // 基类析构函数
	~Base();
}
```

这一点是继承自身的属性，这使得能够从派生类开始依次析构，或者从基类开始依次构造



**在多态时，情况发生了变化**
首先，vtable中包含了所有的method的地址，如果使用了虚函数就指向派生类method，如果没使用就指向基类method，如果派生类新增了函数那么就依次添加到vtable之后
此时，构造函数与析构函数也是作为method添加进vtable的



可以发现，在使用多态的时候，你必须声明一个Derived()，也就是调用Derived**构造函数**返回你类的地址，此时它自动的调用了Derived构造和Base构造。也就是说，如果你需要使用多态，那么这个函数你是指定的，根本就用不上虚表



但是，**在析构时**，情况发生了变化，你必须显式的指定~Derived()，以求递归的执行派生类析构和基类析构，否则的话，你永远只会执行基类虚构（因为以基类指针多态来访问派生类，因此vtable中默认是基类指针）。这也就是为什么析构函数必须要使用虚函数。换句话说，这里的虚析构只是为了在这个特定的vtable实现方法下，让继承的那种递归析构继续起作用。

