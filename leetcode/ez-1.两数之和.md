# 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]


提示：

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案


进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# C++

> vector， map

利用Hashmap记录整数数组集的值，利用find(target-nums[i])快速查找，避免遍历。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hashmap;
        int len = nums.size();
        for(int i = 0; i<len;i++){
            if(hashmap.find(target - nums[i]) != hashmap.end()){
                return {hashmap[target-nums[i]], i};
            }else{
                hashmap[nums[i]] = i;
            }
        }
        return {0,1};    
    }
    
};
```

**==注意==**：

在 C++ 中，`map` 和 `unordered_map`（hash 表）是两种不同的关联容器，它们提供了键值对的存储和检索功能。它们的复杂度如下：

对于 `map`（红黑树实现）：

- 插入操作（`insert`）的平均时间复杂度为 O(log n)，其中 n 是 `map` 中元素的数量。
- 查找操作（`find`）的平均时间复杂度为 O(log n)。
- 删除操作（`erase`）的平均时间复杂度为 O(log n)。

对于 `unordered_map`（哈希表实现）：

- 插入操作（`insert`）的平均时间复杂度为 O(1)。
- 查找操作（`find`）的平均时间复杂度为 O(1)。
- 删除操作（`erase`）的平均时间复杂度为 O(1)。

需要注意的是，上述的时间复杂度是指在平均情况下的时间复杂度。在最坏情况下，特别是当哈希表出现冲突时，`unordered_map` 的操作可能会变慢，但仍然具有较高的概率在常数时间内完成。

因此，如果对于插入和查找操作的性能要求很高，且不需要按照特定顺序访问元素，可以选择使用 `unordered_map` 来获得更好的性能。如果需要按照键的顺序进行遍历或有序访问，或者对于较小的数据集，可以选择使用 `map`。

> `unordered_map` 的平均插入、查找和删除操作的时间复杂度为 O(1)，即常数时间复杂度。这是因为 `unordered_map` 是通过哈希表实现的。
>
> 哈希表是一种使用哈希函数将键映射到桶（bucket）的数据结构。它利用哈希函数计算键的哈希值，并将其映射到存储桶的位置。因此，在哈希表中，插入、查找和删除操作的时间复杂度不依赖于元素数量，而是依赖于哈希函数的性能和哈希表的负载因子。
>
> 当负载因子保持较低时，哈希表能够提供接近 O(1) 的平均操作复杂度。负载因子是指哈希表中存储元素的数量与桶的数量之间的比率。较低的负载因子意味着每个桶中存储的元素较少，减少了哈希冲突的可能性。
>
> 在 C++ 的 `unordered_map` 中，默认情况下，负载因子为 1.0。当哈希表中的元素数量超过桶的数量时，会自动进行扩容，重新分配更多的桶，以保持较低的负载因子。这样可以确保在大多数情况下，哈希表的性能仍然能够接近常数时间复杂度。
>
> 然而，需要注意的是，在最坏的情况下，当哈希函数存在冲突时，插入、查找和删除操作的时间复杂度可能会变为 O(n)，其中 n 是哈希表中的元素数量。这是因为多个键被映射到同一个桶，需要进行线性搜索来处理冲突。为了避免最坏情况的出现，选择一个良好的哈希函数和适当的哈希表大小是重要的。
>
> 综上所述，`unordered_map` 之所以能够实现接近 O(1) 的操作，是因为哈希表的特性和适当的负载因子管理，但需要注意处理哈希冲突的情况可能会增加操作的时间复杂度。

## 哈希函数

> 哈希函数是将键（key）映射到桶（bucket）的算法或函数。在哈希表中，每个桶存储一个或多个键值对，通过哈希函数计算键的哈希值，将其映射到特定的桶。
>
> 以下是哈希函数将键映射到桶的一般过程：
>
> 1. 哈希函数接收一个键作为输入。
> 2. 哈希函数对键执行计算，生成一个哈希值。
> 3. 哈希值通常是一个整数，它表示键的唯一标识。
> 4. 哈希表根据哈希值确定键值对应该存储在哪个桶中。
> 5. 将键值对存储在所确定的桶中。
>
> 需要注意的是，一个好的哈希函数应该具备以下特性：
>
> 1. 唯一性：不同的键应该生成不同的哈希值，以尽可能减少哈希冲突的可能性。
> 2. 均匀性：哈希函数应该尽量将键均匀地映射到桶中，以避免出现热点桶（存储过多的键值对）。
> 3. 效率：哈希函数应该具有高效的计算性能，以确保在常数时间内计算哈希值。
>
> 在 C++ 的 `unordered_map` 中，默认情况下，使用 STL 提供的哈希函数来计算键的哈希值。对于内置的数据类型（如整型、浮点型、指针等），哈希函数已经在 C++ 标准库中定义好了。而对于自定义类型，可以通过提供自定义的哈希函数来指定键的哈希计算方式。
>
> C++ 标准库中的哈希函数可以通过 `std::hash` 模板类来访问。例如，`std::hash<int>` 可以用于计算整数类型的哈希值。
>
> ```
> cppCopy code#include <iostream>
> #include <unordered_map>
> 
> int main() {
>     std::unordered_map<int, std::string> myMap;
>     myMap.insert({42, "Hello"});
>     
>     std::hash<int> hasher;
>     std::size_t hashValue = hasher(42);
>     std::cout << "Hash value of 42: " << hashValue << std::endl;
>     
>     return 0;
> }
> ```
>
> 在上述示例中，使用 `std::hash<int>` 创建了一个哈希函数对象 `hasher`，然后通过调用 `hasher(42)` 计算整数 42 的哈希值，并将其输出到控制台。
>
> 自定义类型的哈希函数可以通过重载 `std::hash` 模板类的特化版本来实现。具体的实现方式会涉及到该类型的特定属性和哈希计算的需求。
>
> 总结起来，哈希函数是将键映射到桶的关键部分，它通过对键执行计算生成

## 哈希常用的桶

桶（bucket）的概念通常用来表示数据结构中的存储单元或容器，而不是指实际的物理内存存储单元。

在哈希表等数据结构中，桶用于逻辑上划分和组织存储空间，用于存储元素或键值对。桶可以是数组、链表、红黑树等数据结构，用于存储相应的元素。

具体而言，桶可以是一个数组的元素，每个元素存储一个键值对或元素。在链表实现的哈希表中，每个桶是一个链表节点，用于存储一个键值对。在红黑树实现的哈希表中，每个桶是一棵红黑树，用于存储多个键值对。

因此，桶可以看作是逻辑上的存储单元，用于组织和存储数据。它们提供了对元素的访问、插入、删除等操作。

需要注意的是，桶的具体实现和内存存储细节可能因不同的数据结构而有所不同。桶的大小和存储方式可能会因实现方式而异。但在一般的理解中，桶是用来划分和组织存储空间的逻辑单位，而不是指具体的物理内存单元。



在哈希表中，常用的桶（bucket）实现包括以下几种：

1. 数组桶：最简单的桶实现方式是使用数组。哈希表的每个桶都是一个数组元素，可以直接通过索引来访问和存储元素。这种实现方式在空间连续、访问速度快的情况下效果较好。
2. 链表桶：链表桶是使用链表来实现的桶。每个桶存储一个键值对，并使用链表连接多个键值对，以处理哈希冲突。当多个键映射到同一个桶时，新的键值对可以添加到链表的末尾，从而实现高效的插入和删除操作。
3. 红黑树桶：红黑树桶使用红黑树（或其他平衡二叉搜索树）来实现。它在处理哈希冲突时，将键值对存储在一棵有序的树结构中。通过红黑树的平衡性质，可以保持较好的查找、插入和删除性能。
4. 开放寻址法桶：开放寻址法是一种解决哈希冲突的技术，其中桶本身就是存储位置。当发生冲突时，新的键值对可以在哈希表中的其他位置继续探测，直到找到一个可用的位置。这种实现方式不涉及链表或树结构，可以节省一些空间，并在某些情况下提供更好的缓存性能。

在 C++ 的标准库中，`unordered_map` 和 `unordered_set` 使用链表桶作为默认实现。这意味着当多个键映射到同一个桶时，键值对会使用链表连接起来。对于需要保持有序性或处理更复杂的情况，可以使用 `map` 和 `set`，它们使用红黑树桶来实现。

## 负载因子

负载因子（load factor）是哈希表中的一个概念，用于衡量哈希表中存储元素的密度或填充程度。它表示已经存储的元素数量与哈希表容量之间的比值。

负载因子可以用以下公式表示：

负载因子 = 已存储元素数量 / 哈希表容量

换句话说，负载因子告诉我们哈希表当前有多少个桶被占用或使用了。例如，负载因子为0.5表示哈希表已经使用了一半的桶。

负载因子的值通常介于 0 到 1 之间，但可以大于 1。以下是负载因子的几种常见情况：

1. 负载因子小于 0.5：表示哈希表中的元素较少，还有很多空闲桶可用。这种情况下，哈希表通常具有较低的冲突率，插入、查找和删除操作的性能可能较好。
2. 负载因子接近 1：表示哈希表中的元素数量接近或达到了哈希表容量。这意味着大部分桶已经被占用。在这种情况下，哈希冲突的可能性会增加，可能会导致性能下降。
3. 负载因子大于 1：表示哈希表中的元素数量超过了哈希表容量。这意味着哈希表中至少有一个桶包含多个键值对。这种情况下，哈希冲突的数量将显著增加，可能会导致性能下降。

选择适当的负载因子是设计和使用哈希表时需要考虑的重要因素。较低的负载因子可以提供较低的冲突率和更好的性能，但会占用更多的内存空间。较高的负载因子可以充分利用空间，但可能会导致更多的哈希冲突和性能下降。

在 C++ 的 `unordered_map` 和 `unordered_set` 中，默认的负载因子为 1.0，即当哈希表中的元素数量达到哈希表容量时进行扩容。可以通过调整负载因子来控制哈希表的性能和内存使用之间的权衡。

## 解决负载因子大于1

当哈希表的负载因子超过 1 时，意味着哈希表中的元素数量超过了哈希表的容量，至少有一个桶包含多个键值对，出现了哈希冲突。在这种情况下，哈希表需要采取一定的策略来解决冲突。

常见的冲突解决策略有以下几种：

1. 链表法（Separate Chaining）：这是一种常见的解决冲突的方法。当多个键值对哈希到同一个桶时，每个桶中存储一个链表（或其他数据结构），将所有哈希到该桶的键值对连接在一起。新的键值对可以添加到链表的末尾。这样，即使发生冲突，仍然可以在同一个桶中高效地存储和检索元素。
2. 开放寻址法（Open Addressing）：这是另一种常用的冲突解决策略。当发生冲突时，新的键值对会尝试在哈希表中的其他位置进行探测，直到找到一个可用的位置。探测的位置可以使用线性探测、二次探测、双重哈希等方法确定。这种方法不需要额外的链表结构，直接存储在哈希表中，可以节省一些空间。常见的开放寻址法的变体包括线性探测、二次探测、双重哈希等。
3. 再哈希法（Rehashing）：当负载因子超过某个阈值时，哈希表可以选择进行扩容（增加桶的数量），并重新哈希所有的键值对。这样可以减小负载因子，使哈希表重新分布键值对，减少冲突的可能性。再哈希法的实现通常会选择一个新的桶数量，通常是原来桶数量的两倍或更大。

这些冲突解决策略的选择取决于具体的哈希表实现和应用场景。链表法适用于处理频繁的哈希冲突，允许存储大量的键值对。开放寻址法可以节省一些空间，并且在某些情况下具有更好的缓存性能。再哈希法可以通过调整哈希表容量来平衡性能和空间使用。

在 C++ 的 `unordered_map` 和 `unordered_set` 中，常用的解决冲突的方法是链表法（Separate Chaining）。当多个键值对哈希到同一个桶时，它们会以链表的形式连接在一起。这样可以在常数时间内

## Hashmap与bucket数量



在哈希表创建时，通常需要指定初始的桶数量（或者称为哈希表的容量）。桶数量的选择可以根据预估的元素数量和负载因子进行决定。

然而，在一些哈希表的实现中，桶数量并非固定不变。当哈希表中的元素数量超过一定阈值（如负载因子达到或超过某个值）时，哈希表可能会进行扩容操作，增加桶的数量。这是为了保持较低的负载因子，减少冲突的可能性，并保持较好的性能。

扩容操作通常涉及重新计算已有元素的哈希值，并将它们重新分配到新的桶中。这样可以使哈希表重新平衡，减少冲突，并提高性能。

因此，哈希表的桶数量在创建时可以指定初始值，但在运行时可能会发生变化，根据哈希表的实现策略和需要进行动态扩容或收缩。具体的实现细节取决于哈希表的设计和库的实现。