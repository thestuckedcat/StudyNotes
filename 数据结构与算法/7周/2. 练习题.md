# 必修题

## 15. 三数之和（第一次做有点难度）

![image-20240116201534134](./assets/image-20240116201534134.png)

方法就是先==排序==，然后一层循环套双指针搜索

```c++
class Solution {
public:
    // 考虑到a+b+c，a和b确定了那么c就是唯一的
    // 因此，按我们的方法，以a为开头的所有情况都在循环内找到了，因此a在循环中不能相同
    // 同理，b也不能相同
    // 同理，c也不能相同

    void double_pointer(int i, vector<int>& nums, vector<vector<int>>& result){
        //这个函数的作用是在给定i的情况下，双指针搜索空间
        //对于每个固定的nums[i], j和end就是双指针搜索
        int end = nums.size() - 1;
        for(int j = i+1; j < nums.size();j++){
                // i+1是因为，如果存在,我们一定能够搜索出带nums[i]的序列，找不到nums[i]就直接被丢弃了
                
                if(j > i+1 && nums[j] == nums[j-1]) continue;

                while(nums[j] + nums[end] + nums[i] >= 0 && end > j){
                    
                    if(nums[j] + nums[end]+nums[i] == 0){
                        
                        //result.emplace_back{nums[j],nums[end],nums[i]};
                        result.push_back(std::vector<int> {nums[i], nums[j], nums[end]});
                        
                        //删掉所有的相同end
                        while(nums[end] == nums[end-1] && end > j){
                            end--;
                        }
                    }
                    end--;
                
                }

            }
            return;
    }
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        std::sort(nums.begin(), nums.end());

        for(int i = 0; i < nums.size();i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            double_pointer(i, nums, result);
            
        }
        /*
        result.erase(
            std::remove_if(result.begin(),result.end(),[](const std::vector<int>& v){return v.empty();}),
            result.end());
*/
        
        return result;
    }
};
```













## 26. 删除有序数组中的重复象

具TM简单，数组复用，整一个指针标识哪些没用了就好了。

![image-20240116202137909](./assets/image-20240116202137909.png)

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        //有效数组长度
        int end = 1;
        for(int i = 1 ; i < nums.size();i++){
            if(nums[i] == nums[i-1]){
                continue;
            }
            else{
                nums[end++] = nums[i];
            }
        }
        return end;
    }
};
```











## 48. 旋转图像（记住即可）

没什么好说的，在本来的矩阵中旋转图像顺时针90°，就是先转置后对每行翻转

注意转置的范围是`for(i=0;i < n;i++) for(j=0;j < i;j++)`

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        //转置
        for(int i = 0;i < matrix.size();i++){
            for(int j = 0;j < i;j++){
                std::swap(matrix[i][j], matrix[j][i]);
            }
        }

        //翻转每一行
        for(int i = 0; i < matrix.size();i++){
            std::reverse(matrix[i].begin(),matrix[i].end());
        }
    }
};
```











## 914. 卡牌分组（最大公约数怎么写）



统计+寻找最大公约数

记住最大公约数的欧几里得解法即可

欧几里得算法基于一个事实：两个整数的最大公约数和它们的差的最大公约数相同。算法可以表述为以下步骤：

假设有两个正整数 `a` 和 `b`（其中 `a > b`），则 `a` 和 `b` 的最大公约数等于 `b` 和 `a % b`（`a` 除以 `b` 的余数）的最大公约数。算法重复这个过程，直到余数为 0。当余数为 0 时，最后的非零余数就是最大公约数。

#### 实现（递归版本）：

```c++
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
```

#### 实现（迭代版本）：

```c++
int gcd(int a, int b) {
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}
```

```c++
class Solution {
public:
    int gcd(int a, int b){
        if(b == 0)
            return a;
        return gcd(b,a%b);
    }
    bool hasGroupsSizeX(vector<int>& deck) {
        if(deck.size() < 2){
            return false;
        }
        
        // 获得计数
        std::unordered_map<int, int> u;
        int gcd_ = -1;
        for(int i = 0; i < deck.size();i++){
            if(u.find(deck[i]) == u.end()){
                u[deck[i]] = 1;
            }else{
                u[deck[i]] = u[deck[i]] + 1;
                
            }
        }
        
        //寻找最大公约数
        for(const auto &pair:u){
            if(gcd_ < 0){
                gcd_ = pair.second;
                continue;
            }
            int max_ = max(gcd_, pair.second);
            int min_ = min(gcd_, pair.second);

            gcd_ = gcd(max_, min_);
            if(gcd_ < 2){
                return false;
            }
        }
        return true;
    }
};
```













## 232. 用栈实现队列

只能使用栈的pop,push,top,empty,

```c++
class MyQueue {
    std::stack<int> stk1;//for push
    std::stack<int> stk2;//for pop

    void reverse_and_swap(){
        int temp;
        if(stk1.empty()){
            while(!stk2.empty()){
                temp = stk2.top();
                stk2.pop();
                stk1.push(temp);
            }
        }else if(stk2.empty()){
            while(!stk1.empty()){
                temp = stk1.top();
                stk1.pop();
                stk2.push(temp);
            }
        }
    }
public:
    MyQueue() {

    }
    
    void push(int x) {
        if(!stk2.empty()){
            reverse_and_swap();
        }
        stk1.push(x);
    }
    
    int pop() {
        if(!stk1.empty()){
            reverse_and_swap();
        }
        int temp = stk2.top();
        stk2.pop();
        return temp;
    }
    
    int peek() {
        if(!stk1.empty()){
            reverse_and_swap();
        }
        return stk2.top();
        
    }
    
    bool empty() {
        return stk1.empty() && stk2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```





## 414. 第三大的数

z最简单的解法：排序遍历

```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        std::sort(nums.begin(),nums.end(),[](int a, int b){
            return a > b;
        });

        int size = 2;
        for(int i = 1; i < nums.size();i++){
            if(nums[i] != nums[i-1])
            {
                size--;
            }
            if(!size){
                return nums[i];
            }
        }
        return nums[0];
    }
};
```

O(n)的简单解法1

遍历同时维护三个数

```c++
class Solution {
public:
    int thirdMax(vector<int> &nums) {
        long a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;
        for (long num : nums) {
            if (num > a) {
                c = b;
                b = a;
                a = num;
            } else if (a > num && num > b) {
                c = b;
                b = num;
            } else if (b > num && num > c) {
                c = num;
            }
        }
        return c == LONG_MIN ? a : c;
    }
};

```



O(n)简单解法2

有序容器set

查找、插入和删除操作的时间复杂度为 O(log n)。

由于有序集合的大小至多为 3，插入和删除的时间复杂度可以视作是 O(1) 的，因此时间复杂度为 O(n)。

set自动去重排序

```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        std::set<int> result;
        for(const int& num:nums){
            result.insert(num);
            if(result.size() > 3){
                result.erase(result.begin());
            }
        }
        if(result.size() < 3){
            return *result.rbegin();//注意不能使用end，要使用reversebegin
        }
        return *result.begin();
    }
};
```







# 选修题

## 206. 翻转链表



迭代实现，自己别脑子混了就行。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    
public:
    ListNode* reverseList(ListNode* head) {
        //单节点实例,注意需要head判断在前，不然会出现对nullptr访问成员
        if( head == nullptr || head->next == nullptr){
            return head;
        }


        //首节点设置
        //设置上一个节点
        ListNode* LastNode = head;
        //设置下一个节点
        ListNode* NextNode = head->next;

        head->next = nullptr;

        head = NextNode;
        
        while(head->next != nullptr){
            NextNode = head->next;
            //翻转
            head->next = LastNode;

            LastNode = head;

            head = NextNode;
        }

        //尾节点设置
        head->next = LastNode;
        return head;
    }
};
```





