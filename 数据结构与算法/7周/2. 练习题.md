# 必修题

## 15. 三数之和（第一次做有点难度）

![image-20240120143427427](./assets/image-20240120143427427.png)

方法就是先==排序==，然后一层循环套双指针搜索

```c++
class Solution {
public:
    // 考虑到a+b+c，a和b确定了那么c就是唯一的
    // 因此，按我们的方法，以a为开头的所有情况都在循环内找到了，因此a在循环中不能相同
    // 同理，b也不能相同
    // 同理，c也不能相同

    void double_pointer(int i, vector<int>& nums, vector<vector<int>>& result){
        //这个函数的作用是在给定i的情况下，双指针搜索空间
        //对于每个固定的nums[i], j和end就是双指针搜索
        int end = nums.size() - 1;
        for(int j = i+1; j < nums.size();j++){
                // i+1是因为，如果存在,我们一定能够搜索出带nums[i]的序列，找不到nums[i]就直接被丢弃了
                
                if(j > i+1 && nums[j] == nums[j-1]) continue;

                while(nums[j] + nums[end] + nums[i] >= 0 && end > j){
                    
                    if(nums[j] + nums[end]+nums[i] == 0){
                        
                        //result.emplace_back{nums[j],nums[end],nums[i]};
                        result.push_back(std::vector<int> {nums[i], nums[j], nums[end]});
                        
                        //删掉所有的相同end
                        while(nums[end] == nums[end-1] && end > j){
                            end--;
                        }
                    }
                    end--;
                
                }

            }
            return;
    }
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        std::sort(nums.begin(), nums.end());

        for(int i = 0; i < nums.size();i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;
            double_pointer(i, nums, result);
            
        }
        /*
        result.erase(
            std::remove_if(result.begin(),result.end(),[](const std::vector<int>& v){return v.empty();}),
            result.end());
*/
        
        return result;
    }
};
```













## 26. 删除有序数组中的重复象

具TM简单，数组复用，整一个指针标识哪些没用了就好了。

![image-20240120143447634](./assets/image-20240120143447634.png)

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        //有效数组长度
        int end = 1;
        for(int i = 1 ; i < nums.size();i++){
            if(nums[i] == nums[i-1]){
                continue;
            }
            else{
                nums[end++] = nums[i];
            }
        }
        return end;
    }
};
```











## 48. 旋转图像（记住即可）

![image-20240120143501532](./assets/image-20240120143501532.png)

没什么好说的，在本来的矩阵中旋转图像顺时针90°，就是先转置后对每行翻转

注意转置的范围是`for(i=0;i < n;i++) for(j=0;j < i;j++)`

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        //转置
        for(int i = 0;i < matrix.size();i++){
            for(int j = 0;j < i;j++){
                std::swap(matrix[i][j], matrix[j][i]);
            }
        }

        //翻转每一行
        for(int i = 0; i < matrix.size();i++){
            std::reverse(matrix[i].begin(),matrix[i].end());
        }
    }
};
```











## 914. 卡牌分组（最大公约数怎么写）

![image-20240120143509715](./assets/image-20240120143509715.png)

统计+寻找最大公约数

记住最大公约数的欧几里得解法即可

欧几里得算法基于一个事实：两个整数的最大公约数和它们的差的最大公约数相同。算法可以表述为以下步骤：

假设有两个正整数 `a` 和 `b`（其中 `a > b`），则 `a` 和 `b` 的最大公约数等于 `b` 和 `a % b`（`a` 除以 `b` 的余数）的最大公约数。算法重复这个过程，直到余数为 0。当余数为 0 时，最后的非零余数就是最大公约数。

#### 实现（递归版本）：

```c++
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
```

#### 实现（迭代版本）：

```c++
int gcd(int a, int b) {
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}
```

```c++
class Solution {
public:
    int gcd(int a, int b){
        if(b == 0)
            return a;
        return gcd(b,a%b);
    }
    bool hasGroupsSizeX(vector<int>& deck) {
        if(deck.size() < 2){
            return false;
        }
        
        // 获得计数
        std::unordered_map<int, int> u;
        int gcd_ = -1;
        for(int i = 0; i < deck.size();i++){
            if(u.find(deck[i]) == u.end()){
                u[deck[i]] = 1;
            }else{
                u[deck[i]] = u[deck[i]] + 1;
                
            }
        }
        
        //寻找最大公约数
        for(const auto &pair:u){
            if(gcd_ < 0){
                gcd_ = pair.second;
                continue;
            }
            int max_ = max(gcd_, pair.second);
            int min_ = min(gcd_, pair.second);

            gcd_ = gcd(max_, min_);
            if(gcd_ < 2){
                return false;
            }
        }
        return true;
    }
};
```













## 232. 用栈实现队列

![image-20240120143520230](./assets/image-20240120143520230.png)

只能使用栈的pop,push,top,empty,

```c++
class MyQueue {
    std::stack<int> stk1;//for push
    std::stack<int> stk2;//for pop

    void reverse_and_swap(){
        int temp;
        if(stk1.empty()){
            while(!stk2.empty()){
                temp = stk2.top();
                stk2.pop();
                stk1.push(temp);
            }
        }else if(stk2.empty()){
            while(!stk1.empty()){
                temp = stk1.top();
                stk1.pop();
                stk2.push(temp);
            }
        }
    }
public:
    MyQueue() {

    }
    
    void push(int x) {
        if(!stk2.empty()){
            reverse_and_swap();
        }
        stk1.push(x);
    }
    
    int pop() {
        if(!stk1.empty()){
            reverse_and_swap();
        }
        int temp = stk2.top();
        stk2.pop();
        return temp;
    }
    
    int peek() {
        if(!stk1.empty()){
            reverse_and_swap();
        }
        return stk2.top();
        
    }
    
    bool empty() {
        return stk1.empty() && stk2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```





## 414. 第三大的数

![image-20240120143530728](./assets/image-20240120143530728.png)

z最简单的解法：排序遍历

```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        std::sort(nums.begin(),nums.end(),[](int a, int b){
            return a > b;
        });

        int size = 2;
        for(int i = 1; i < nums.size();i++){
            if(nums[i] != nums[i-1])
            {
                size--;
            }
            if(!size){
                return nums[i];
            }
        }
        return nums[0];
    }
};
```

O(n)的简单解法1

遍历同时维护三个数

```c++
class Solution {
public:
    int thirdMax(vector<int> &nums) {
        long a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;
        for (long num : nums) {
            if (num > a) {
                c = b;
                b = a;
                a = num;
            } else if (a > num && num > b) {
                c = b;
                b = num;
            } else if (b > num && num > c) {
                c = num;
            }
        }
        return c == LONG_MIN ? a : c;
    }
};

```



O(n)简单解法2

有序容器set

查找、插入和删除操作的时间复杂度为 O(log n)。

由于有序集合的大小至多为 3，插入和删除的时间复杂度可以视作是 O(1) 的，因此时间复杂度为 O(n)。

set自动去重排序

```c++
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        std::set<int> result;
        for(const int& num:nums){
            result.insert(num);
            if(result.size() > 3){
                result.erase(result.begin());
            }
        }
        if(result.size() < 3){
            return *result.rbegin();//注意不能使用end，要使用reversebegin
        }
        return *result.begin();
    }
};
```









## 283. 移动零

![image-20240120143601536](./assets/image-20240120143601536.png)

简单的双指针，用一个标记完成的序列的尾部（例如完成的序列是12300，那这个标记应该只想第四个位置)，然后用i遍历遇到非零就通过交换添加到这个尾部。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int end_of_ok_sequence = 0;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] != 0 && end_of_ok_sequence < i){
                std::swap(nums[end_of_ok_sequence], nums[i]);
                end_of_ok_sequence++;
            }
            else if(nums[i]!= 0)
            {
                end_of_ok_sequence++;
            }
        }

    }
};
```









## 380. O(1) 时间插入、删除和获取随机元素

![image-20240120143610483](./assets/image-20240120143610483.png)

模拟题

主要就是考虑到hash表不能获取随机元素，数组不能O(1)插入和删除

因此结合这两个，hash表维护数组中元素位置即可

第一次做比较麻烦的是删除，其实就是将要删除的元素在数组中和数组末尾交换，更新hash表然后pop数组最后一个元素即可。

```c++
class RandomizedSet {
    std::vector<int> nums;
    std::unordered_map<int,int> u;
public:
    RandomizedSet() {
        srand(static_cast<unsigned>(time(0)));
    }
    
    bool insert(int val) {
        if(u.find(val) == u.end()){
            nums.push_back(val);
            u[val] = nums.size()-1;
            return true;
        }
        return false;
    }
    
    bool remove(int val) {
        if(u.find(val) == u.end()){
            return false;
        }
        u[nums[nums.size()-1]] = u[val];
        std::swap(nums[u[val]], nums[nums.size()-1]);
        

        nums.pop_back();
        u.erase(val);
        return true;
    }
    
    int getRandom() {
        unsigned pos = rand() % nums.size();

        return nums[pos];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```

















## 239. 滑动窗口最大值(HARD)

这题乍一看很简单，我首先使用如下代码

我判断初始k个的最大值，得到其坐标max_index，然后利用滑动窗口进来的新值来判断是否取代。

有一种可能是全取代不了，此时max_index坐标是小于当前坐标的（不在窗口内），因此我们要再搜索一次。这个方法的问题是，对于从大到小的特殊情况，运行时间爆了。这个方法就等同于对每个窗口搜索。

```c++
class Solution {
    int find_max_in_k(vector<int>& nums, int& k, int begin){
        int max_index = begin;
        for(int i = begin + 1; i < begin + k;i++){
            if(nums[i] > nums[max_index]){
                max_index = i;
            }
        }
        return max_index;
    }
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int max_index = find_max_in_k(nums, k, 0);
        vector<int> result;
        result.push_back(nums[max_index]);
        for(int i = 1;i < nums.size() - k+1;i++){
            // 检查推入的元素是否能够充当最大值
            if(nums[i+k-1] >= nums[max_index]){
                max_index = i+k-1;
            }
            //这种情况发生在旧的max_index已经不在窗口内了
            if(max_index < i){
                max_index = find_max_in_k(nums,k,i);
            }

            result.push_back(nums[max_index]);
        }
        return result;
        
    }
};
```





# 选修题

## 206. 翻转链表



迭代实现，自己别脑子混了就行。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    
public:
    ListNode* reverseList(ListNode* head) {
        //单节点实例,注意需要head判断在前，不然会出现对nullptr访问成员
        if( head == nullptr || head->next == nullptr){
            return head;
        }


        //首节点设置
        //设置上一个节点
        ListNode* LastNode = head;
        //设置下一个节点
        ListNode* NextNode = head->next;

        head->next = nullptr;

        head = NextNode;
        
        while(head->next != nullptr){
            NextNode = head->next;
            //翻转
            head->next = LastNode;

            LastNode = head;

            head = NextNode;
        }

        //尾节点设置
        head->next = LastNode;
        return head;
    }
};
```









## 25.K个一组翻转链表(HARD)

将问题细化成对k大小的block翻转即可，模拟Hard题

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    std::pair<ListNode*, ListNode*> reverse_block(ListNode* thisnode, ListNode* end){
        // 设定为这里的end节点也需要翻转

        //提前存档头节点
        ListNode* beginNode = thisnode;

        //获取上一个节点，下一个节点
        ListNode* lastnode = thisnode;
        ListNode* nextnode = thisnode->next;

        //thisnode不为end时
        while(thisnode != end){
            //到下一个节点
            thisnode = nextnode;
            nextnode = thisnode->next;

            //翻转
            thisnode->next = lastnode;

            //更新lastnode
            lastnode = thisnode;

        }
        //返回块的新开始与新结束
        return std::make_pair(end, beginNode);

    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr || head->next == nullptr){
            return head;
        }
        int count = 0;
        ListNode* Block_begin = nullptr;
        ListNode* Block_end = nullptr;
        ListNode* Unreversed_first_ndoe = nullptr;
        std::vector<std::pair<ListNode*, ListNode*>> vec;
        bool done = true;

        while(head->next != nullptr && done){
            if(count == 0){
                Block_begin = head;
                count ++;
            }else{
                head = head->next;
                count++;
            }
            if(count % k == 0){
                //块结尾为当前节点
                Block_end = head;
                
                //不完整尾部列表开头
                //如果Unreserved_first_node为null_ptr，那么正好给最后一个完整的block的next赋值
                Unreversed_first_ndoe = head->next;

                //更新head到下一个块的开始，注意检索这个head正好是链表最后一个节点的情况
                if(head->next != nullptr){
                    head = head->next;
                    //如果head->next是nullptr那么什么都不做就可以靠while终止
                }else{
                    done = false;
                }
                
                //翻转块
                vec.push_back(reverse_block(Block_begin, Block_end));
                //重置计数
                count = 0;
                
            }
            
        }
        //推入尾部链表，可能为dummy node
        vec.push_back(std::make_pair(Unreversed_first_ndoe, nullptr));
        //拼接
        for(int i = 0; i < vec.size()-1;i++){
            vec[i].second->next = vec[i+1].first;
        }

        return vec[0].first;
    }
};
```

