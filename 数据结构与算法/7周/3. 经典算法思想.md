## 1. 二分查找

二分查找需要数组有序，然后双指针表示头尾，逐步收缩范围。

![image-20240125195202327](./assets/image-20240125195202327.png)

![image-20240125195413543](./assets/image-20240125195413543.png)

解决方案

* 重新设计收缩规则：`R->mid`,`L->mid + 1`
* 边界判断:`if(R-L==1)`对R，L，mid分别判断。









## 2. 贪心算法

局部最优一定保证全局最优，不能保证则需要转而使用动态规划或者搜索。











## 3.分治

复杂的原始问题可能可以拆分成若干个子问题，如果子问题之间互相独立（即一个子问题的计算结果不依赖于其他子问题）



分治思想适用的问题都能多线程。



![image-20240125200320710](./assets/image-20240125200320710.png)







## 快速幂

O(n)乘n次->O(logn) 分治乘

![image-20240125201217322](./assets/image-20240125201217322.png)

```c++
//这里需要my_pow_with_sign_check来处理n为负的情况
class Solution {
public:
    double my_pow_with_sign_check(double x, int n){
         if(n == 0){
           return 1;
       } 

       double y = my_pow_with_sign_check(x,n/2);
       
       return n%2 == 0 ? y*y : y*y*x;
    }
    double myPow(double x, int n) {
        double result = my_pow_with_sign_check(x,n);
        if(n < 0)
            return 1/result;
        return result;
    }
};
```









## 快排

快速排序的核心思想是，每次我们选择一个参照数，然后将数组中小于这个参照数的数放在其左边，大于参照数的数放在其右边。当然，这样放置以后参考数自身也在合适的位置了。

![image-20240125203035855](./assets/image-20240125203035855.png)



接着，定义两个指针i,j，将除了flag之外的所有数分块

![image-20240125203440189](./assets/image-20240125203440189.png)

Pivot函数

* i指针指向第一个比flag大的
* j指针指向第一个比flag小的
* 交换，以此类推，直到i，j碰面。
* 碰面之后，将i与5比较即可
  * 交换flag与最后一个小于flag的位置即可



```c++
class Solution {
    void quickSortRecursive(std::vector<int>& nums, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(nums, low, high);
            quickSortRecursive(nums, low, pivotIndex - 1);  // Sort left part
            quickSortRecursive(nums, pivotIndex + 1, high); // Sort right part
        }
    }

    int partition(std::vector<int>& nums, int low, int high) {
        int pivot = nums[high]; // Choosing the last element as pivot
        int i = low; // Index of smaller element

        for (int j = low; j < high; j++) {
            if (nums[j] < pivot) {
                std::swap(nums[i], nums[j]);
                i++;
            }
        }
        std::swap(nums[i], nums[high]); // Swap pivot to the correct position
        return i; // Return pivot's final position
    }

public:
    vector<int> sortArray(vector<int>& nums) {
        quickSortRecursive(nums, 0, nums.size()-1);
        return nums;
    }
};
```

