# 必修



## 19. 删除链表的倒数第 N 个结点

使用定长queue记录即可

同理，双指针也可

![image-20240226135038412](./assets/image-20240226135038412.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == nullptr || head->next == nullptr)
        {
            return nullptr;
        }
        int count_list = 0;
        std::queue<ListNode*> q;
        ListNode* t = head;
        while(t != nullptr){
            count_list++;
            q.push(t);
            t = t->next;
            if(q.size() > n+1){
                q.pop();
            }
        }
        //处理删除掉头节点的情况
        if(count_list == n){
            return head->next;
        }

        q.front()->next = q.front()->next->next;

        return head;
    }
};
```











## 160. 相交链表(看了一点提示)

需要注意两个list不相交的情况。

![image-20240226135053704](./assets/image-20240226135053704.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //我们假设listA长为A,listB长为B
        //如果其共长为D，那么listA分支长度为A-D，listB分支长度为B-D
        //因此，如果我们用两个指针，分别先遍历A后遍历B，先遍历B后遍历A，步长相同
        //那么，指针相交的地方一定在A+B-D的地方

        ListNode* a = headA,*b = headB;//用以标识两条list不相交的情况
        bool al = true,bl=true;
        while(a != b){
            if(a->next == nullptr && al){
                a = headB;
                al = false;
            }else{
                a = a->next;
            }
            if(b->next == nullptr && bl){
                b = headA;
                bl = false;
            }else{
                b = b->next;
            }

        }

        return a;
    }
};
```











## 215. 数组中的第K个最大元素

![image-20240226135258015](./assets/image-20240226135258015.png)

方法一：排序然后找到第k个即可，NlogN

方法二：堆排序/priority_queue，当然是使用floyd建堆维护而非那个NlogN的swim方法。

https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9



O(N)与O(NlogN)的建堆方法,优先队列pop，push的方法,堆排原理

Floyd 建堆算法是一种更高效的建堆方法，可以在 O(N) 时间内从无序数组创建一个堆。该方法的基本思想是从最后一个非叶子节点开始，逐个向前对每个节点执行下沉（`heapify`）操作，直到根节点。这种方法利用了堆中大部分元素都是叶子节点的事实，通过从后向前进行下沉操作，可以减少不必要的比较和交换操作。

- **下沉（`heapify`）**：对于每个选中的节点，如果它违反了堆的性质（即它小于（或大于）其子节点），则将它与其最大（或最小）的子节点交换，并继续下沉操作，直到恢复堆的性质或成为叶子节点。

STL解法

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        std::priority_queue<int, std::vector<int>, std::greater<int>> pq;

        for(auto &num:nums){
            if(pq.size() < k){
                pq.push(num);
            }else{
                if(pq.top() < num){
                    pq.pop();
                    pq.push(num);
                }
            }
        }
        return pq.top();
    }
};
```

我自己写的小根堆

```c++
class Solution {
public:
    void down(vector<int>& heap, int i){
        //小根堆叶子节点大于父亲节点
        while(2*i+1<heap.size()){//如果存在左子节点
            int son = 2*i+1;
            if(2*i+2<heap.size() && heap[son] > heap[2*i+2]){//如果存在右子节点，记录较为小的点
                son = 2*i+2;
            }
            //如果父亲节点比子节点还大，那么与比较小的交换
            if(heap[i] > heap[son])
                std::swap(heap[i], heap[son]);

            //我们保证了子结构一定是符合堆序的，因此我们只需要关注这个新下来的点
            i = son;
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        //小根堆
        vector<int> heap;
        heap.reserve(k);
        for(int i = 0; i < k;i++){
            heap.push_back(nums[i]);
        }
        // floyd堆排
        for(int i = (k-2)/2;i >= 0;i--){
            down(heap,i);
        }
        //插入新值
        for(int i = k; i < nums.size();i++){
            if(heap[0] < nums[i]){//因为我们要最大的k个数，这里不能小于等于
                heap[0] = nums[i];
                down(heap,0);
            }
        }
        return heap[0];

    }
};
```







## 134. 加油站(贪心)

![image-20240226163118707](./assets/image-20240226163118707.png)

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        //这道题的关键在于，例如a b c d e五个加油站，从a出发最远到d，那么从b,c出发也只能最远到d
        // 因为a开到b剩余的油量总是大于等于0，这样都开不到e，从b,c出发少了这些油更不可能了
        // 因此，此题贪心，更新起始加油站为第一个到不了的加油站即可

        //遍历起点
        for(int i = 0; i <  gas.size();){
            int current_tank = 0;
            int current_pos = i;
            bool flag = false;
            while(current_tank>= 0){
                if(current_pos == i && flag){
                    return i;
                }
                flag = true;
                current_tank += gas[current_pos] - cost[current_pos];
                current_pos = (current_pos+1) % gas.size(); 
            }

            if(current_pos <= i){//此时不可能成功，因为<i的部分我们已经验证过不能到达了，=i的话代表最后一段到起点的油不够
                return -1;
            }else{
                i = current_pos;
            }
        }
        return -1;
    }
};
```











## 138. 复制带随即指针的链表

这道题就是什么意思，就是你必须另外处理random指向的新地址，会出现各种问题，例如这个地址对应的deepcopy还未建立，你就需要递归的建立一下，我觉得没必要这么麻烦，递归滚出c++。

为了防止太麻烦，我选择直接存一下新旧节点的对应map，而非像标准解答那样递归。

第一遍建立map，第二遍替换random指向即可。

![image-20240226171534529](./assets/image-20240226171534529.png)



```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr){
            return head;
        }
        unordered_map<Node*, Node*> mapp;

        Node* result;
        result = new Node(head->val);

        Node* this_ptr = head;
        Node* copy_ptr = result;
        mapp.insert(std::make_pair(head, result));
        while(this_ptr->next != nullptr){
            //创建了一个节点
            Node* node = new Node(this_ptr->next->val);
            mapp.insert(std::make_pair(this_ptr->next, node));
            copy_ptr->next = node;
            copy_ptr->random = this_ptr->random;

            copy_ptr = copy_ptr->next;
            this_ptr = this_ptr->next;
        }

        //尾部处理,this_ptr指向最后一个节点，copy_ptr指向最后一个节点
        copy_ptr->next = nullptr;
        copy_ptr->random = this_ptr->random;

        //替换random
        copy_ptr = result;
        while(copy_ptr != nullptr){
            copy_ptr->random = mapp[copy_ptr->random];
            copy_ptr = copy_ptr->next;
        }
        
        return result;
    }
};
```









## 260. 只出现一次的数字III



![image-20240226180542445](./assets/image-20240226180542445.png)

这种方法能够将两个只出现一次的数字分成两组的原理基于异或运算的性质。当我们对数组中所有元素进行异或运算时，最终的结果是那两个只出现一次的数字的异或结果，记作`xorResult`。-因为这两个数字是不同的，所以`xorResult`不可能为0，==这意味着至少有一个位上，这两个数字是不同的（一个是0，另一个是1）。==

通过找到`xorResult`中任意一个为1的位，==我们实际上找到了一个可以区分这两个唯一数字的标准。==假设在`xorResult`中，第k位是1，这意味着在这两个只出现一次的数字中，一个在第k位上是1，另一个在第k位上是0。







对于大多数整数`x`，`-x`能够正常产生一个补码形式的负数。然而，对于最小的负整数（在32位整数中是`-2,147,483,648`，二进制表示为`1000 0000 0000 0000 0000 0000 0000 0000`），取负操作会导致一个问题。理论上，这个数的负值应该是`2,147,483,648`，但这个值在32位有符号整数中无法表示，因为有符号整数的最大值是`2,147,483,647`。这导致取负操作的结果仍然是`-2,147,483,648`，不会改变其值，但这个操作本身并不会导致越界。实际上，越界风险不是由这个操作引起的。

`-2147483648`（`int`类型在32位系统上的最小值）进行取负操作时遇到的一个特定问题。根据错误信息："negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself"，这意味着在尝试将`-2147483648`取负时发生了未定义行为（Undefined Behavior，简称UB），因为结果超出了`int`类型可表示的范围。

在C++中，`int`类型通常是有符号的，并且在32位系统上范围是从`-2,147,483,648`到`2,147,483,647`。当你尝试对`-2,147,483,648`取负时，理论上的结果是`2,147,483,648`，但这超出了`int`类型的最大正值，因此这个操作导致了未定义行为。



这段代码中的特殊处理`int the_different_flag = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));`是为了解决当`xorsum`等于`INT_MIN`（即`-2,147,483,648`，或者在二进制中为`1000 0000 0000 0000 0000 0000 0000 0000`）时由于取负操作导致的未定义行为问题。在这种情况下，直接对`INT_MIN`取负是未定义的，因为其结果不在`int`类型的范围内。

==**当`xorsum`等于`INT_MIN`时**，表示`xorsum`的二进制表示中只有最高位是1。此时，直接使用`xorsum`作为`the_different_flag`，即使用最高位来区分两个数。这同样满足算法的需要，因为这意味着其中一个数在最高位为1，另一个为0，可以据此将数组分为两组。==

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xorsum = 0;
        for(auto &num:nums){
            xorsum^= num;
        }

        int the_different_flag = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));
        int type1 = 0, type0 = 0;
        for(auto &num:nums){
            if(num & the_different_flag)//此位为1
            {
                type1^= num;
            }else{
                type0 ^= num;
            }
        }

        return {type1, type0};
    }
};
```

