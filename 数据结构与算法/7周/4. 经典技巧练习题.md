# 必修



## 19. 删除链表的倒数第 N 个结点

使用定长queue记录即可

同理，双指针也可

![image-20240224230300041](C:\Users\52985\AppData\Roaming\Typora\typora-user-images\image-20240224230300041.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == nullptr || head->next == nullptr)
        {
            return nullptr;
        }
        int count_list = 0;
        std::queue<ListNode*> q;
        ListNode* t = head;
        while(t != nullptr){
            count_list++;
            q.push(t);
            t = t->next;
            if(q.size() > n+1){
                q.pop();
            }
        }
        //处理删除掉头节点的情况
        if(count_list == n){
            return head->next;
        }

        q.front()->next = q.front()->next->next;

        return head;
    }
};
```











## 160. 相交链表(看了一点提示)

需要注意两个list不相交的情况。

![image-20240224233648846](C:\Users\52985\AppData\Roaming\Typora\typora-user-images\image-20240224233648846.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //我们假设listA长为A,listB长为B
        //如果其共长为D，那么listA分支长度为A-D，listB分支长度为B-D
        //因此，如果我们用两个指针，分别先遍历A后遍历B，先遍历B后遍历A，步长相同
        //那么，指针相交的地方一定在A+B-D的地方

        ListNode* a = headA,*b = headB;//用以标识两条list不相交的情况
        bool al = true,bl=true;
        while(a != b){
            if(a->next == nullptr && al){
                a = headB;
                al = false;
            }else{
                a = a->next;
            }
            if(b->next == nullptr && bl){
                b = headA;
                bl = false;
            }else{
                b = b->next;
            }

        }

        return a;
    }
};
```











## 



![image-20240225203620559](/home/stuckedcat-3060/.config/Typora/typora-user-images/image-20240225203620559.png)

方法二：堆排序/priority_queue

https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=61f56e9689aceb8e8b1f51e6e06bddd9



O(N)与O(NlogN)的建堆方法,优先队列pop，push的方法,堆排原理

Floyd 建堆算法是一种更高效的建堆方法，可以在 O(N) 时间内从无序数组创建一个堆。该方法的基本思想是从最后一个非叶子节点开始，逐个向前对每个节点执行下沉（`heapify`）操作，直到根节点。这种方法利用了堆中大部分元素都是叶子节点的事实，通过从后向前进行下沉操作，可以减少不必要的比较和交换操作。

- **下沉（`heapify`）**：对于每个选中的节点，如果它违反了堆的性质（即它小于（或大于）其子节点），则将它与其最大（或最小）的子节点交换，并继续下沉操作，直到恢复堆的性质或成为叶子节点。

STL解法

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        std::priority_queue<int, std::vector<int>, std::greater<int>> pq;

        for(auto &num:nums){
            if(pq.size() < k){
                pq.push(num);
            }else{
                if(pq.top() < num){
                    pq.pop();
                    pq.push(num);
                }
            }
        }
        return pq.top();
    }
};
```

我自己写的小根堆

```c++
class Solution {
public:
    void down(vector<int>& heap, int i){
        //小根堆叶子节点大于父亲节点
        while(2*i+1<heap.size()){//如果存在左子节点
            int son = 2*i+1;
            if(2*i+2<heap.size() && heap[son] > heap[2*i+2]){//如果存在右子节点，记录较为小的点
                son = 2*i+2;
            }
            //如果父亲节点比子节点还大，那么与比较小的交换
            if(heap[i] > heap[son])
                std::swap(heap[i], heap[son]);

            //我们保证了子结构一定是符合堆序的，因此我们只需要关注这个新下来的点
            i = son;
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        //小根堆
        vector<int> heap;
        heap.reserve(k);
        for(int i = 0; i < k;i++){
            heap.push_back(nums[i]);
        }
        // floyd堆排
        for(int i = (k-2)/2;i >= 0;i--){
            down(heap,i);
        }
        //插入新值
        for(int i = k; i < nums.size();i++){
            if(heap[0] < nums[i]){//因为我们要最大的k个数，这里不能小于等于
                heap[0] = nums[i];
                down(heap,0);
            }
        }
        return heap[0];

    }
};
```





