## 必修题



### 226. 翻转二叉树

简单规律题，递归，交换每个孩子即可

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // invert two son
        if(root == nullptr)
            return root;
        TreeNode* temp;
        temp = root->left;
        root->left = root->right;
        root->right = temp;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```







### 199. 二叉树的右视图

简单模拟题，直接在每一层寻找最右边的即可

可惜是链表，爷最烦链表了，正常人谁用啊

链表那就没办法了，BFS，DFS

DFS就是每层维护一个值，考虑到BFS的访问顺序，每层一定是最右边的最后被访问，因此是O(n)

我怕觉得还是BFS比较贴合

BFS就是每层找到最右边的即可

简单来说，分解为子问题，每一层的节点都存在一个queue里面，queue的最后一个节点就是我们需要的，每一层只需要将下一层存在节点存在新queue里面递归即可。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void find_this_layer(std::queue<TreeNode*>& node_this_layer, std::vector<int>& res){
        if(node_this_layer.size() == 0){
            return ;
        }
        std::queue<TreeNode*> node_next_layer;
        res.push_back(node_this_layer.back()->val);

        while(node_this_layer.size() > 0){
            TreeNode* temp;
            temp = node_this_layer.front();
            node_this_layer.pop();

            if(temp->left != nullptr){
                node_next_layer.push(temp->left);
            }
            if(temp->right != nullptr){
                node_next_layer.push(temp->right);
            }
        }
        find_this_layer(node_next_layer, res);
    }
    vector<int> rightSideView(TreeNode* root) {
        std::queue<TreeNode*> node_this_layer;
        std::vector<int> res;
        if(root == nullptr){
            return res;
        }
        res.push_back(root->val);
        if(root->left != nullptr)
            node_this_layer.push(root->left);
        if(root->right != nullptr)
            node_this_layer.push(root->right);
        find_this_layer(node_this_layer, res);
        return res;
    }
};
```



考虑到（虽然不太可能）递归会发生栈溢出，也有迭代写法

写的麻烦一点，就是你得额外维护一个该节点是什么深度，然后用一个queue来找就好了。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        std::vector<int> res;
        if(!root){
            return res;
        }
        //记录每一层的最右值
        std::unordered_map<int,int> rightEST;
        // 记录层-节点对
        std::queue<std::pair<int, TreeNode*>> node_list;

        node_list.push(std::make_pair(0,root));

        while(node_list.size()){
            std::pair<int, TreeNode*> thisNode = node_list.front();

            node_list.pop();
		   // 考虑访问顺序，后访问的一定是我们需要的
            rightEST[thisNode.first] = thisNode.second->val;
		   // 添加子节点
            if(thisNode.second->left != nullptr)
                node_list.push(std::make_pair(thisNode.first + 1, thisNode.second->left));
            if(thisNode.second->right != nullptr)
                node_list.push(std::make_pair(thisNode.first + 1, thisNode.second->right));
        }


        for(int i = 0; ; i++){
            if(rightEST.find(i) != rightEST.end()){
                res.push_back(rightEST[i]);
            }else{
                break;
            }
        }
        return res;

    }
};
```









### 297.二叉树的序列化与反序列化（困难）

![image-20240417182606370](./assets/image-20240417182606370.png)

这个题加深了前序，中序，后序遍历（按根节点访问顺序所命名）的作用。

首先，考虑到节点数为10000，肯定不能构造完全二叉树，因为极限情况（链）会需要$2^{10001}-1$大小的数组，同时，我们还需要反序列化， 因此不能只存储已有节点。

这个时候，我们就需要考虑，一个序列化后的树需要哪些信息，才能够还原。

答案显而易见，序列化时的规则（需要无后效性，即为已经构造完成的不会受到未构造部分的插入而改变结构），以及每个节点是否为最后一个节点。

每个节点是否为最后一个节点又分为有左孩子，有右孩子，无孩子。



有了这两个信息，配合前序/中序/后序遍历规则，即可将一棵树的信息完整表示。



我们使用的null来表示空节点（无孩子），实际上会遇到一些情况，有过多的null（最多会有10000+1），这是没办法的，我们得考虑所有的节点都不是一个有两个孩子的节点，这就意味着我们至多需要节点数目个null来标识节点性质。



还有一种邪道写法是使用括号的嵌套结构来标识节点性质，就是反序列化的时候烦了很多



为了遍历方便起见，我们使用前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
    // 用于序列化构造
    void serialize_acess(std::string &res, TreeNode* this_node){
        if(this_node->left){
            res += "," + std::to_string(this_node->left->val);
            serialize_acess(res, this_node->left);
        }else{
            res += ",#";
        }

        if(this_node->right){
            res += "," + std::to_string(this_node->right->val);
            serialize_acess(res, this_node->right);
        }else{
            res += ",#";
        }

        return;
    }
    //for deserialize
    // 用于获得下一个数字
    int get_next_num(std::string &data, int &pos, bool &is_null){
        std::string temp = {};
        int res = 0;
        if(data[pos] == '#'){
            is_null = true;
            pos++;
            pos++;
            return res;
        }
        // 需要用来额外判断是否为负数
        if(data[pos] == '-'){
            temp += '-';
            pos++;
        }
        while(isdigit(data[pos])){
            temp += data[pos++];
        }
        res = std::stoi(temp);
        pos++;
        is_null = false;
        return res;
    }
	
    // 用于前序构造
    void PreOrder(TreeNode* father, int &pos, bool &is_null, std::string &data){
        int val;
        // left
        if(pos >= data.size()) return;
        val = get_next_num(data, pos, is_null);
        if(is_null){
            father->left = nullptr;
        }else{
            father->left = new TreeNode(val);
            PreOrder(father->left, pos, is_null, data);
        }

        // right
        if(pos >= data.size()) return;
        val = get_next_num(data, pos, is_null);
        if(is_null){
            father->right = nullptr;
        }else{
            father->right = new TreeNode(val);

            PreOrder(father->right, pos, is_null, data);
        }

        return;

    }

public:
    
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root){
            return {};
        }
        std::string res = std::to_string(root->val);
        serialize_acess(res, root);
        //std::cout << res << std::endl;
        return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data.empty()){
            return nullptr;
        }


        int pos = 0;
        bool is_null = false;

        int val = get_next_num(data, pos, is_null);
        if(is_null){
            return nullptr;
        }

        TreeNode* root = new TreeNode(val);


        PreOrder(root, pos, is_null, data);

        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```

![image-20240417132514611](./assets/image-20240417132514611.png)
