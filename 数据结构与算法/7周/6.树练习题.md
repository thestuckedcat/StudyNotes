## 必修题



### 226. 翻转二叉树

简单规律题，递归，交换每个孩子即可

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // invert two son
        if(root == nullptr)
            return root;
        TreeNode* temp;
        temp = root->left;
        root->left = root->right;
        root->right = temp;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```







### 199. 二叉树的右视图

简单模拟题，直接在每一层寻找最右边的即可

可惜是链表，爷最烦链表了，正常人谁用啊

链表那就没办法了，BFS，DFS

DFS就是每层维护一个值，考虑到BFS的访问顺序，每层一定是最右边的最后被访问，因此是O(n)

我怕觉得还是BFS比较贴合

BFS就是每层找到最右边的即可

简单来说，分解为子问题，每一层的节点都存在一个queue里面，queue的最后一个节点就是我们需要的，每一层只需要将下一层存在节点存在新queue里面递归即可。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void find_this_layer(std::queue<TreeNode*>& node_this_layer, std::vector<int>& res){
        if(node_this_layer.size() == 0){
            return ;
        }
        std::queue<TreeNode*> node_next_layer;
        res.push_back(node_this_layer.back()->val);

        while(node_this_layer.size() > 0){
            TreeNode* temp;
            temp = node_this_layer.front();
            node_this_layer.pop();

            if(temp->left != nullptr){
                node_next_layer.push(temp->left);
            }
            if(temp->right != nullptr){
                node_next_layer.push(temp->right);
            }
        }
        find_this_layer(node_next_layer, res);
    }
    vector<int> rightSideView(TreeNode* root) {
        std::queue<TreeNode*> node_this_layer;
        std::vector<int> res;
        if(root == nullptr){
            return res;
        }
        res.push_back(root->val);
        if(root->left != nullptr)
            node_this_layer.push(root->left);
        if(root->right != nullptr)
            node_this_layer.push(root->right);
        find_this_layer(node_this_layer, res);
        return res;
    }
};
```



考虑到（虽然不太可能）递归会发生栈溢出，也有迭代写法

写的麻烦一点，就是你得额外维护一个该节点是什么深度，然后用一个queue来找就好了。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        std::vector<int> res;
        if(!root){
            return res;
        }
        //记录每一层的最右值
        std::unordered_map<int,int> rightEST;
        // 记录层-节点对
        std::queue<std::pair<int, TreeNode*>> node_list;

        node_list.push(std::make_pair(0,root));

        while(node_list.size()){
            std::pair<int, TreeNode*> thisNode = node_list.front();

            node_list.pop();
		   // 考虑访问顺序，后访问的一定是我们需要的
            rightEST[thisNode.first] = thisNode.second->val;
		   // 添加子节点
            if(thisNode.second->left != nullptr)
                node_list.push(std::make_pair(thisNode.first + 1, thisNode.second->left));
            if(thisNode.second->right != nullptr)
                node_list.push(std::make_pair(thisNode.first + 1, thisNode.second->right));
        }


        for(int i = 0; ; i++){
            if(rightEST.find(i) != rightEST.end()){
                res.push_back(rightEST[i]);
            }else{
                break;
            }
        }
        return res;

    }
};
```

