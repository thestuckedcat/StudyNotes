## 回溯

### 77.组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。



每一层递归依次选择一个数添加进数组即可

类似for循环解法

```c++
class Solution {
    vector<int> path;
    int n,k;
    void dfs(vector<vector<int>>& ans,int begin, int curDepth){
        if(curDepth == k){
            ans.push_back(path);
            return;
        }
        for(int i = begin; i <= n;i++){
            path[curDepth] = i;
            dfs(ans,i+1,curDepth+1);
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        this->n = n;
        this->k = k;
        path = vector<int>(k);
        vector<vector<int>> ans;
        dfs(ans,1,0);
        return ans;

    }
};
```











### 216.组合总和III

同样就是列举数字即可，第一层依次选择一个数字，第二层依次选择后面的数字

```c++
class Solution {
    vector<vector<int>> ans;
    vector<int> path;
    int n,k;
    void dfs(int cur,int sum, int depth){
        if(sum == n || depth == k){
            if(sum == n && depth == k){
                ans.push_back(path);
            }
            return;
        }
        for(int i = cur;i <= 9;i++){
            path[depth] = i;
            dfs(i+1,sum+i,depth+1);
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        this->n = n;this->k = k;
        path = vector<int>(k);

        dfs(1,0,0);
        return ans;
    }
};
```







### 17.电话号码的字母组合

每一层遍历这个数字能代表的字母即可。

```c++
class Solution {
    vector<string> ans;
    string path;
    void dfs(int cur, string& s,unordered_map<int,vector<char>> &mp){
        if(cur >= s.size()){
            ans.push_back(path);
            return;
        }
        if(s[cur] != '1' && s[cur] != '0')
        {
            for(auto c : mp[s[cur]-'0']){
                path.push_back(c);
                dfs(cur+1,s,mp);
                path.pop_back();
            }
        }else{
            dfs(cur+1,s,mp);
        }
    }
    
public:
    vector<string> letterCombinations(string digits) {
        unordered_map<int,vector<char>> mp {{2,{'a','b','c'}},
                                    {3,{'d','e','f'}},
                                    {4,{'g','h','i'}},
                                    {5,{'j','k','l'}},
                                    {6,{'m','n','o'}},
                                    {7,{'p','q','r','s'}},
                                    {8,{'t','u','v'}},
                                    {9,{'w','x','y','z'}}};
        if(digits.size() == 0) return {};
        dfs(0,digits,mp);
        return ans;
        
    }
};
```















### 39.组合总和

此题如果使用一个公共的`vector<int> path`，考虑到一个数字可以使用多次，需要理清楚path什么时候pop，并且什么时候pop干净返回上一层。

```c++
class Solution {
    vector<vector<int>> ans;
    void dfs(int cur,vector<int>& candidates,int target,int sum,vector<int> path)   {

        if(cur >= candidates.size()){
            return;
        }


        dfs(cur+1,candidates,target,sum ,path);
        for(int i = 1;i * candidates[cur]+sum <= target;i++){
            path.push_back(candidates[cur]);
            if(i * candidates[cur]+sum == target){
                ans.push_back(path);
                return;
            }
            dfs(cur+1,candidates,target,i * candidates[cur]+sum ,path);
        }

    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        dfs(0,candidates,target,0,{});
        return ans;
    }
};
```





### 40. 组合总和II

```c++
class Solution {
    // 这一题的难点在于，元素可能重复，因此如果对每个元素做选取/不选取的两种情况的dfs就可能重复
    // 上一题因为每个元素能够使用无限次，所以它设置的是元素不重复，因此没有这个问题
    // 解决的方法是排序加上统计同一个元素个数，做成和上一题类似的方式，不过不是使用无限次而是有限次。
    vector<int> path;
    vector<vector<int>> ans;
    void dfs(int curpos, vector<int>&candidates, int target,int sum){
        if(sum == target){
            ans.push_back(path);
            return;
        }
        if(curpos >= candidates.size()) return;
        if(sum > target) return;

        //找到相同数字的区间
        int cnt = 1;
        for(;curpos+cnt < candidates.size();cnt++){
            if(candidates[curpos+cnt] != candidates[curpos+cnt-1]){
                break;
            }
        }

 
        // 不采用任何一个
        dfs(curpos+cnt,candidates,target,sum);
        // 遍历能够采用的数量
        for(int i = 1; i <= cnt;i++){
            path.push_back(candidates[curpos]);
            dfs(curpos+cnt,candidates,target,sum+i*candidates[curpos]);
        }

        for(int i = 1;i <= cnt;i++){
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(0,candidates,target,0);
        return ans;
    }
};
```











### 131. 分割回文串

这一题的题干很绕，但是从另一个角度想就很容易了



你只需要找到一种分割方式，保证分割出的每个子串都是回文串

也就是说，我们回溯的就是遍历方式，**也就是每一层代表当前被分割区间的范围**

```c++
class Solution {
    vector<vector<string>> ans;
    vector<string> path;
    bool is_pad(string s){
        int begin = 0;
        int end = s.size()-1;

        while(begin < end){
            if(s[begin] != s[end]){
                return false;
            }
            begin++;
            end--;
        }
        return true;
    }
    void find(string &s, int pos){
        if(pos >= s.size()){
            ans.push_back(path);
            return;
        }
        for(int i = pos;i < s.size();i++){
            string sub = s.substr(pos,i-pos+1);
            if(is_pad(sub)){
                path.push_back(sub);
                find(s,i+1);
                path.pop_back();
            }
        }
        return;
    }
public:
    vector<vector<string>> partition(string s) {
        find(s,0);
        return ans;
    }
};
```

