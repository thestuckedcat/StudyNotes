单纯的记录一下，无详细解释

### 0. ACM输入输出

#### `cin/cout`

基础的大伙都知道了，cin就是对`istream`不同input type的流重载，并且返回带引用的`istream`以方便链式传导，我们说点实用的

* `cin`通常**不识别空格**
* `cin`实现时设置了两个标志位，`eofbit`和`failbit`
  * `cin`如果遇到某一段输入与目标类型不匹配，则会设置`failbit`
  * `cin`如果遇到`End Of File`则会设置`eofbit`
  * 当使用`while(cin>>a)`时，只要存在`eofbit`或者`failbit`被设置，则循环退出，也就是`while(!eofbit || !failbit)`
  * 当使用 `cin >> c` 读取字符时，默认情况下，`cin` 会**跳过所有的空白字符（包括空格、制表符和换行符），并读取下一个非空白字符。**因此，`cin >> c` 不会读取空格字符。

cout没什么好说的，可以额外使用流操作符输出

**小数点位数**

```c++
#include <iostream>
#include <iomanip> // 包含操纵符头文件
using namespace std;

int main() {
    double pi = 3.14159;
    cout << fixed << setprecision(2) << pi << endl; // 保留2位小数，结果为 "3.14"
    return 0;
}

```

**输出宽度**

```c++
#include <iostream>
#include <iomanip> // 包含操纵符头文件
using namespace std;

int main() {
    int n = 42;
    cout << setw(5) << n << endl;  // 输出宽度为5，右对齐，结果为 "   42"
    cout << left << setw(5) << n << endl; // 输出宽度为5，左对齐，结果为 "42   "
    return 0;
}

```











#### `scanf/printf`

`scanf`是cin的鼻祖，因此自然做法相同

对于

```c++
int a,b;
scanf("%d %d", &a, &b);
// scanf返回成功赋值个数
// 输入{1 2} a b分别被赋值1 2
// 输入{1,} a被赋值1，设置fail状态，b不会被赋值，scanf返回1
// 输入{1 ,} 同上
// 输入{1     2} 包含多个空格，scanf自动忽略空格，制表，换行，因此a b被成功赋值，scanf返回2
// 输入{1 a} scanf读取1，a会使得fail状态被设置，scanf返回1
```

```c++
while ((n = scanf("%d", &x)) != EOF && n != 0) {
    // 读取到非EOF且读取到了
}
```



这个只需要记得几点

| 类型                             | 说明符 |
| -------------------------------- | ------ |
| 整数Integer                      | ` %d`  |
| 无符号整数Unsigned Integer       | `%u`   |
| 浮点数float                      | `%f`   |
| 双精度double                     | `%lf`  |
| 字符char                         | `%c`   |
| 字符串（直到遇到空白字符）string | `%s`   |

额外的，

```c++
printf("%5d\n", 42);   // 输出宽度为5的整数，右对齐，结果为 "   42"
printf("%-5d\n", 42);  // 输出宽度为5的整数，左对齐，结果为 "42   "
printf("%.2f\n", 3.14159); // 保留2位小数，结果为 "3.14"
// 如果同时指定输出宽度和小数个数，那么冲突时以小数个数为标准
```







#### `getline/getchar`

`cin` 和 `scanf` 在处理空白字符（如空格、换行符、制表符）时，通常会跳过这些字符，导致在某些场景下不方便处理。因此，`getchar` 和 `getline` 通常会作为补充，用于读取空白字符和整行输入。

**`getchar`**

`getchar` 用于读取单个字符，包括空白字符。它不会跳过任何输入，因此非常适合读取逐字符输入，包括空白字符。.

* 成功读取字符，返回该字符ASCII值
* 读到EOF，返回特殊值EOF(-1)

通常使用为

```c++
int ch;
while((ch = getchar()) != EOF){
    
}
```

`getchar()`可以读取换行符



**`getline()`**

`getline` 用于读取整行输入，包括空白字符。它会一直读取，直到遇到换行符（`'\n'`）或文件末尾（EOF）。

getline返回读取的字符数（包括换行符），不包括终止符`\0`

如果读到EOF返回-1。

```c++
#include <stdio.h>
#include <stdlib.h>

char *line = NULL;
// 分配给line缓冲区的字节数（包括终止空字符)
size_t len = 0;
//ssize_t为getline返回值，表示成功读取的字符数，包括换行符，但不包括终止的空字符（null terminator）。
ssize_t read; 
while ((read = getline(&line, &len, stdin)) != -1) {
        printf("Retrieved line of length %zd:\n", read);
        printf("%s", line);
    }
```

`getline()`因为能够读取到换行符，通常需要额外做处理

```c++
#include <stdio.h>
#include <stdlib.h>

char *line = NULL;
size_t len = 0;
ssize_t read;
while ((read = getline(&line, &len, stdin)) != -1) {
        // 检查是否有换行符，并将其替换为字符串结束符
        if (line[read - 1] == '\n') {
            line[read - 1] = '\0';
        }
        
        // 输出处理后的行
        printf("Processed line: %s\n", line);
    }
```





#### 新一代`getline/getchar`

上面的太过冗余，c++提供了getline和getchar与流的交互

注意，在使用过cin之后，通常需要使用`cin.ignore()`来清空缓存区，这是因为cin通常不会读取`\n`（或者说需要读取下一个时会自动跳过），因此如果你先`cin`了，应该防止`getchar`或者`getline`读取这个`\n`

##### `cin`与`getchar`

不是那么有用的组合，我只能想到你需要这个字符的ascii值

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    int a;
    string line;

    // 使用 cin 读取整数
    cout << "Enter an integer: ";
    cin >> a;
    cout << "You entered: " << a << endl;

    // 使用 getline 读取整行字符串
    cout << "Enter a line of text: ";
    cin.ignore(); // 清除输入缓冲区中的换行符
    getline(cin, line);
    cout << "You entered: " << line << endl;

    return 0;
}

```



##### `cin`与`getline`

这个就有意思了

==注意，`cin`不会读取换行符，它会被从输入流中提取并丢弃，因此不用额外处理==

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    int a;
    string line;

    // 使用 cin 读取整数
    cout << "Enter an integer: ";
    cin >> a;
    cout << "You entered: " << a << endl;

    // 使用 getline 读取整行字符串
    cout << "Enter a line of text: ";
    cin.ignore(); // 清除输入缓冲区中的换行符
    getline(cin, line);
    cout << "You entered: " << line << endl;

    return 0;
}

```











#### 一些常见的输入处理

##### 靠EOF终止

通常来说，输入长成

```txt
1 2 3
2 3 4
3 4 5
EOF
```

使用

```c++
int a, b, c;
while(cin >> a >> b >> c);//eofbit会使得其退出循环
```

或者

```c++
```



##### 强迫读取整行

[7. 平均绩点 (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1006)

这里，你虽然可以通过cin读取所有非空格的字符，但是你不知道换行符在哪里

因此需要使用getline和cin组合

```c++
#include<iostream>
#include<string>

int main(){
    string s;
    while(getline(cin, s)){
        for(auto &c:s){
            
        }
    }
}
```





##### 有规律的字符和整数混合读取

这个倒是简单了，因为有规律（通常指的是能够人为通过输入确定，而不需要通过换行符确定每个request）

直接使用cin即可

> [13. 镂空三角形 (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1012)

```c++
int main(){
    char c;
    int n;
    while(cin >> c){
        if(c == '@'){
            break;
        }
        cin >> n;
    }
}
```











##### 所有使用空格隔开的数据读取

包括字符串，字符，数字

都直接使用cin

[14. 句子缩写 (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1013)

```c++
#include<iostream>
#include<string>
using namespace std;

int main(){
    int n;
    cin >> n;
    cin.ignore();//注意这里很容易错
    while(n--)
    {
        string s;
        getline(cin,s);
        
        string res = "";
        int flag = 0;
        for(auto &c : s){
            if(c == ' '){
                flag = 0;
            }
            else{
                
                if(!flag)
                    res += toupper(c);
                flag = 1;
            }
        }
        cout << res << endl;
    }
}
```













#### 常用的功能函数

##### 数字与字符转换

在C中

`stdio.h``stdlib.h`

**ASCII to Integer **

```c++
char str[] = "12345";
int num = atoi(str);
```

**ASCII to long**

```c++
char str[] = "1234567890";
long num = atol(str);
```

**ASCII to Float**

```c++
char str[] = "123.45";
float num = atof(str);
```





在C++中

`#include<iostream>`

`#include<string>`

**String to Integer**

```c++
string str = "12345";
int num = stoi(str);
```



**string to long**

```c++
string str = "1234567890";
long num = stol(str);
```





**String to float**

```c++
string str = "123.45";
float num = stof(str);
```





##### 大小写转换

C中`ctype.h`只能修改单个字符

**toupper**

```c++
void to_uppercase(char *str) {
    while (*str) {
        *str = toupper(*str);
        str++;
    }
}
```

**tolower**

```c
void to_lowercase(char *str) {
    while (*str) {
        *str = tolower(*str);
        str++;
    }
}
```







C++的`cctype`，同理只能单个字符

```c++
void to_uppercase(std::string &str) {
    for (char &c : str) {
        c = toupper(c);
    }
}
void to_lowercase(std::string &str) {
    for (char &c : str) {
        c = tolower(c);
    }
}

```

但是实际上string提供了类似的功能，通过算法库的transform

```c++
std::string str = "Hello, World!";
std::transform(str.begin(), str.end(), str.begin(), ::toupper);

std::transform(str.begin(), str.end(), str.begin(), ::tolower);
```









#### 总结

* cin不读换行和空格制表符，适用于大多情况
* getline能读取`\n`，和cin搭配虽然读取不了`\n`但是能够整行读取分析



合理利用`cin`和`getline`和`cin.ignore()`能够解决我见过的100%的ACM输入输出问题，虽然有些不是最搞笑的。



























































### 1. 二分查找

此处我采用左闭右开的写法

#### 704.二分查找(简单)

```c++
class Solution {

public:
    int search(vector<int>& nums, int target) {
        int begin = 0;
        int end = nums.size();



        while(begin < end){
            int middle = (begin+end)/2;
            if(nums[middle] < target){
                begin = middle + 1;
            }else if(nums[middle] > target){
                end = middle;
            }else{
                return middle;
            }
        }

        return -1;



    }
};
```





#### 35. 搜索插入位置(简单)

懒得写了，直接用库

需要注意序列要求排序且非降序

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        auto it = std::lower_bound(nums.begin(),nums.end(), target);
        return std::distance(nums.begin(), it);
        
        
    }
};
```







#### 34.在排序数组中查找元素的第一个和最后一个位置（中等）

两次二分

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        auto itbegin = std::lower_bound(nums.begin(),nums.end(),target);
        auto itend = std::upper_bound(nums.begin(),nums.end(),target);

        if(itbegin == nums.end() || *itbegin != target) return {-1,-1};
        return {(int)std::distance(nums.begin(),itbegin),(int)std::distance(nums.begin(),itend)-1};
    }
};
```



#### 69. x的平方根(简单)

需要注意的是最后得到的数如果平方大于x那么需要减1.

最好使用begin

```c++
class Solution {
public:
    int mySqrt(int x) {
        long long begin = 0;
        long long end = x;
        long long mid=0;
        while(begin < end){
            mid = (begin + end) / 2;
            if(mid* mid > x){
                end = mid;
            }else if(mid * mid < x){
                begin = mid + 1;
            }else{
                return mid;
            }
        }

        return (int)(begin*begin > x ? begin-1:begin);
    }
};
```







#### 367. 有效的完全平方数

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num==1) return true;
        long begin = 0;
        long end = num;

        long mid = 0;
        while(begin < end){
            mid = (begin+end)/2;

            if(mid * mid > num){
                end = mid;
            }else if(mid * mid < num){
                begin = mid + 1;
            }else{
                return true;
            }
        }
        return false;
    }
};
```











### 2. 双指针

#### 27.移除元素(简单)

双指针，只需要注意最后的临界情况即可

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.empty()) return 0;
        int front = 0;
        int back = nums.size()-1;
        while(front < back){
            if(nums[front] == val){
                std::swap(nums[front], nums[back]);
                back--;
            }else{
                front++;
            }
        }

        // 两种情况，
        // front和back同时指向最后一个非value
        // front和back同时指向第一个value
        if(nums[front] == val) return front;
        else return front+1;
    }
};
```







#### 26. 删除有序数组中的重复项(简单)

快慢指针，

这里发现，是删除，最好不要使用交换，删除意味着可以直接覆盖，因为要保持删除后元素的相对顺序

因此使用快慢指针，**题目已排序**，快指针寻找新元素，慢指针填充元素

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // 快慢指针
        int slow = 0;
        int fast = 1;

        for(;fast<nums.size();fast++){
            if(nums[slow] != nums[fast]){
                if(fast-slow > 1){
                    nums[++slow] = nums[fast];
                }else{
                    slow++;
                }
            }
        }

        return slow+1;

    }
};
```









#### 283. 移动零

边界条件数清楚即可，方法一较慢，方法二较快

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        //方法一：快慢指针使用swap，快指针寻找第一个非0，慢指针寻找第一个0
        
        int slow = -1;
        for(slow = 0; slow < nums.size();slow++){
            if(nums[slow] == 0){
                break;
            }
        }

        if(slow == nums.size()) return;


        int fast = slow + 1;
        // 上面的预处理保证了slow不会比fast快，因为每次交换都是代表fast前一定有0
        for(;fast < nums.size();fast++){
            if(nums[fast] != 0){
                std::swap(nums[slow],nums[fast]);
                while(nums[slow]){
                    slow++;
                }
            }
        }

        


        // 第二个方法
        // 慢指针逐个递增,指向被覆盖的地方
        // 快指针逐个指向需要被移动到前面的数
        // 完成后将剩余的赋值0
        // 需要注意nums[0]==0的情况
        int slow = 0;
        int fast = 1;
        // 处理开头
        if(nums[slow] == 0){
            while(fast < nums.size() && !nums[fast]){
                fast++;
            }
            // for situation [0]
            if(fast < nums.size())
            {
                nums[slow] = nums[fast];
            }
            else return;
            slow++;
            fast++;
        }else{
            slow++;
        }
        //主体
        for(;fast < nums.size();fast++){
            if(nums[fast]){
                nums[slow++] = nums[fast];
            }
        }

        for(;slow < nums.size();slow++){
            nums[slow] = 0;
        }


        
    }
};
```









#### 844. 比较含退格的字符串

一个方法是模拟（使用栈，或者使用双指针模拟栈）

另一个方法O(1)O(n)是从后往前步进

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        // 除了模拟，可以使用双指针来达成O(1)空间复杂度，即为在s和t上构造最终的字符串（类似于前面的删除题

        // 考虑到删除的特性（删除仅对其之前的起作用），因此倒序遍历可以让我们达成类似从最终字符串尾部开始比较的效果，使得时间复杂度为O(max(s,t))


        int cur_s = s.size()-1;
        int cur_t = t.size()-1;
        int skip_s = 0;
        int skip_t = 0;

        while(cur_s >= 0 || cur_t >= 0){
            // a loop is a jump

            while(cur_s >= 0 && (s[cur_s] == '#' || skip_s))
            {
                if(s[cur_s] == '#'){
                    skip_s++;
                }else{
                    skip_s--;
                }
                cur_s--;
            }

            while(cur_t >= 0 && (t[cur_t] == '#' || skip_t))
            {
                if(t[cur_t] == '#'){
                    skip_t++;
                }else{
                    skip_t--;
                }
                cur_t--;
            }
            
            // now cur pos stand for a comparison pos
            if(cur_s >= 0 && cur_t >= 0) {
                if(s[cur_s] != t[cur_t]) return false;
            }else if(cur_s < 0 && cur_t < 0){
                return true;
            }else
                return false;

            cur_t--;
            cur_s--;

        }

        return true;
        
    }
};
```









#### 977. 有序数组的平方

方法一：平方后排序

方法二：利用其有序性，找到正负分界线双指针填入

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {

        vector<int> ans(nums.size());


        auto it = std::lower_bound(nums.begin(), nums.end(),0);

        int positive = std::distance(nums.begin(), it);
        int negative = positive-1;
        int cur = 0;
        while(positive < nums.size() && negative >= 0){
            if(abs(nums[positive]) > abs(nums[negative])){
                ans[cur++] = nums[negative] * nums[negative];
                negative--;
            }else{
                ans[cur++] = nums[positive] * nums[positive];
                positive++;
            }
        }

        while(positive < nums.size()){
            ans[cur++] = nums[positive]*nums[positive];
            positive++;
        }
        while(negative >= 0){
            ans[cur++] = nums[negative]*nums[negative];
            negative--;
        }

        return ans;


    }
};
```







### 3. 滑动窗口

我觉得滑动窗口叫蜗牛算法或者史莱姆算法更贴切啊（笑）

一般使用双指针来做，end先走一步，然后begin指针开始收缩直到某个条件

#### 209. 长度最小子数组（中等）

每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。





```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.size() ==1){
            return nums[0] > target ? 1 : 0;
        }
        int sum = 0;

        int begin = 0;
        int end = 1;
        sum += nums[0];
        int minLen = INT_MAX;
        while(end < nums.size()){
            
            while(end < nums.size() && sum < target){
                sum += nums[end++];
            }
            while(sum >= target)
            {
                minLen = (end-begin < minLen) ? (end-begin) : minLen;
                sum -= nums[begin++];
            }
        }
        if(begin == 0 && end == nums.size()) return 0;


        return minLen;
    }
};
```



官方写法更优雅

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};


```









#### 904. 水果成篮（中等）

类滑动窗口，维护窗口内类型数量

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        // 这里因为需要“连续选取”的特性，因此仍然可以使用滑动窗口
        // 滑动窗口维护了目前窗口内的类型个数，具体来说使用一个hashmap来维护
        // 类型个数多于2则xxx，小于2则xxxx
        int begin = 0;
        int end = 0;
        int cnt = 0;
        map<int,int> mp;
        int maxLen = 0;
        while(end < fruits.size()){
            // push
            if(mp.find(fruits[end]) == mp.end()){
                mp[fruits[end]] = 1;
                cnt++;
            }else{
                mp[fruits[end]]++;
            }

            while(cnt > 2){
                mp[fruits[begin]]--;
                if(mp[fruits[begin]] == 0){
                    cnt--;
                    mp.erase(fruits[begin]);
                }
                begin++;
            }

            if(end - begin + 1 > maxLen){
                maxLen = end - begin + 1;
            }
            end++;
        }
        return maxLen;
    }
};
```












#### 76. 最小覆盖子串（困难）

一遍过哥们

就是一个滑动窗口，不过维护的又变了，变成了两个字符串用哈希表统计的元素是否符合条件

做了一个优化，就是当收缩`begin`指针的时候，根据当前移除的char直接O(1)判断是否会改变availability

但是在推进end的时候，做了s.size()次的比较，对于类似

`s=DEFGHIJKLMNOPQRSTABC`，`t=ABC`的情况很不友好，意味着比较`s.size()*t.size()`次，这个暂时没想法



不过没超时就是好事

```c++
class Solution {
    bool check(map<char,int>& target, map<char,int>& cur){
        for(auto& p:target){
            if(cur.find(p.first) == cur.end()){
                return false;
            }else{
                if(cur[p.first] < p.second){
                    return false;
                }
            }
        }
        return true;
    }
public:
    string minWindow(string s, string t) {
        map<char, int> mps;
        map<char, int> mpt;

        for(char& c:t){
            if(mpt.find(c) == mpt.end()){
                mpt[c] = 1;
            }else{
                mpt[c]++;
            }
        }





        int begin = 0;
        int end = 0;

        int minLen = INT_MAX;
        int ans_begin = -1;
        while(end < s.size()){
            // push
            if(mps.find(s[end]) == mps.end()){
                mps[s[end]] = 1;
            }else{
                mps[s[end]]++;
            }

            bool old_available = check(mpt,mps);
            // check & shorten
            bool is_available = old_available;
            while(is_available){
                mps[s[begin]]--;
                if( mpt.find(s[begin]) != mpt.end() && 
                    mps[s[begin]] < mpt[s[begin]]){
                        is_available = false;
                    }
                begin++;
            }
			// 如果之前判断是符合的，并且保证了while之后是不符合的，那么一定是上一个begin纳入集合会符合
            if(old_available){
                int length = end - (begin - 1) + 1;
                if(length < minLen){
                    minLen = length;
                    ans_begin = begin-1;
                }
            }
            end++;
        }

        if(ans_begin < 0){
            return "";
        }else{
            return s.substr(ans_begin, minLen);
        }
        
    }
};
```













## 4.模拟题

### 59. 螺旋矩阵II

简单模拟题，递归每次固定操作即可

```c++
class Solution {
    void fill(vector<vector<int>>& ans, int r,int c,int cur,int n){

        if(cur > n*n){return;}

        while(c < n && !ans[r][c]){
            ans[r][c] = cur++;
            c++;
        }
        c--;r++;
        while(r < n && !ans[r][c]){
            ans[r][c] = cur++;
            r++;
        }
        r--;c--;
        while(c >= 0 && !ans[r][c]){
            ans[r][c] = cur++;
            c--;
        }
        c++;r--;
        while(r >= 0 && !ans[r][c]){
            ans[r][c] = cur++;
            r--;
        }
        r++;c++;

        fill(ans,r,c,cur,n);
        return;
    }
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> ans(n,vector<int>(n,0));

        fill(ans,0,0,1, n);
        return ans;
    }
};
```







### 54. 螺旋矩阵

同理，添加一个visited矩阵即可。

```c++
class Solution {
    void solve(vector<int>& ans, vector<vector<int>>& visited, vector<vector<int>>& matrix, int cur, int r, int c){
        int m = matrix.size();
        int n = matrix[0].size();
        if(cur >= n*m) return;
        while(c < n && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            c++;
        }
        c--;r++;
        while(r < m && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            r++;
        }
        r--;c--;
        while(c >= 0 && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            c--;
        }
        c++;r--;
        while(r >= 0 && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            r--;
        }
        r++;c++;
        solve(ans,visited,matrix,cur,r,c);
        return;
    }
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans(matrix.size()*matrix[0].size());
        vector<vector<int>> visited(matrix.size(),vector<int>(matrix[0].size(),0));

        solve(ans, visited, matrix,0, 0, 0);
        return ans;
    }
};
```





### LCR146. 螺旋遍历二维数组

同上

```c++
class Solution {
    void solve(vector<int>& ans, vector<vector<int>>& visited, vector<vector<int>>& matrix, int cur, int r, int c){
        int m = matrix.size();
        int n = matrix[0].size();
        if(cur >= n*m) return;
        while(c < n && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            c++;
        }
        c--;r++;
        while(r < m && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            r++;
        }
        r--;c--;
        while(c >= 0 && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            c--;
        }
        c++;r--;
        while(r >= 0 && !visited[r][c]){
            ans[cur++] = matrix[r][c];
            visited[r][c] = 1;
            r--;
        }
        r++;c++;
        solve(ans,visited,matrix,cur,r,c);
        return;
    }
public:
    vector<int> spiralArray(vector<vector<int>>& matrix) {
        if(matrix.empty()) return {};
        vector<int> ans(matrix.size()*matrix[0].size());
        vector<vector<int>> visited(matrix.size(),vector<int>(matrix[0].size(),0));

        solve(ans, visited, matrix,0, 0, 0);
        return ans;
    }
};
```













## 5. 前缀和

前缀和通常用于减少**连续区间**内的重复运算

### 58.区间和(Karma code)

https://kamacoder.com/problempage.php?pid=1070

一个简单的想法就是维护一个前缀和数组nums，

nums[i]代表算上第i个给定数据的前缀和

因此，如果需要获得[a,b]范围内的和，注意这里a,b是从零开始的，也就是包含第a+1和b+1个数据，因此直接nums[b+1]-nums[a]即可

```c++
#include<iostream>
#include<vector>
int main(){
    int n;
    std::cin >> n;
    std::vector<int> nums(n+1);
    
    int sum = 0;
    nums[0] = 0;
    for(int i = 1; i <= n; i++){
        int temp;
        std::cin >> temp;
        sum += temp;
        nums[i] = sum;
    }
    
    
    
    int begin,end;
    while(std::cin >> begin >> end){
        std::cout << (nums[end+1]-nums[begin]) << std::endl;
    }
}
```



