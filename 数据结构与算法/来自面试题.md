# 1. 携程

##  2024.4.16晚第三题: dp+素数筛

游游拿到了一个数组，每次操作可以将相邻的两个素数元素进行合并，合并后的新数为原来的两个数之和，并删除原来的两个数。游游喜旺最终数组的元素==尽可能少==。



>输入一个整数n，代表数组大小
>
>输入n个整数$a_i$，代表数组的元素
>
>$1\leq n \leq 1e5$
>
>$1\leq a_i \leq 1e6$
>
>输出合并结束后的元素数量

示例:

>5
>
>1 3 2 5 4
>
>3



>5
>
>1 5 3 2 4
>
>3



注意，要求尽可能少，因此不能使用贪心，因为考虑"5 3 2"这样的连续素数子串，它实际上是先合并3 2较优。



因此，大体思路如下：

* 找出连续素数子串
* 对每个子串dp求解

dp数组构造为如下
$$
dp[i][j] = max(dp[i][k], dp[k+1][j])
$$
$dp[i][j]$：代表[i,j]区间内的最大减去的数量

考虑到$dp[i][k] + dp[k+1][j]$合并时需要考虑边界是否能再次合并，因此$dp[i][j]$需要自定义结构

```c++
class prime_unit {
public:
	std::vector<int> range;
	int minus_count;

	prime_unit(std::vector<int> range_, int minus_count_)
		:range{range_}, minus_count{minus_count_} {}

	prime_unit operator+(const prime_unit& other) const {

		std::vector<int> merged_range = range;

		int merged_minus_count = this->minus_count + other.minus_count;

		// 合并区间
		merged_range.insert(merged_range.end(), other.range.begin(), other.range.end());

		
		//std::cout << "面对的两个vector为" << std::endl;
		//std::cout << " 左序列" << std::endl;
		//for (int i = 0; i < range.size(); i++) {
		//	std::cout << range[i] << " ";
		//}
		//std::cout << std::endl;
		//std::cout << " 右序列" << std::endl;
		//for (int i = 0; i < other.range.size(); i++) {
		//	std::cout << other.range[i] << " ";
		//}
		//std::cout << std::endl;
		//std::cout << "merged_range大小为" << merged_range.size() << std::endl;
		//std::cout << "需要访问的两个位置为" << this->range.size() - 1 << " " << this->range.size() << std::endl;

		// 若是合并后产生连续素数
		if (is_prime[merged_range[this->range.size() - 1]] && is_prime[merged_range[this->range.size()]]) {
			// remove these two
			int temp = merged_range[range.size() - 1] + merged_range[range.size()];
			merged_range.erase(merged_range.begin() + range.size() - 1, merged_range.begin() + range.size() - 1 + 2);

			merged_range.insert(merged_range.begin() + (range.size() - 1), temp);

			merged_minus_count++;
		}

		

		return prime_unit(merged_range, merged_minus_count);
	}


	bool operator<(const prime_unit& other) const {
		return this->minus_count < other.minus_count;
	}

};
```

使用如上结构，其包含一个[i,j]区间内的最优子序列，以及[i,j]区间内的最大消去元素个数。

* 自定义`+`，判断左区间的最右与右区间的最左是否能合并
* 自定义比较，使得std::max能够使用。

以下是全部代码，具体来说就是打个表，然后dp，注意子序列的生成方式。

注意dp的三层循环是:区间长度->区间开始->区间内隔断

最好使用中间变量增加可读性。

```c++
void print_vector(std::vector<int> vec) {
	for (int i = 0; i < vec.size(); i++) {
		std::cout << vec[i] << " ";
	}
	std::cout << std::endl;
}


std::vector<bool> is_prime;
std::vector<bool> Eratosthenes(int n) {
	std::vector<bool> prime_list(n + 1, true);

	prime_list[0] = false;
	prime_list[1] = false;

	for (int i = 2; i * i <= n; i++) {
		if (prime_list[i]) {
			for (int j = i * i; j <= n; j+= i) {
				prime_list[j] = false;
			}
		}
	}
	return prime_list;
	
}

class prime_unit {
public:
	std::vector<int> range;
	int minus_count;

	prime_unit(std::vector<int> range_, int minus_count_)
		:range{range_}, minus_count{minus_count_} {}

	prime_unit operator+(const prime_unit& other) const {

		std::vector<int> merged_range = range;

		int merged_minus_count = this->minus_count + other.minus_count;

		// 合并区间
		merged_range.insert(merged_range.end(), other.range.begin(), other.range.end());

		
		//std::cout << "面对的两个vector为" << std::endl;
		//std::cout << " 左序列" << std::endl;
		//for (int i = 0; i < range.size(); i++) {
		//	std::cout << range[i] << " ";
		//}
		//std::cout << std::endl;
		//std::cout << " 右序列" << std::endl;
		//for (int i = 0; i < other.range.size(); i++) {
		//	std::cout << other.range[i] << " ";
		//}
		//std::cout << std::endl;
		//std::cout << "merged_range大小为" << merged_range.size() << std::endl;
		//std::cout << "需要访问的两个位置为" << this->range.size() - 1 << " " << this->range.size() << std::endl;

		// 若是合并后产生连续素数
		if (is_prime[merged_range[this->range.size() - 1]] && is_prime[merged_range[this->range.size()]]) {
			// remove these two
			int temp = merged_range[range.size() - 1] + merged_range[range.size()];
			merged_range.erase(merged_range.begin() + range.size() - 1, merged_range.begin() + range.size() - 1 + 2);

			merged_range.insert(merged_range.begin() + (range.size() - 1), temp);

			merged_minus_count++;
		}

		

		return prime_unit(merged_range, merged_minus_count);
	}


	bool operator<(const prime_unit& other) const {
		return this->minus_count < other.minus_count;
	}

};

int dp_solve_range(std::vector<int> data) {
	//[i,j]区间内的最大minus_count
	if (data.size() == 2) {
		return 1;
	}
	int num = data.size();

	// 构造dp表
	std::vector<std::vector<prime_unit>> dp(data.size(),
											std::vector<prime_unit>(data.size(),
																	prime_unit({},0)));

	for (int i = 0; i < num; i++) {
		// 可优化，添加移动语义
		dp[i][i] = prime_unit({ data[i] }, 0);
	}

	// 区间长度-起始点-区间内分割点
	for (int len = 2; len <= data.size(); len++)
	{
		// 可访问的最后一个为begin + len - 1
		for (int begin = 0; begin + len - 1 < data.size(); begin++) 
		{
			int end = begin + len - 1;
			for (int k = begin; k < end; k++) 
			{
				
				//std::cout << "dp使用的区间为[" << begin << "," << begin+len-1 << "]" << std::endl;
				//std::cout << "其搜找的两个区间为[" << begin << "," <<k << "]" << std::endl;
				//std::cout << "与[" << k+1 << "," << begin + len - 1 << "]" << std::endl;


				dp[begin][end] = std::max(dp[begin][end], dp[begin][k] + dp[k + 1][end]);
			}
		}
	}
	
	return dp[0][num - 1].minus_count;
}


int num_able_to_merge(std::vector<int> data) {
	
	int count = data.size();
	for (int i = 0; i < data.size();) {
		// 非连续素数的话正常+1，连续素数的话i最后在最后一个素数后
		int temp = i;
		// 找到不是素数为止
		while (i < data.size() && is_prime[data[i]]) {
			i++;
		}
		if (temp == i) {
			i++;
			continue;
		}
		// 传入子序列
		std::vector<int>test(data.begin() + temp, data.begin() + i);
		// print_vector(test);
		int minus = dp_solve_range(test);
		count -= minus;
	}
	return count;
}

int main() {
	const int num_range = 1000000 + 5;
	int n;
	std::vector<int> data;
	std::cin >> n;
	for (int i = 0; i < n; i++) {
		int temp;
		std::cin >> temp;
		data.push_back(temp);
	}
	
	is_prime = Eratosthenes(num_range);

	std::cout << num_able_to_merge(data);



}

```

















## 2024.4.16晚第四题: BFS（未写完，思路确定）

游游定义了一个树的直径为任意两个节点的距离的最大值，现在游游拿到了一颗树

她定义$f(i)$为：对$i$号节点上再连接一个新的叶子节点之后，树的直径长度。游游希望你求出$f(1)$到$f(n)$的值



> 输入一个整数n，代表树的节点数量
>
> 接下来n-1行，每行输入两个正整数u,v， 代表u号节点和v号节点有一条长度为1的边链接
>
> $1\leq n \leq 1e5$
>
> $1\leq u,v\leq n$​
>
> 输出n行，第i行代表f(i)的值

> 5
>
> 1 2
>
> 2 3
>
> 3 4
>
> 2 5
>
> 输出
>
> 4
>
> 3
>
> 3
>
> 4
>
> 4

首先，我们知道，树一定是无环全连通的，就是一次DFS就能遍历一遍。



**寻找直径**：

选择任意一个节点，寻找离其最远的节点A。

从节点A，寻找离其最远的节点B。

AB就是直径。

> 证明：
>
> 待写。





```c++
# include<iostream>
# include<string>
# include<unordered_map>
# include<vector>
# include<queue>
# include<cmath>

int BFS_find_farest(std::unordered_map<int, std::vector<int>> um, std::vector<int> &is_accessed, int u) {
	std::queue<int> this_layer_node;
	is_accessed[u] = true;
	for (int i = 0; i < um[u].size(); i++) {
		if (!is_accessed[um[u][i]]) {
			this_layer_node.push(um[u][i]);
		}
	}
	
}

int main() {
	// node->node_list
	std::unordered_map<int, std::vector<int>> um;
	int n;
	std::cin >> n;
	std::vector<int> is_accessed(n,false);


	for (int i = 0; i < n - 1; i++) {
		int u, v;
		std::cin >> u >> v;
		if (um.find(u) == um.end()) {
			um[u] = { v };
		}
		else {
			um[u].push_back(v);
		}

		if (um.find(v) == um.end()) {

			um[v] = { u };

		}
		else {
			um[v].push_back(u);
		}
	}


}
```







## 2024.4.17 晚第三题：Dijkstra + DP

![1c5d4444183a851eb36c3e18d7aad24](./assets/1c5d4444183a851eb36c3e18d7aad24.jpg)

![8bc896fa0aca9c101f8db85ae4da0f0](./assets/8bc896fa0aca9c101f8db85ae4da0f0.jpg)

![985811fc7042b99cbfabf758e04196c](./assets/985811fc7042b99cbfabf758e04196c.jpg)

![397a7e668bb12c3c5aa9b8a5d958da9](./assets/397a7e668bb12c3c5aa9b8a5d958da9.jpg)





Dijkstra获得目标点与其他点的最短距离

DP获得所需的点

注意，需要记录所需点

```c++
# include<iostream>
# include<string>
# include<unordered_map>
# include<vector>
# include<queue>
# include<cmath>
# include<climits>

std::vector<std::pair<int, int>> dijkstra(const std::vector<std::vector<int>>& latency, int start) {
    int n = latency.size();
    std::vector<std::pair<int, int>> dist(n);

    for (int i = 0; i < latency.size(); i++) {
        dist.emplace_back(INT_MAX, i);
    }
    std::vector<bool> visited(n, false);
    dist[start].first = 0;

    // distance-node pair, find the nearest node to be handled
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;
    pq.push({ 0, start });

    while (!pq.empty()) {
        int current = pq.top().second;
        pq.pop();


        if (visited[current]) continue;
        visited[current] = true;

        // relaxation
        for (int j = 0; j < n; ++j) {
            if (latency[current][j] != -1 && !visited[j]) {  
                // if node is connected and not visited
                // start node -> current_node + current_node->node j
                int path = dist[current].first + latency[current][j];
                if (path < dist[j].first) {
                    // update shortest path
                    dist[j].first = path;
                    pq.push({ dist[j].first, j });
                }
            }
        }
    }
    return dist;
}

int main() {
	int n;

	std::vector<std::vector<int>> latency;

	std::vector<int> remain_capacity;

	int faultyNode;

	int Damaged_work;

	std::cin >> n;

	for (int i = 0; i < n; i++) {
		std::vector<int> temp;
		for (int j = 0; j < n; j++) {
			int m;
			std::cin >> m;
			temp.push_back(m);
		}
		latency.push_back(temp);
	}


	for (int i = 0; i < n; i++) {
		int temp;
		std::cin >> temp;
		remain_capacity.push_back(temp);
	}

	std::cin >> faultyNode >> Damaged_work;

    
    std::vector<std::pair<int,int>> dist = dijkstra(latency, faultyNode);

    // dp[i][j]:use only i 个 来填满 j的容量 所需的节点个数
  








}


```







## 2024.4.17 晚第二题

将云服务器看作一颗树，每个云服务在发布前尚未解决的问题称为云服务的遗留问题（云服务的遗留问题包含以该云服务为根节点的树上所有节点的问题），DI值（遗留问题缺陷密度）可以作为评估云服务发布的指标，当云服务DI值小于等于阈值时才准许云服务发布，否则视为风险云服务，需要问题整改完成后重新进行发布评估。

现有一批云服务树，已给出云服务树各节点的问题数量，请通过计算输出风险云服务的个数。



计算公式：$DI值\leq 5\times 严重问题数 + 2 \times 一般问题数$，其中每个结点的不同级别问题数量需要将该节点以及该节点为根节点的所有子节点的相应级别问题数量求和



第一行输入M和N(M <= 100000, N <= 1000)，使用空格分隔，M代表云服务器阈值，N标识接下来有N行问题统计数据



接下来输入一个N*4的矩阵表，行内使用空格分隔，第一列$A_i$为服务节点，第二行$B_i$为$A_i$的父节点，如果$A_i$为云服务则无父节点，此时$B_i$用`*`号标识($A_i$和$B_i$取值为字符串， $1\leq 字符串长度\leq 5$，均由小写英文字母或者`*`组成)，第三列$C_i$为问题级别，($C_i$取值为{0,1}，0表示严重问题，1表示一般问题)，第四列$D_i$为该节点该级别的问题数量($D_i\leq$1000)

说明，输入保证只出现树关系，不会出现连同图情况



输出：风险云服务个数

```markdown
输入：
40 12
a * 0 2
a * 1 2
b a 0 3
b a 1 5
c a 1 3
d a 0 1
d a 1 3
e b 0 2
f * 0 8
f * 1 10
g f 1 2
h * 0 4

输出:
2
```

![image-20240417224246601](./assets/image-20240417224246601.png)

![image-20240417224255526](./assets/image-20240417224255526.png)

![image-20240417224304695](./assets/image-20240417224304695.png)

![image-20240417224313045](./assets/image-20240417224313045.png)
