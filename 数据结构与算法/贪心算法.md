# 1. 贪心算法

## 1.1 分配问题

### 1.1.1 Assign Cookies(Easy) 455

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        std::sort(g.begin(),g.end());
        std::sort(s.begin(), s.end());

        size_t ptr_size = 0;
        size_t ptr_appetite = 0;
        while(ptr_size < s.size() && ptr_appetite < g.size()){
            if(s[ptr_size] >= g[ptr_appetite])
            {
                ptr_appetite++;
                ptr_size++;
            }else{
                ptr_size++;
            }
        }

        return ptr_appetite;
    }
};
```





### 1.1.2 *Candy(Hard) 135

为什么可以使用贪心？

* 显而易见的局部性

为什么可以使用两次遍历？

* 第一次遍历是保证了右边对左边一定是按需大于的
* 第二次遍历是保证了左边对右边一定是按需大于的。
* 因为只需要考虑`i-1`与`i+1`，因此，`i+1`与`i-1`没有任何联系，换句话说，对`i`位置，如果`i-1,i+1`都比`i`大，那么第一次遍历时，只是`i+1`的变了，第二次遍历只是`i-1`变了，`i`是不会收到第一次和第二次遍历影响的。这也证明了两次遍历是独立的。

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        size_t length = ratings.size();
        vector<int> number_of_candy(length,1);
        for(size_t i = 1; i < length;i++){
            if(ratings[i] > ratings[i-1])
            {
                number_of_candy[i] = max(number_of_candy[i-1]+1,number_of_candy[i]);
            }
        }
        for(size_t i = length-1; i > 0;i--){
            if(ratings[i-1] > ratings[i])
            {
                number_of_candy[i-1] = max(number_of_candy[i-1], number_of_candy[i] + 1);
            }
        }
        
        return std::accumulate(number_of_candy.begin(),number_of_candy.end(),0);
    }
};
```









## 1.2 区间问题

### 1.2.1 Non-overlapping Intervals(Medium) 435.

























## 1.3 其余习题

### 1.3.1 Can Place Flowers(Easy)

这里面需要考虑的局部问题就是类似1000...01这样的区间，我们只需要考虑每个这样的区间能够栽种多少个花即可。

假设begin与end,

* 如果0的个数n1 = (end - begin - 1) % 2 == 0, 则能够栽种(n1-1) / 2;
* 否则，能够栽种(n1/2)个花朵。



需要注意：

1. 为了统一，方便管理，我们可以为这个序列前后加上10和01，这样并不会改变这个序列能够栽种的数量。
   * 这种方法直接解决了开头为0和结尾为0的序列
   * 在我的方法中，
     * 我是将begin的初始值设置为-2，表示-2位置flowerbed为1，
     * 在循环结束后，单独处理最后一个区间，将end设置为flowerbed.size()+1
     * 这里end初始值也需要设置为-2是为了类似"0000"这种，begin=end后会不变。
2. 这种方法不需要任何特判，十分好用。

```c++
class Solution {
    int get_usable_number(int n){
        return n%2==0?(n-1)/2:n/2;
    }
public:

    
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        if(n == 0){
            return true;
        }


        int begin = -2, end = -2;
        for(int i = 0;i < flowerbed.size(); i++){
            if(end == -2 && flowerbed[i] == 1){
                end = i;
                n-= get_usable_number(end-begin-1);
                if(n <= 0)
                {
                    return true;
                }   
            }else if(flowerbed[i] == 1){
                begin = end;
                end = i;
                n-= get_usable_number(end-begin-1);
                if(n <= 0)
                {
                    return true;
                }   
            }
            
        }
        //处理结尾，当结尾为0时，循环不会自动处理
        begin = end;
        end = flowerbed.size()+1;
        n -= get_usable_number(end-begin-1);


        if(n > 0)
        {
            return false;
        }
        return true;
    }
        
        
};
```

