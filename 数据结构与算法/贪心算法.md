# 1. 贪心算法

## 1.1 分配问题

### 1.1.1 Assign Cookies(Easy) 455

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        std::sort(g.begin(),g.end());
        std::sort(s.begin(), s.end());

        size_t ptr_size = 0;
        size_t ptr_appetite = 0;
        while(ptr_size < s.size() && ptr_appetite < g.size()){
            if(s[ptr_size] >= g[ptr_appetite])
            {
                ptr_appetite++;
                ptr_size++;
            }else{
                ptr_size++;
            }
        }

        return ptr_appetite;
    }
};
```





### 1.1.2 *Candy(Hard) 135

为什么可以使用贪心？

* 显而易见的局部性

为什么可以使用两次遍历？

* 第一次遍历是保证了右边对左边一定是按需大于的
* 第二次遍历是保证了左边对右边一定是按需大于的。
* 因为只需要考虑`i-1`与`i+1`，因此，`i+1`与`i-1`没有任何联系，换句话说，对`i`位置，如果`i-1,i+1`都比`i`大，那么第一次遍历时，只是`i+1`的变了，第二次遍历只是`i-1`变了，`i`是不会收到第一次和第二次遍历影响的。这也证明了两次遍历是独立的。

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        size_t length = ratings.size();
        vector<int> number_of_candy(length,1);
        for(size_t i = 1; i < length;i++){
            if(ratings[i] > ratings[i-1])
            {
                number_of_candy[i] = max(number_of_candy[i-1]+1,number_of_candy[i]);
            }
        }
        for(size_t i = length-1; i > 0;i--){
            if(ratings[i-1] > ratings[i])
            {
                number_of_candy[i-1] = max(number_of_candy[i-1], number_of_candy[i] + 1);
            }
        }
        
        return std::accumulate(number_of_candy.begin(),number_of_candy.end(),0);
    }
};
```









## 1.2 区间问题

### 1.2.1 Non-overlapping Intervals(Medium) 435.

