# 1. vector<bool>

首先vector< bool> 并不是一个通常意义上的vector容器，这个源自于历史遗留问题。
早在C++98的时候，就有vector< bool>这个类型了，但是因为当时为了考虑到节省空间的想法，所以vector< bool>里面不是一个Byte一个Byte储存的，它是一个bit一个bit储存的！
因为没有直接去给一个bit来操作，所以用operator[]的时候，正常容器返回的应该是一个对应元素的引用，但是对于vector< bool>实际上访问的是一个”proxy reference”而不是一个”true reference”，返回的是”std::vector< bool>:reference”类型的对象。
而一般情况情况下

```c++
vector<bool> c{ false, true, false, true, false };
bool b = c[0];
auto d = c[0];

```

对于b的初始化它其实暗含了一个隐式的类型转换。而对于d，它的类型并不是bool，而是一个vector< bool>中的一个内部类。
而此时如果修改d的值，c中的值也会跟着修改

```c++
d = true;
for(auto i:c)
    cout<<i<<" ";
cout<<endl;
//上式会输出1 1 0 1 0
```

而如果c被销毁，d就会变成一个悬垂指针，再对d操作就属于未定义行为。

所以对于容器一些基本的操作它并不能满足，诸如取地址给指针初始化操作【因为没有办法给单一一个bit来取地址，或者搞引用】

```c++
vector<bool> c{ false, true, false, true, false };
bool &tmp = c[0];   //错误，不能编译，对于引用来说，因为c[0]不是一个左值
bool *p = &c[0];    //错误，不能编译，因为无法将一个临时量地址给绑定到指针
```

所以为什么说vector< bool>不是一个标准容器，就是因为它不能支持一些容器该有的基本操作。







# 2. 不能被复制的packaged_task

在24.2.1中有详细阐述，需要写一个function_wrapper以及模板编程来适应。



# 3. 多线程迭代中的栈溢出

24.4中有详细阐述

# 4. local_thread与静态编译

同样，24.4中有详细阐述，同时补充一点

