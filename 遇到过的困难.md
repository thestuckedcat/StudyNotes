# 1. vector<bool>

首先vector< bool> 并不是一个通常意义上的vector容器，这个源自于历史遗留问题。
早在C++98的时候，就有vector< bool>这个类型了，但是因为当时为了考虑到节省空间的想法，所以vector< bool>里面不是一个Byte一个Byte储存的，它是一个bit一个bit储存的！
因为没有直接去给一个bit来操作，所以用operator[]的时候，正常容器返回的应该是一个对应元素的引用，但是对于vector< bool>实际上访问的是一个”proxy reference”而不是一个”true reference”，返回的是”std::vector< bool>:reference”类型的对象。
而一般情况情况下

```c++
vector<bool> c{ false, true, false, true, false };
bool b = c[0];
auto d = c[0];

```

对于b的初始化它其实暗含了一个隐式的类型转换。而对于d，它的类型并不是bool，而是一个vector< bool>中的一个内部类。
而此时如果修改d的值，c中的值也会跟着修改

```c++
d = true;
for(auto i:c)
    cout<<i<<" ";
cout<<endl;
//上式会输出1 1 0 1 0
```

而如果c被销毁，d就会变成一个悬垂指针，再对d操作就属于未定义行为。

所以对于容器一些基本的操作它并不能满足，诸如取地址给指针初始化操作【因为没有办法给单一一个bit来取地址，或者搞引用】

```c++
vector<bool> c{ false, true, false, true, false };
bool &tmp = c[0];   //错误，不能编译，对于引用来说，因为c[0]不是一个左值
bool *p = &c[0];    //错误，不能编译，因为无法将一个临时量地址给绑定到指针
```

所以为什么说vector< bool>不是一个标准容器，就是因为它不能支持一些容器该有的基本操作。







# 2. 不能被复制的packaged_task

在24.2.1中有详细阐述，需要写一个function_wrapper以及模板编程来适应。



# 3. 多线程迭代中的栈溢出

24.4中有详细阐述

# 4. local_thread与静态编译

同样，24.4中有详细阐述，同时补充一点











# 5. 封装计算cuda kernel运行时间

```c++
#define TIME_GPU(kernellauncher)	\
do						\
{						\
	cudaEvent_t start, stop;\
	cudaEventCreate(&start);\
	cudaEventCreate(&stop);\
	cudaEventRecord(start);\
	kernellauncher();\
	cudaEventRecord(stop);\
	cudaEventSynchronize(stop);\
	float milliseconds = 0;\
	cudaEventElapsedTime(&milliseconds,start, stop);\
	std::cout << "GPU Time taken: " << milliseconds / 1000 << " seconds" << std::endl;\
	cudaEventDestroy(start);\
	cudaEventDestroy(stop);\
} while (0)
```

我原本是使用

```c++
TIME_GPU(origin_copy_if << < 16, 512 >> >(device_result1, device_src, nres1, array_size);)
```

此时会报错参数错误。

预处理器在解析宏时，会试图找到宏参数和宏体之间的逗号`,`来区分不同的参数。在CUDA的kernel启动语法中，`kernel<<<numBlocks, blockSize>>>(args...)`使用的`<<< >>>`并不是标准C++语法的一部分，预处理器可能会错误地将`<<<`和`>>>`内的内容视为宏参数的一部分，尤其是当宏被定义为接受多个参数时。



我使用了lambda表达式包装了一下

```c++
TIME_GPU([&](){
		origin_copy_if << < 16, 512 >> >(device_result1, device_src, nres1, array_size);
	});
```

此时理论上我的参数应该是lambda表达式了对吧，其实还是错了，我认为是因为这个<<<>>>仍然在其中被作为参数直接传递，会引起误判。

修改为

```c++
auto kernel_launcher = [&](){
	origin_copy_if << < 16, 512 >> >(device_result1, device_src, nres1, array_size);
};

TIME_GPU(kernel_launcher);
```

之后就好了。















# 6. 经典的一些template概念混淆

直接查看C++的template.md

